<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emma ‚Ä¢ People</title>
  <link rel="stylesheet" href="../css/main.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0a0a0f;
      color: #ffffff;
      overflow-x: hidden;
      min-height: 100vh;
    }

    /* Emma Aurora Background */
    .aurora-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
    }

    .aurora {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 119, 198, 0.2) 0%, transparent 50%);
      animation: aurora 8s ease-in-out infinite alternate;
    }

    @keyframes aurora {
      0% {
        transform: rotate(0deg) scale(1);
        opacity: 0.8;
      }
      100% {
        transform: rotate(5deg) scale(1.1);
        opacity: 0.6;
      }
    }

    /* Neural Network Background */
    .neural-network {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.1;
    }

    .neural-canvas {
      width: 100%;
      height: 100%;
    }

    /* Main Container */
    .people-container {
      position: relative;
      min-height: 100vh;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
    }

    /* Header */
    .people-header {
      text-align: center;
      margin-bottom: 20px;
    }

    .people-title {
      font-size: 3.5rem;
      font-weight: 300;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 50%, #06b6d4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      letter-spacing: -0.02em;
    }

    .people-subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.7);
      font-weight: 300;
    }

    /* People Grid - Responsive & Fullscreen */
    .people-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 32px;
      width: 100%;
      max-width: 100vw;
      padding: 0 40px;
      margin-bottom: 40px;
      grid-auto-rows: minmax(400px, 1fr);
    }

    /* Responsive grid adjustments */
    @media (min-width: 768px) {
      .people-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (min-width: 1200px) {
      .people-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (min-width: 1600px) {
      .people-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* Person Card with Slideshow Background */
    .person-card {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 48px 32px;
      text-align: center;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 400px;
    }

    /* Memory Slideshow Background */
    .memory-slideshow {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.3; /* Always slightly visible */
      transition: opacity 1s ease;
    }

    .person-card:hover .memory-slideshow,
    .person-card:focus-within .memory-slideshow {
      opacity: 1;
    }

    /* Touch devices - always show slideshow */
    @media (hover: none) and (pointer: coarse) {
      .memory-slideshow {
        opacity: 0.6;
      }
    }

    .memory-slide {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
      opacity: 0;
      transition: opacity 2s ease-in-out;
    }

    .memory-slide.active {
      opacity: 1;
    }

    /* Emma Gradient Overlay */
    .memory-slideshow::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        135deg,
        rgba(139, 92, 246, 0.85) 0%,
        rgba(236, 72, 153, 0.75) 50%,
        rgba(6, 182, 212, 0.85) 100%
      );
      mix-blend-mode: multiply;
      pointer-events: none;
    }

    /* Ensure content stays above slideshow */
    .person-card > *:not(.memory-slideshow) {
      position: relative;
      z-index: 1;
    }

    .person-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(236, 72, 153, 0.1) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 20px;
    }

    .person-card:hover::before {
      opacity: 1;
    }

    .person-card:hover {
      transform: translateY(-8px) scale(1.02);
      border-color: rgba(139, 92, 246, 0.3);
      box-shadow:
        0 20px 40px rgba(139, 92, 246, 0.2),
        0 0 0 1px rgba(139, 92, 246, 0.1);
    }

    /* Person Avatar - Enhanced for slideshow */
    .person-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      margin: 0 auto 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: 700;
      color: white;
      position: relative;
      overflow: hidden;
      box-shadow: 
        0 0 0 4px rgba(255, 255, 255, 0.2),
        0 8px 32px rgba(0, 0, 0, 0.3),
        0 0 80px rgba(139, 92, 246, 0.4);
      transition: all 0.4s ease;
    }

    .person-card:hover .person-avatar {
      transform: scale(1.1);
      box-shadow: 
        0 0 0 6px rgba(255, 255, 255, 0.3),
        0 12px 48px rgba(0, 0, 0, 0.4),
        0 0 120px rgba(236, 72, 153, 0.6);
    }

    .person-avatar.family {
      background: linear-gradient(135deg, #ec4899 0%, #f97316 100%);
    }

    .person-avatar.friend {
      background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
    }

    .person-avatar.colleague {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }

    .person-avatar.other {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    }

    .person-name {
      font-size: 1.8rem;
      font-weight: 700;
      margin-bottom: 8px;
      color: white;
      text-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(139, 92, 246, 0.5);
      letter-spacing: -0.02em;
    }

    .person-relation {
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.9);
      text-transform: capitalize;
      margin-bottom: 16px;
      font-weight: 500;
      padding: 6px 16px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      backdrop-filter: blur(10px);
      display: inline-block;
    }

    .person-contact {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Inter', -apple-system, sans-serif;
      margin-top: auto;
      padding-top: 16px;
    }

    /* Add Person Card */
    .add-person-card {
      background: rgba(139, 92, 246, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px dashed rgba(139, 92, 246, 0.3);
      border-radius: 20px;
      padding: 60px 32px;
      text-align: center;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 280px;
    }

    .add-person-card:hover {
      transform: translateY(-8px) scale(1.02);
      border-color: rgba(139, 92, 246, 0.6);
      background: rgba(139, 92, 246, 0.15);
      box-shadow:
        0 20px 40px rgba(139, 92, 246, 0.3),
        0 0 0 1px rgba(139, 92, 246, 0.2);
    }

    .add-person-icon {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      font-size: 24px;
      transition: transform 0.3s ease;
    }

    .add-person-card:hover .add-person-icon {
      transform: scale(1.1) rotate(180deg);
    }

    .add-person-text {
      font-size: 1.2rem;
      font-weight: 600;
      color: white;
      margin-bottom: 8px;
    }

    .add-person-subtitle {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 24px;
      width: 90%;
      max-width: 420px;
      max-height: 85vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: transform 0.3s ease;
      position: relative;
    }

    .modal-overlay.active .modal {
      transform: scale(1) translateY(0);
    }

    .modal-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: white;
      margin-bottom: 6px;
    }

    .modal-subtitle {
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
    }

    .modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.6);
      font-size: 20px;
      cursor: pointer;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .modal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    /* Form Styles */
    .form-group {
      margin-bottom: 18px;
    }

    .form-label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 6px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      color: white;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: rgba(139, 92, 246, 0.6);
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
      background: rgba(255, 255, 255, 0.15);
    }

    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .form-select option {
      background: #1a1a2e;
      color: white;
    }

    /* Avatar Upload Styles */
    .avatar-upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .avatar-preview {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 2px dashed rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
    }

    .avatar-preview:hover {
      border-color: rgba(139, 92, 246, 0.6);
      background: rgba(139, 92, 246, 0.1);
    }

    .avatar-placeholder {
      text-align: center;
      color: rgba(255, 255, 255, 0.6);
      transition: all 0.3s ease;
    }

    .avatar-preview:hover .avatar-placeholder {
      color: rgba(139, 92, 246, 0.8);
    }

    .avatar-icon {
      font-size: 1.5rem;
      margin-bottom: 4px;
    }

    .avatar-text {
      font-size: 0.7rem;
      font-weight: 500;
    }

    .avatar-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }

    .avatar-upload-btn {
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .avatar-upload-btn:hover {
      background: rgba(139, 92, 246, 0.2);
      border-color: rgba(139, 92, 246, 0.4);
      color: white;
    }

    .avatar-remove-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: rgba(239, 68, 68, 0.9);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .avatar-preview:hover .avatar-remove-btn {
      opacity: 1;
    }

    .form-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 10px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    /* Home Button */
    .home-button {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 100;
      box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
    }

    .home-button:hover {
      transform: translateY(-3px) scale(1.1);
      box-shadow: 0 15px 30px rgba(139, 92, 246, 0.4);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 80px 20px;
      grid-column: 1 / -1;
    }

    .empty-state-icon {
      font-size: 4rem;
      margin-bottom: 24px;
      opacity: 0.5;
    }

    .empty-state-text {
      font-size: 1.4rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 12px;
    }

    .empty-state-subtitle {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.5);
    }

    /* Person Detail Modal Styles */
    .person-detail-modal {
      max-width: 500px;
      max-height: 80vh;
    }

    .person-detail-header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 32px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .person-detail-avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }

    .person-detail-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }

    .person-detail-info {
      flex: 1;
    }

    .person-detail-name {
      font-size: 1.8rem;
      font-weight: 600;
      color: white;
      margin: 0 0 8px 0;
    }

    .person-detail-relation {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin: 0;
      text-transform: capitalize;
    }

    .person-detail-content {
      margin-bottom: 32px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title::before {
      content: '';
      width: 3px;
      height: 16px;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      border-radius: 2px;
    }

    .detail-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .detail-item:last-child {
      border-bottom: none;
    }

    .detail-label {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 500;
    }

    .detail-value {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.9);
      text-align: right;
    }

    .person-detail-actions {
      display: flex;
      gap: 12px;
    }

    .person-detail-actions .btn {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Edit Modal Specific Styles */
    .avatar-edit-buttons {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .avatar-remove-btn-edit {
      padding: 6px 12px;
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 6px;
      color: rgba(239, 68, 68, 0.8);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .avatar-remove-btn-edit:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.6);
      color: #ef4444;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
      flex: 0 0 auto;
      min-width: 100px;
    }

    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(239, 68, 68, 0.3);
    }

    .form-actions .btn-danger {
      margin-right: auto;
    }

    /* Responsive - iPad and smaller */
    @media (max-width: 768px) {
      .people-title {
        font-size: 2.5rem;
      }

      .people-container {
        padding: 20px 16px;
      }

      .people-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        padding: 0 20px;
        grid-auto-rows: minmax(350px, 1fr);
      }

      .person-card {
        min-height: 350px;
        padding: 32px 24px;
      }

      .person-avatar {
        width: 100px;
        height: 100px;
        font-size: 40px;
      }

      .person-name {
        font-size: 1.5rem;
      }
    }

    /* Mobile phones */
    @media (max-width: 480px) {
      .people-grid {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .modal {
        padding: 20px;
        margin: 16px;
        max-width: calc(100vw - 32px);
        max-height: 90vh;
      }

      .modal-title {
        font-size: 1.3rem;
      }

      .avatar-preview {
        width: 80px;
        height: 80px;
      }

      .form-group {
        margin-bottom: 16px;
      }

      .form-actions {
        margin-top: 20px;
        gap: 10px;
      }

      .btn {
        padding: 10px;
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body>
  <!-- Aurora Background -->
  <div class="aurora-bg">
    <div class="aurora"></div>
  </div>

  <!-- Neural Network Background -->
  <div class="neural-network">
    <canvas id="neural-canvas" class="neural-canvas"></canvas>
  </div>

  <!-- Main Container -->
  <div class="people-container">
    <!-- Header -->
    <div class="people-header">
      <h1 class="people-title">emma</h1>
      <p class="people-subtitle">Your Network of Connections</p>
    </div>

    <!-- People Grid -->
    <div class="people-grid" id="people-grid">
      <!-- Add Person Card -->
      <div class="add-person-card" onclick="openAddPersonModal()">
        <div class="add-person-icon">‚ú®</div>
        <div class="add-person-text">Add Someone Special</div>
        <div class="add-person-subtitle">Expand your network of memories</div>
      </div>

      <!-- Empty State (shown when no people) -->
      <div class="empty-state" id="empty-state" style="display: none;">
        <div class="empty-state-icon">üë•</div>
        <div class="empty-state-text">No connections yet</div>
        <div class="empty-state-subtitle">Start building your network of meaningful relationships</div>
      </div>
    </div>
  </div>

  <!-- Add Person Modal -->
  <div class="modal-overlay" id="modal-overlay">
    <div class="modal">
      <button class="modal-close" onclick="closeAddPersonModal()">√ó</button>

      <div class="modal-header">
        <h2 class="modal-title">Add New Person</h2>
        <p class="modal-subtitle">Add someone to your network of family, friends, and connections</p>
      </div>

      <form id="add-person-form" onsubmit="handleAddPerson(event)">
        <!-- Avatar Upload Section -->
        <div class="form-group">
          <label class="form-label">Profile Picture</label>
          <div class="avatar-upload-container">
            <div class="avatar-preview" id="avatar-preview">
              <div class="avatar-placeholder">
                <div class="avatar-icon">üì∑</div>
                <div class="avatar-text">Add Photo</div>
              </div>
            </div>
            <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
            <button type="button" class="avatar-upload-btn" onclick="document.getElementById('avatar-upload').click()">
              Choose Photo
            </button>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="person-name">Full Name *</label>
          <input type="text" id="person-name" class="form-input" placeholder="Enter full name" required>
        </div>

        <div class="form-group">
          <label class="form-label" for="person-email">Email Address</label>
          <input type="email" id="person-email" class="form-input" placeholder="person@example.com">
        </div>

        <div class="form-group">
          <label class="form-label" for="person-phone">Phone Number</label>
          <input type="tel" id="person-phone" class="form-input" placeholder="+1 (555) 123-4567">
        </div>

        <div class="form-group">
          <label class="form-label" for="person-relation">Relationship *</label>
          <select id="person-relation" class="form-select" required>
            <option value="">Select relationship type</option>
            <option value="family">Family</option>
            <option value="friend">Friend</option>
            <option value="colleague">Colleague</option>
            <option value="other">Other</option>
          </select>
        </div>

        <div class="form-actions">
          <button type="button" class="btn btn-secondary" onclick="closeAddPersonModal()">Cancel</button>
          <button type="submit" class="btn btn-primary">Add Person</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Person Detail Modal -->
  <div class="modal-overlay" id="person-detail-modal">
    <div class="modal person-detail-modal">
      <button class="modal-close" onclick="closePersonDetailModal()">√ó</button>

      <div class="person-detail-header">
        <div class="person-detail-avatar" id="person-detail-avatar">
          <div class="avatar-placeholder">
            <div class="avatar-icon">üë§</div>
          </div>
        </div>
        <div class="person-detail-info">
          <h2 class="person-detail-name" id="person-detail-name">Person Name</h2>
          <p class="person-detail-relation" id="person-detail-relation">Relationship</p>
        </div>
      </div>

      <div class="person-detail-content">
        <div class="detail-section">
          <h3 class="section-title">Contact Information</h3>
          <div class="detail-item" id="person-contact-info">
            <span class="detail-label">Contact:</span>
            <span class="detail-value">No contact information</span>
          </div>
        </div>

        <div class="detail-section">
          <h3 class="section-title">Memory Connection</h3>
          <div class="detail-item">
            <span class="detail-label">Added:</span>
            <span class="detail-value" id="person-created-date">Recently</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Memories:</span>
            <span class="detail-value">0 shared memories</span>
          </div>
        </div>
      </div>

      <div class="person-detail-actions">
        <button class="btn btn-secondary" onclick="editPerson()">
          <span>‚úèÔ∏è</span>
          Edit Person
        </button>
        <button class="btn btn-primary" onclick="createMemoryWithPerson()">
          <span>‚ú®</span>
          Create Memory
        </button>
      </div>
    </div>
  </div>

  <!-- Edit Person Modal -->
  <div class="modal-overlay" id="edit-person-modal">
    <div class="modal">
      <button class="modal-close" onclick="closeEditPersonModal()">√ó</button>

      <div class="modal-header">
        <h2 class="modal-title">Edit Person</h2>
        <p class="modal-subtitle">Update their information and avatar</p>
      </div>

      <form id="edit-person-form" onsubmit="handleEditPerson(event)">
        <!-- Avatar Edit Section -->
        <div class="form-group">
          <label class="form-label">Profile Picture</label>
          <div class="avatar-upload-container">
            <div class="avatar-preview" id="edit-avatar-preview">
              <div class="avatar-placeholder">
                <div class="avatar-icon">üì∑</div>
                <div class="avatar-text">Change Photo</div>
              </div>
            </div>
            <input type="file" id="edit-avatar-upload" accept="image/*" style="display: none;">
            <div class="avatar-edit-buttons">
              <button type="button" class="avatar-upload-btn" onclick="document.getElementById('edit-avatar-upload').click()">
                Change Photo
              </button>
              <button type="button" class="avatar-remove-btn-edit" onclick="removeEditAvatar()">
                Remove
              </button>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="edit-person-name">Full Name *</label>
          <input type="text" id="edit-person-name" class="form-input" placeholder="Enter full name" required>
        </div>

        <div class="form-group">
          <label class="form-label" for="edit-person-email">Email Address</label>
          <input type="email" id="edit-person-email" class="form-input" placeholder="person@example.com">
        </div>

        <div class="form-group">
          <label class="form-label" for="edit-person-phone">Phone Number</label>
          <input type="tel" id="edit-person-phone" class="form-input" placeholder="+1 (555) 123-4567">
        </div>

        <div class="form-group">
          <label class="form-label" for="edit-person-relation">Relationship *</label>
          <select id="edit-person-relation" class="form-select" required>
            <option value="">Select relationship type</option>
            <option value="family">Family</option>
            <option value="friend">Friend</option>
            <option value="colleague">Colleague</option>
            <option value="other">Other</option>
          </select>
        </div>

        <div class="form-actions">
          <button type="button" class="btn btn-danger" onclick="deletePerson()">
            <span>üóëÔ∏è</span>
            Delete
          </button>
          <button type="button" class="btn btn-secondary" onclick="closeEditPersonModal()">Cancel</button>
          <button type="submit" class="btn btn-primary">
            <span>üíæ</span>
            Save Changes
          </button>
        </div>
      </form>
    </div>
  </div>

  <!-- Home Button -->
  <button class="home-button" onclick="window.location.href='../dashboard.html'" title="Back to Dashboard">
    üè†
  </button>

  <!-- Universal Vault Modal -->
  <!-- Web Vault System Scripts -->
  <script src="../js/emma-input-modal.js"></script>
  <script src="../js/clean-password-modal.js"></script>
  <script src="../js/emma-web-vault.js"></script>
  <script src="../js/web-vault-status.js"></script>
  <script src="../js/universal-vault-modal.js"></script>
  <script src="../js/modal-helpers.js"></script>

  <script>
    // Initialize vault system for people management
    document.addEventListener('DOMContentLoaded', () => {

      // CRITICAL FIX: Don't create new instances - use existing ones from global scripts
      console.log('üîç PEOPLE: Using existing vault instances (no new creation)');

      // FIXED: Wait for vault scripts with LIMIT to prevent infinite loop
      let initAttempts = 0;
      const maxInitAttempts = 25; // 5 seconds max
      
      function initializeVaultForPeople() {
        initAttempts++;
        
        if (initAttempts > maxInitAttempts) {
          console.error('‚ùå PEOPLE: Gave up waiting for vault after 5 seconds');
          return;
        }
        
        if (window.emmaWebVault && typeof window.emmaWebVault.restoreVaultState === 'function') {
          console.log('‚úÖ PEOPLE: Vault found! Attempting to restore vault state...');
          // Try to restore vault state if vault was previously active
          if (sessionStorage.getItem('emmaVaultActive') === 'true') {
            window.emmaWebVault.restoreVaultState()
              .then(result => {
                if (result) {
                  console.log('‚úÖ PEOPLE: Vault state restored successfully');
                } else {
                  console.log('‚ö†Ô∏è PEOPLE: Vault state restore returned false');
                }
              })
              .catch(error => {
                console.warn('‚ö†Ô∏è PEOPLE: Could not restore vault state:', error);
              });
          } else {
            console.log('üë• PEOPLE: No active vault session found');
          }
        } else {
          console.log(`üë• PEOPLE: Vault not ready yet, waiting... (${initAttempts}/${maxInitAttempts})`);
          setTimeout(initializeVaultForPeople, 200);
        }
      }

      // Start vault initialization
      setTimeout(initializeVaultForPeople, 100);
    });

    // Neural network animation
    function initNeuralNetwork() {
      const canvas = document.getElementById('neural-canvas');
      const ctx = canvas.getContext('2d');

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      resize();
      window.addEventListener('resize', resize);

      const nodes = [];
      const connections = [];

      // Create nodes
      for (let i = 0; i < 15; i++) {
        nodes.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          radius: Math.random() * 2 + 1
        });
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update nodes
        nodes.forEach(node => {
          node.x += node.vx;
          node.y += node.vy;

          if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
          if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
        });

        // Draw connections
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.1)';
        ctx.lineWidth = 1;

        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 150) {
              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.stroke();
            }
          }
        }

        // Draw nodes
        ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
        nodes.forEach(node => {
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        requestAnimationFrame(animate);
      }

      animate();
    }

    // People management
    let people = [];
    let currentAvatarFile = null;
    let currentAvatarDataUrl = null;

    // Avatar upload functionality
    document.addEventListener('DOMContentLoaded', () => {
      const avatarUpload = document.getElementById('avatar-upload');
      const avatarPreview = document.getElementById('avatar-preview');

      // Handle file selection
      avatarUpload.addEventListener('change', handleAvatarUpload);

      // Handle click on preview to select file
      avatarPreview.addEventListener('click', () => {
        avatarUpload.click();
      });
    });

    async function handleAvatarUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Validate file type
      if (!file.type.startsWith('image/')) {
        showToast('‚ùå Please select an image file', 'error');
        return;
      }

      // Validate file size (5MB limit)
      if (file.size > 5 * 1024 * 1024) {
        showToast('‚ùå Image must be smaller than 5MB', 'error');
        return;
      }

      try {

        // Convert to data URL for preview and storage
        currentAvatarDataUrl = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });

        currentAvatarFile = file;

        // Update preview
        updateAvatarPreview(currentAvatarDataUrl);

        showToast('‚úÖ Avatar selected', 'success');

      } catch (error) {
        console.error('üì∑ AVATAR: Failed to process avatar:', error);
        showToast('‚ùå Failed to process avatar', 'error');
      }
    }

    function updateAvatarPreview(dataUrl) {
      const preview = document.getElementById('avatar-preview');

      // SECURITY FIX: Use safe DOM creation instead of innerHTML
      preview.innerHTML = ''; // Clear existing content safely

      if (dataUrl) {
        const img = document.createElement('img');
        img.src = dataUrl;
        img.alt = 'Avatar preview';

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'avatar-remove-btn';
        removeBtn.textContent = '√ó';
        removeBtn.title = 'Remove avatar';
        removeBtn.onclick = removeAvatar;

        preview.appendChild(img);
        preview.appendChild(removeBtn);
        preview.style.border = '2px solid rgba(139, 92, 246, 0.6)';
      } else {
        const placeholder = document.createElement('div');
        placeholder.className = 'avatar-placeholder';

        const icon = document.createElement('div');
        icon.className = 'avatar-icon';
        icon.textContent = 'üì∑';

        const text = document.createElement('div');
        text.className = 'avatar-text';
        text.textContent = 'Add Photo';

        placeholder.appendChild(icon);
        placeholder.appendChild(text);
        preview.appendChild(placeholder);
        preview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
      }
    }

    function removeAvatar() {
      currentAvatarFile = null;
      currentAvatarDataUrl = null;
      updateAvatarPreview(null);
      document.getElementById('avatar-upload').value = '';
      showToast('Avatar removed', 'info');
    }

    async function loadPeople() {
      try {
        console.log('üë• PEOPLE: Starting loadPeople...');
        console.log('üë• PEOPLE: emmaAPI available?', !!window.emmaAPI);
        console.log('üë• PEOPLE: emmaAPI.people available?', !!window.emmaAPI?.people);
        console.log('üë• PEOPLE: emmaAPI.people.list available?', !!window.emmaAPI?.people?.list);

        if (!window.emmaAPI || !window.emmaAPI.people || !window.emmaAPI.people.list) {
          console.error('‚ùå PEOPLE: emmaAPI.people.list not available');
          // Show empty state with instructions to unlock vault
          people = [];
          await renderPeople();
          return;
        }

        console.log('üë• PEOPLE: Calling emmaAPI.people.list()...');
        const response = await window.emmaAPI.people.list();
        console.log('üë• PEOPLE: Response received:', response);

        if (response && response.success) {
          people = response.items || [];
          console.log(`üë• PEOPLE: Loaded ${people.length} people from vault`);
          await renderPeople();
        } else {
          console.error('‚ùå PEOPLE: Failed to load people:', response);
          people = [];
          await renderPeople();
        }
      } catch (error) {
        console.error('‚ùå PEOPLE: Error loading people:', error);
        people = [];
        await renderPeople();
      }
    }

    async function renderPeople() {
      const grid = document.getElementById('people-grid');
      const emptyState = document.getElementById('empty-state');

      // Clear existing people cards (keep add button)
      const existingCards = grid.querySelectorAll('.person-card');
      existingCards.forEach(card => card.remove());

      if (people.length === 0) {
        emptyState.style.display = 'block';
      } else {
        emptyState.style.display = 'none';

        // Create person cards with avatar loading
        for (const person of people) {
          const card = await createPersonCard(person);
          grid.appendChild(card);
        }

        // If in fallback mode, show affordance to re-enable direct save
        try {
          if (window.emmaWebVault && window.emmaWebVault.isFallbackMode && window.emmaWebVault.isFallbackMode()) {
            window.emmaWebVault.showDirectSaveAffordance && window.emmaWebVault.showDirectSaveAffordance();
          }
        } catch (_) {}
      }
    }

    async function createPersonCard(person) {
      const card = document.createElement('div');
      card.className = 'person-card';

      // Create memory slideshow background
      const slideshow = await createMemorySlideshow(person);
      if (slideshow) {
        card.appendChild(slideshow);
      }

      const avatar = document.createElement('div');
      avatar.className = `person-avatar ${person.relation || 'other'}`;

      // Start with letter, then try to load avatar
      avatar.textContent = person.name.charAt(0).toUpperCase();

      // Prefer direct avatarUrl provided by extension (already reconstructed)
      if (person.avatarUrl) {

        const img = document.createElement('img');
        img.src = person.avatarUrl;
        img.alt = `${person.name} avatar`;
        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 50%;';
        img.onload = () => {
          avatar.innerHTML = '';
          avatar.appendChild(img);

        };
        img.onerror = () => {
          console.error('üì∑ AVATAR: Failed to display avatarUrl for:', person.name);
          // Keep the letter fallback
        };
      // If person has an avatar ID but no avatarUrl, fetch from legacy API as fallback
      } else if (person.avatarId) {
        try {

          // Use web vault to get media directly - SAME AS MEMORY GALLERY
          if (window.emmaWebVault && window.emmaWebVault.isOpen) {
            const avatarData = await window.emmaWebVault.getMedia(person.avatarId);

            if (avatarData) {
              // Convert decrypted data to data URL for display
              const blob = new Blob([avatarData], { type: 'image/jpeg' });
              const dataUrl = URL.createObjectURL(blob);

              const img = document.createElement('img');
              img.src = dataUrl;
              img.alt = `${person.name} avatar`;
              img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 50%;';
              img.onload = () => {
                // Replace letter with image once loaded
                avatar.innerHTML = '';
                avatar.appendChild(img);

              };
              img.onerror = () => {
                console.error('üì∑ AVATAR: Failed to display avatar for:', person.name);
                // Keep the letter fallback
              };
            } else {
              console.warn('üì∑ AVATAR: No avatar data found for:', person.name);
            }
          } else {
            console.warn('üì∑ AVATAR: Web vault not available for avatar loading');
          }
        } catch (error) {
          console.error('üì∑ AVATAR: Error loading avatar for:', person.name, error);
        }
      }

      const name = document.createElement('div');
      name.className = 'person-name';
      name.textContent = person.name;

      const relation = document.createElement('div');
      relation.className = 'person-relation';
      relation.textContent = person.relation || 'other';

      const contact = document.createElement('div');
      contact.className = 'person-contact';
      contact.textContent = person.contact || person.email || person.phone || '';

      // Quick actions (delete) - hidden by default, shown on hover
      const actions = document.createElement('div');
      actions.style.cssText = 'position:absolute; top:8px; right:8px; display:flex; gap:6px; opacity:0; transition:opacity 0.3s ease; z-index:10;';
      
      // Show actions on hover
      card.addEventListener('mouseenter', () => {
        actions.style.opacity = '1';
      });
      card.addEventListener('mouseleave', () => {
        actions.style.opacity = '0';
      });
      
      const delBtn = document.createElement('button');
      delBtn.textContent = 'üóëÔ∏è';
      delBtn.title = 'Delete person';
      delBtn.style.cssText = 'background:rgba(0,0,0,0.7); color:#fff; border:none; border-radius:8px; padding:8px; cursor:pointer; backdrop-filter:blur(10px); transition:all 0.3s ease;';
      delBtn.addEventListener('mouseenter', () => {
        delBtn.style.background = 'rgba(239,68,68,0.8)';
        delBtn.style.transform = 'scale(1.1)';
      });
      delBtn.addEventListener('mouseleave', () => {
        delBtn.style.background = 'rgba(0,0,0,0.7)';
        delBtn.style.transform = 'scale(1)';
      });
      delBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        // SECURITY FIX: Replace confirm with proper modal
        if (!await showConfirmModal(`Delete ${person.name}?`, 'This action cannot be undone.', 'Delete', 'Cancel')) return;
        try {
          if (window.emmaAPI && window.emmaAPI.people && window.emmaAPI.people.delete) {
            const res = await window.emmaAPI.people.delete(person.id);
            if (res && res.success) {
              showToast('‚úÖ Person deleted', 'success');
              await loadPeople();
            } else {
              showToast('‚ùå Failed to delete person', 'error');
            }
          }
        } catch (err) {
          console.error('Delete failed:', err);
          showToast('‚ùå Error deleting person', 'error');
        }
      });
      actions.appendChild(delBtn);
      card.appendChild(actions);

      card.appendChild(avatar);
      card.appendChild(name);
      card.appendChild(relation);
      if (contact.textContent) {
        card.appendChild(contact);
      }

      // Add click handler to open person detail modal
      card.addEventListener('click', () => {
        openPersonDetailModal(person);
      });

      return card;
    }

    function openAddPersonModal() {
      document.getElementById('modal-overlay').classList.add('active');
      document.getElementById('person-name').focus();
    }

    function closeAddPersonModal() {
      document.getElementById('modal-overlay').classList.remove('active');
      document.getElementById('add-person-form').reset();

      // Reset avatar state
      currentAvatarFile = null;
      currentAvatarDataUrl = null;
      updateAvatarPreview(null);
      document.getElementById('avatar-upload').value = '';
    }

    async function handleAddPerson(event) {
      event.preventDefault();

      const name = document.getElementById('person-name').value.trim();
      const email = document.getElementById('person-email').value.trim();
      const phone = document.getElementById('person-phone').value.trim();
      const relation = document.getElementById('person-relation').value;

      if (!name || !relation) {
        // SECURITY FIX: Replace alert with proper modal
        showErrorModal('Required Fields Missing', 'Please fill in all required fields before saving.');
        return;
      }

      try {

        // First, add the person to get their ID
        const personData = {
          name,
          contact: email || phone || null,
          relation
        };

        // If we have an avatar, save it to vault first
        let avatarAttachmentId = null;

        if (currentAvatarDataUrl && currentAvatarFile) {
          try {

            // Use web app for avatar storage
            if (window.emmaWebVault && window.emmaWebVault.isOpen && window.emmaWebVault.vaultData) {
              avatarAttachmentId = await window.emmaWebVault.addMedia({
                name: `avatar_${currentAvatarFile.name}`,
                type: currentAvatarFile.type,
                data: currentAvatarDataUrl
              });

            } else {
              console.warn('üì∑ AVATAR: Extension not available - avatar will not be saved');
            }
          } catch (avatarError) {
            console.error('üì∑ AVATAR: Failed to save avatar to vault:', avatarError);
            showToast('‚ö†Ô∏è Person will be added but avatar upload failed', 'warning');
          }
        } else {

        }

        // Add avatar info to person data if we have it
        if (avatarAttachmentId) {
          personData.avatar = currentAvatarDataUrl; // Use 'avatar' field for web vault
        }

        try {
          const response = await window.emmaAPI.people.add(personData);

          if (response.success) {
            closeAddPersonModal();

            // Wait a moment for extension to finish saving to storage
            setTimeout(async () => {
              await loadPeople(); // Reload to show the new person
            }, 500);

            // Show success message
            const message = avatarAttachmentId ? '‚ú® Person and avatar added successfully!' : '‚ú® Person added successfully!';
            showToast(message, 'success');

            // Reset avatar state
            currentAvatarFile = null;
            currentAvatarDataUrl = null;
            updateAvatarPreview(null);

          } else {
            console.error('Failed to add person:', response);
            showToast('‚ùå Failed to add person: ' + (response.message || response.error), 'error');
          }
        } catch (directSaveError) {
          console.error('‚ùå Direct save error adding person:', directSaveError);

          if (directSaveError.message.includes('Direct save required')) {
            showToast('‚ö†Ô∏è Please click "Enable direct save" to add people', 'warning');
          } else {
            showToast('‚ùå Failed to add person: ' + directSaveError.message, 'error');
          }
        }
      } catch (error) {
        console.error('Error adding person:', error);
        showToast('‚ùå Error adding person', 'error');
      }
    }

    function showToast(message, type) {
      // Simple toast notification
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? 'rgba(16, 185, 129, 0.9)' : 'rgba(239, 68, 68, 0.9)'};
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        backdrop-filter: blur(20px);
        z-index: 2000;
        font-weight: 500;
        transition: all 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }

    function showVaultLockAlert(message) {
      // Create elegant vault lock alert modal
      const alertHTML = `
        <div class="vault-lock-alert-overlay" id="vault-lock-alert" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          backdrop-filter: blur(10px);
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
          opacity: 0;
          visibility: hidden;
          transition: all 0.3s ease;
        ">
          <div class="vault-lock-alert" style="
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            padding: 40px;
            max-width: 400px;
            text-align: center;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s ease;
          ">
            <div class="vault-lock-icon" style="
              font-size: 48px;
              margin-bottom: 16px;
            ">üîí</div>
            <h3 class="vault-lock-title" style="
              color: white;
              font-size: 1.5rem;
              font-weight: 600;
              margin-bottom: 16px;
            ">Vault is Locked</h3>
            <p class="vault-lock-message" style="
              color: rgba(255, 255, 255, 0.8);
              margin-bottom: 32px;
              line-height: 1.5;
            ">${message}</p>
            <div class="vault-lock-actions" style="
              display: flex;
              gap: 12px;
              justify-content: center;
            ">
              <button class="btn btn-secondary" onclick="closeVaultLockAlert()" style="
                padding: 12px 24px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
              ">
                Cancel
              </button>
              <button class="btn btn-primary" onclick="openVaultUnlock()" style="
                padding: 12px 24px;
                border: none;
                background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
                color: white;
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 8px;
              ">
                <span>üîì</span>
                Unlock Vault
              </button>
            </div>
          </div>
        </div>
      `;

      // SECURITY FIX: Use safe DOM creation instead of insertAdjacentHTML
      const alertElement = document.createElement('div');
      alertElement.id = 'vault-lock-alert';
      alertElement.className = 'vault-lock-alert';
      alertElement.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 20px; border-radius: 10px; z-index: 10000; opacity: 0; visibility: hidden; transition: all 0.3s ease;';

      const content = document.createElement('div');
      content.style.cssText = 'text-align: center;';

      const title = document.createElement('h3');
      title.textContent = 'üîí Vault Locked';
      title.style.cssText = 'margin-bottom: 10px; color: #f093fb;';

      const messageElement = document.createElement('p');
      messageElement.textContent = 'Your vault has been locked for security. Please unlock to continue.';
      messageElement.style.cssText = 'margin-bottom: 20px; line-height: 1.5;';

      const unlockBtn = document.createElement('button');
      unlockBtn.textContent = 'Unlock Vault';
      unlockBtn.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;';
      unlockBtn.onclick = () => window.open('popup.html', '_blank');

      content.appendChild(title);
      content.appendChild(messageElement);
      content.appendChild(unlockBtn);
      alertElement.appendChild(content);
      document.body.appendChild(alertElement);

      // Show with animation
      setTimeout(() => {
        const alert = document.getElementById('vault-lock-alert');
        alert.style.opacity = '1';
        alert.style.visibility = 'visible';
        alert.querySelector('.vault-lock-alert').style.transform = 'scale(1) translateY(0)';
      }, 10);
    }

    function closeVaultLockAlert() {
      const alert = document.getElementById('vault-lock-alert');
      if (alert) {
        alert.style.opacity = '0';
        alert.style.visibility = 'hidden';
        setTimeout(() => alert.remove(), 300);
      }
    }

    function openVaultUnlock() {
      closeVaultLockAlert();
      // Show beautiful universal vault unlock modal
      universalVaultModal.show({
        title: "Unlock Vault",
        message: "Please unlock your vault to manage people",
        onSuccess: () => {
          // Refresh the people list after successful unlock
          loadPeople();
          showToast('‚úÖ Vault unlocked successfully!', 'success');
        },
        onCancel: () => {
          // User cancelled - nothing to do

        }
      });
    }

    // Person detail modal functions
    let currentPerson = null;

    async function openPersonDetailModal(person) {
      currentPerson = person;

      // Update modal content
      document.getElementById('person-detail-name').textContent = person.name;
      document.getElementById('person-detail-relation').textContent = person.relation || 'other';

      // Update contact info
      const contactInfo = document.getElementById('person-contact-info');
      if (person.contact) {
        contactInfo.innerHTML = `
          <span class="detail-label">Contact:</span>
          <span class="detail-value">${person.contact}</span>
        `;
      } else {
        contactInfo.innerHTML = `
          <span class="detail-label">Contact:</span>
          <span class="detail-value">No contact information</span>
        `;
      }

      // Update created date
      const createdDate = new Date(person.createdAt).toLocaleDateString();
      document.getElementById('person-created-date').textContent = createdDate;

      // Load avatar for detail view - SAME LOGIC AS PERSON CARDS
      const detailAvatar = document.getElementById('person-detail-avatar');
      detailAvatar.className = `person-detail-avatar ${person.relation || 'other'}`;

      // Use the same logic as createPersonCard - prefer avatarUrl from extension
      // Clear existing content safely
      detailAvatar.innerHTML = '';

      if (person.avatarUrl) {

        // Safely create img element
        const img = document.createElement('img');
        img.src = person.avatarUrl;
        img.alt = `${person.name} avatar`; // Safe - browser escapes alt text
        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 50%;';
        detailAvatar.appendChild(img);
      } else {

        // Safely create placeholder elements
        const placeholder = document.createElement('div');
        placeholder.className = 'avatar-placeholder';

        const icon = document.createElement('div');
        icon.className = 'avatar-icon';
        icon.textContent = person.name.charAt(0).toUpperCase(); // Safe - textContent auto-escapes

        placeholder.appendChild(icon);
        detailAvatar.appendChild(placeholder);
      }

      // Show modal
      document.getElementById('person-detail-modal').classList.add('active');
    }

    function closePersonDetailModal() {
      document.getElementById('person-detail-modal').classList.remove('active');
      currentPerson = null;
    }

    function editPerson() {
      if (!currentPerson) {
        console.error('‚ùå EDIT: No current person selected');
        return;
      }

      // Store the person data before closing detail modal
      const personToEdit = { ...currentPerson };

      // Close detail modal first
      closePersonDetailModal();

      // Small delay to ensure modal is closed before opening edit
      setTimeout(() => {
        openEditPersonModal(personToEdit);
      }, 100);
    }

    // Edit modal state
    let editAvatarFile = null;
    let editAvatarDataUrl = null;
    let editAvatarChanged = false;

    async function openEditPersonModal(person) {
      if (!person) {
        console.error('‚ùå EDIT: Cannot open edit modal - no person data provided');
        return;
      }

      currentPerson = person;

      // Safely populate form fields with null checks
      const nameField = document.getElementById('edit-person-name');
      const emailField = document.getElementById('edit-person-email');
      const phoneField = document.getElementById('edit-person-phone');
      const relationField = document.getElementById('edit-person-relation');

      if (!nameField || !emailField || !phoneField || !relationField) {
        console.error('‚ùå EDIT: Form fields not found');
        return;
      }

      nameField.value = person.name || '';
      emailField.value = person.contact && person.contact.includes('@') ? person.contact : '';
      phoneField.value = person.contact && !person.contact.includes('@') ? person.contact : '';
      relationField.value = person.relation || 'other';

      // Load current avatar
      const editPreview = document.getElementById('edit-avatar-preview');
      if (!editPreview) {
        console.error('‚ùå EDIT: Avatar preview element not found');
        return;
      }

      editPreview.className = `avatar-preview ${person.relation || 'other'}`;

      if (person.avatarId) {
        try {

          const avatarResult = await window.emmaAPI.vault.attachment.get(person.avatarId);
          if (avatarResult && avatarResult.success && avatarResult.dataUrl) {
            editPreview.innerHTML = `
              <img src="${avatarResult.dataUrl}" alt="${person.name} avatar">
              <button type="button" class="avatar-remove-btn" onclick="removeEditAvatar()" title="Remove avatar">√ó</button>
            `;
            editPreview.style.border = '2px solid rgba(139, 92, 246, 0.6)';
            editAvatarDataUrl = avatarResult.dataUrl; // Store current avatar
          } else {
            // No avatar data, show placeholder
            editPreview.innerHTML = `
              <div class="avatar-placeholder">
                <div class="avatar-icon">üì∑</div>
                <div class="avatar-text">Change Photo</div>
              </div>
            `;
            editPreview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
          }
        } catch (error) {
          console.error('üì∑ EDIT: Failed to load avatar for edit:', error);
          // Show placeholder on error
          editPreview.innerHTML = `
            <div class="avatar-placeholder">
              <div class="avatar-icon">üì∑</div>
              <div class="avatar-text">Change Photo</div>
            </div>
          `;
          editPreview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
        }
      } else {
        // No avatar, show placeholder
        editPreview.innerHTML = `
          <div class="avatar-placeholder">
            <div class="avatar-icon">üì∑</div>
            <div class="avatar-text">Change Photo</div>
          </div>
        `;
        editPreview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
      }

      // Reset edit state
      editAvatarFile = null;
      editAvatarChanged = false;

      // Show modal
      const editModal = document.getElementById('edit-person-modal');
      if (editModal) {
        editModal.classList.add('active');

        // Focus on name field after a short delay
        setTimeout(() => {
          const nameField = document.getElementById('edit-person-name');
          if (nameField) {
            nameField.focus();
          }
        }, 200);
      } else {
        console.error('‚ùå EDIT: Edit modal element not found');
      }
    }

    function closeEditPersonModal() {
      const editModal = document.getElementById('edit-person-modal');
      const editForm = document.getElementById('edit-person-form');

      if (editModal) {
        editModal.classList.remove('active');
      }

      if (editForm) {
        editForm.reset();
      }

      // Reset edit state
      editAvatarFile = null;
      editAvatarDataUrl = null;
      editAvatarChanged = false;

      // Reset avatar preview
      const editPreview = document.getElementById('edit-avatar-preview');
      if (editPreview) {
        editPreview.innerHTML = `
          <div class="avatar-placeholder">
            <div class="avatar-icon">üì∑</div>
            <div class="avatar-text">Change Photo</div>
          </div>
        `;
        editPreview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
      }

      currentPerson = null;

    }

    function createMemoryWithPerson() {
      if (!currentPerson) return;

      // Navigate to memory creation with person pre-selected
      window.location.href = `../dashboard.html?createMemory=true&person=${currentPerson.id}`;
    }

    // Close modal on overlay click
    document.getElementById('modal-overlay').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) {
        closeAddPersonModal();
      }
    });

    // Edit avatar upload functionality
    document.addEventListener('DOMContentLoaded', () => {
      const editAvatarUpload = document.getElementById('edit-avatar-upload');
      if (editAvatarUpload) {
        editAvatarUpload.addEventListener('change', handleEditAvatarUpload);
      }
    });

    async function handleEditAvatarUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Validate file type
      if (!file.type.startsWith('image/')) {
        showToast('‚ùå Please select an image file', 'error');
        return;
      }

      // Validate file size (5MB limit)
      if (file.size > 5 * 1024 * 1024) {
        showToast('‚ùå Image must be smaller than 5MB', 'error');
        return;
      }

      try {

        // Convert to data URL
        editAvatarDataUrl = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });

        editAvatarFile = file;
        editAvatarChanged = true;

        // Update preview
        const preview = document.getElementById('edit-avatar-preview');
        if (preview && editAvatarDataUrl) {
          preview.innerHTML = `
            <img src="${editAvatarDataUrl}" alt="Avatar preview">
            <button type="button" class="avatar-remove-btn" onclick="removeEditAvatar()" title="Remove avatar">√ó</button>
          `;
          preview.style.border = '2px solid rgba(139, 92, 246, 0.6)';
        }

        showToast('‚úÖ New avatar selected', 'success');

      } catch (error) {
        console.error('üì∑ EDIT AVATAR: Failed to process avatar:', error);
        showToast('‚ùå Failed to process avatar', 'error');
      }
    }

    function updateEditAvatarPreview(dataUrl) {
      const preview = document.getElementById('edit-avatar-preview');

      if (dataUrl) {
        preview.innerHTML = `
          <img src="${dataUrl}" alt="Avatar preview">
          <button type="button" class="avatar-remove-btn" onclick="removeEditAvatar()" title="Remove avatar">√ó</button>
        `;
        preview.style.border = '2px solid rgba(139, 92, 246, 0.6)';
      } else {
        preview.innerHTML = `
          <div class="avatar-placeholder">
            <div class="avatar-icon">üì∑</div>
            <div class="avatar-text">Change Photo</div>
          </div>
        `;
        preview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
      }
    }

    function removeEditAvatar() {
      editAvatarFile = null;
      editAvatarDataUrl = null;
      editAvatarChanged = true; // Mark as changed (removing avatar)

      // Reset preview
      const preview = document.getElementById('edit-avatar-preview');
      if (preview) {
        preview.innerHTML = `
          <div class="avatar-placeholder">
            <div class="avatar-icon">üì∑</div>
            <div class="avatar-text">Change Photo</div>
          </div>
        `;
        preview.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
      }

      const uploadField = document.getElementById('edit-avatar-upload');
      if (uploadField) {
        uploadField.value = '';
      }

      showToast('Avatar will be removed', 'info');
    }

    async function handleEditPerson(event) {
      event.preventDefault();

      if (!currentPerson) return;

      const name = document.getElementById('edit-person-name').value.trim();
      const email = document.getElementById('edit-person-email').value.trim();
      const phone = document.getElementById('edit-person-phone').value.trim();
      const relation = document.getElementById('edit-person-relation').value;

      if (!name || !relation) {
        showToast('‚ùå Please fill in the required fields', 'error');
        return;
      }

      try {

        // Handle avatar changes
        let newAvatarId = currentPerson.avatarId; // Keep current by default

        if (editAvatarChanged) {
          // Remove old avatar if it exists
          if (currentPerson.avatarId) {
            try {
              await window.emmaAPI.vault.attachment.remove(currentPerson.avatarId);

            } catch (error) {
              console.warn('üì∑ EDIT: Failed to remove old avatar:', error);
            }
          }

          // Upload new avatar if we have one
          if (editAvatarDataUrl && editAvatarFile) {
            try {
              const tempMemoryId = `person_avatar_edit_${Date.now()}`;
              const avatarResult = await window.emmaAPI.vault.attachment.add({
                name: `avatar_${editAvatarFile.name}`,
                type: editAvatarFile.type,
                data: editAvatarDataUrl,
                memoryId: tempMemoryId,
                meta: {
                  caption: `Avatar for ${name}`,
                  isAvatar: true,
                  personName: name
                }
              });

              if (avatarResult && avatarResult.success && avatarResult.id) {
                newAvatarId = avatarResult.id;

              } else {
                console.error('üì∑ EDIT: Failed to save new avatar:', avatarResult);
                showToast('‚ö†Ô∏è Person updated but avatar upload failed', 'warning');
              }
            } catch (error) {
              console.error('üì∑ EDIT: Avatar upload error:', error);
              showToast('‚ö†Ô∏è Person updated but avatar upload failed', 'warning');
            }
          } else {
            // No new avatar, remove the old one
            newAvatarId = null;
          }
        }

        // Update person data
        const updatedPerson = {
          ...currentPerson,
          name,
          contact: email || phone || null,
          relation,
          avatarId: newAvatarId,
          avatarUrl: editAvatarDataUrl // For immediate display
        };

        // Update in vault using the proper update API
        const response = await window.emmaAPI.people.update({
          id: currentPerson.id,
          name,
          contact: email || phone || null,
          relation,
          avatarId: newAvatarId,
          avatarUrl: editAvatarDataUrl
        });

        if (response.success) {
          closeEditPersonModal();
          // Add delay to allow extension to process and save the update
          setTimeout(async () => {
            await loadPeople(); // Reload to show changes
          }, 500);
          showToast('‚úÖ Person updated successfully!', 'success');
        } else {
          console.error('Failed to update person:', response);

          // Handle vault lock error with elegant alert
          if (response.error === 'vault_locked') {
            showVaultLockAlert(response.userMessage || 'Please unlock your vault to edit people');
          } else {
            showToast('‚ùå Failed to update person: ' + (response.message || response.error), 'error');
          }
        }

      } catch (error) {
        console.error('Error updating person:', error);
        showToast('‚ùå Error updating person', 'error');
      }
    }    async function deletePerson() {
      if (!currentPerson) return;

      // SECURITY FIX: Replace confirm with proper modal
      const confirmed = await showConfirmModal(`Delete ${currentPerson.name}?`, 'This action cannot be undone.', 'Delete', 'Cancel');
      if (!confirmed) return;

      try {

        // Remove avatar if it exists (best-effort)
        if (currentPerson.avatarId && window.emmaAPI?.vault?.attachment?.remove) {
          try {
            await window.emmaAPI.vault.attachment.remove(currentPerson.avatarId);

          } catch (error) {
            console.warn('üì∑ DELETE: Failed to remove avatar:', error);
          }
        }

        // Remove person from vault via new API
        const response = await window.emmaAPI.people.delete(currentPerson.id);

        if (response.success) {
          closeEditPersonModal();
          await loadPeople(); // Reload to remove from display
          showToast('‚úÖ Person deleted successfully', 'success');
        } else {
          console.error('Failed to delete person:', response);

          // Handle vault lock error with elegant alert
          if (response.error === 'vault_locked') {
            showVaultLockAlert(response.userMessage || 'Please unlock your vault to remove people');
          } else {
            showToast('‚ùå Failed to delete person: ' + (response.message || response.error), 'error');
          }
        }

      } catch (error) {
        console.error('Error deleting person:', error);
        showToast('‚ùå Error deleting person', 'error');
      }
    }

    // Close person detail modal on overlay click
    document.addEventListener('DOMContentLoaded', () => {
      const personDetailModal = document.getElementById('person-detail-modal');
      if (personDetailModal) {
        personDetailModal.addEventListener('click', (e) => {
          if (e.target === e.currentTarget) {
            closePersonDetailModal();
          }
        });
      }

      const editPersonModal = document.getElementById('edit-person-modal');
      if (editPersonModal) {
        editPersonModal.addEventListener('click', (e) => {
          if (e.target === e.currentTarget) {
            closeEditPersonModal();
          }
        });
      }
    });

    // Create memory slideshow for person
    async function createMemorySlideshow(person) {
      try {
        // Load memories connected to this person
        const memories = await loadMemoriesForPerson(person.id);
        
        if (!memories || memories.length === 0) {
          console.log(`üë§ No memories found for ${person.name}`);
          return null;
        }

        // Collect all photos from memories
        const photos = [];
        for (const memory of memories) {
          if (memory.attachments && memory.attachments.length > 0) {
            for (const attachment of memory.attachments) {
              if (attachment.type && attachment.type.startsWith('image/')) {
                photos.push({
                  id: attachment.id,
                  memory: memory,
                  type: attachment.type
                });
              }
            }
          }
        }

        if (photos.length === 0) {
          console.log(`üì∑ No photos found in memories for ${person.name}`);
          return null;
        }

        console.log(`üé® Creating slideshow for ${person.name} with ${photos.length} photos`);

        // Create slideshow container
        const slideshow = document.createElement('div');
        slideshow.className = 'memory-slideshow';

        // Load and create slides
        let loadedSlides = 0;
        for (let i = 0; i < Math.min(photos.length, 5); i++) { // Limit to 5 photos for performance
          const photo = photos[i];
          const slide = document.createElement('div');
          slide.className = 'memory-slide';
          
          try {
            // Load photo from vault
            if (window.emmaWebVault && window.emmaWebVault.isOpen) {
              const mediaData = await window.emmaWebVault.getMedia(photo.id);
              
              if (mediaData) {
                const blob = new Blob([mediaData], { type: photo.type });
                const url = URL.createObjectURL(blob);
                
                slide.style.backgroundImage = `url(${url})`;
                slideshow.appendChild(slide);
                loadedSlides++;
                
                // First slide active
                if (loadedSlides === 1) {
                  slide.classList.add('active');
                }
              }
            }
          } catch (error) {
            console.error(`‚ùå Failed to load photo ${photo.id}:`, error);
          }
        }

        if (loadedSlides === 0) {
          return null;
        }

        // Start carousel if multiple slides with VARIABLE timing
        if (loadedSlides > 1) {
          let currentSlide = 0;
          
          // Random interval between 3-7 seconds for natural feel
          const randomInterval = 3000 + Math.random() * 4000;
          
          // Add random delay before starting (0-2 seconds)
          const startDelay = Math.random() * 2000;
          
          setTimeout(() => {
            setInterval(() => {
              const slides = slideshow.querySelectorAll('.memory-slide');
              if (slides.length > 1) {
                slides[currentSlide].classList.remove('active');
                currentSlide = (currentSlide + 1) % slides.length;
                slides[currentSlide].classList.add('active');
              }
            }, randomInterval);
          }, startDelay);
        }

        return slideshow;

      } catch (error) {
        console.error(`‚ùå Error creating slideshow for ${person.name}:`, error);
        return null;
      }
    }

    // Load memories connected to a person
    async function loadMemoriesForPerson(personId) {
      try {
        if (!window.emmaWebVault || !window.emmaWebVault.isOpen) {
          console.warn('‚ö†Ô∏è Vault not open, cannot load memories');
          return [];
        }

        const vaultData = window.emmaWebVault.vaultData;
        if (!vaultData || !vaultData.memories) {
          return [];
        }

        // Find memories that include this person
        const connectedMemories = [];
        
        for (const [memoryId, memory] of Object.entries(vaultData.memories)) {
          // Check if person is in memory's people metadata
          if (memory.metadata && memory.metadata.people && 
              Array.isArray(memory.metadata.people) && 
              memory.metadata.people.includes(personId)) {
            connectedMemories.push(memory);
          }
          
          // Also check if person's name is mentioned in content
          const personData = vaultData.people && vaultData.people[personId];
          if (personData && memory.content) {
            const personName = personData.name.toLowerCase();
            const memoryContent = memory.content.toLowerCase();
            if (memoryContent.includes(personName)) {
              // Avoid duplicates
              if (!connectedMemories.find(m => m.id === memory.id)) {
                connectedMemories.push(memory);
              }
            }
          }
        }

        console.log(`üìö Found ${connectedMemories.length} memories for person ${personId}`);
        return connectedMemories;

      } catch (error) {
        console.error('‚ùå Error loading memories for person:', error);
        return [];
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initNeuralNetwork();

      // FIXED: Wait for vault with LIMIT to prevent infinite loop
      let loadAttempts = 0;
      const maxLoadAttempts = 20; // 10 seconds max
      
      function waitForVaultAndLoadPeople() {
        loadAttempts++;
        
        if (loadAttempts > maxLoadAttempts) {
          console.error('‚ùå PEOPLE: Gave up waiting for vault listPeople after 10 seconds');
          console.log('‚ùå PEOPLE: Showing empty state');
          renderPeople(); // Show empty state
          return;
        }
        
        if (window.emmaWebVault && typeof window.emmaWebVault.listPeople === 'function') {
          console.log('‚úÖ PEOPLE: Vault is ready, loading people...');
          loadPeople();
        } else {
          console.log(`üë• PEOPLE: Waiting for vault initialization... (${loadAttempts}/${maxLoadAttempts})`);
          setTimeout(waitForVaultAndLoadPeople, 500);
        }
      }

      // Start checking after a brief delay
      setTimeout(waitForVaultAndLoadPeople, 1000);
    });
  </script>
</body>
</html>
