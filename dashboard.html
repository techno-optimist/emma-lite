<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emma - Your Intelligent Memory Companion</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">

  <!-- Cache busting meta tags -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <!-- Load Emma Core Systems -->
  <script src="js/emma-env.js"></script>
  <script src="js/emma-logger.js"></script>
  <script src="js/modal-manager.js"></script>
  <script src="js/emma-dementia-modals.js"></script>
  <script src="js/emma-font-scaler.js"></script>
  <script src="js/emma-performance-optimizer.js"></script>
  
  <!-- Load Emma Web Vault System -->
  <script src="js/emma-input-modal.js"></script>
  <script src="js/clean-password-modal.js"></script>
  <script src="js/modal-helpers.js"></script>
  <script src="js/emma-feature-flags.js"></script>
  <script src="js/emma-vault-primary.js"></script>
  <script src="js/emma-web-vault.js"></script>
  <script src="js/web-vault-status.js"></script>

  <!-- WEBAPP-FIRST ARCHITECTURE: Communication bridge -->
  <script src="js/webapp-extension-bridge.js"></script>

    <!-- Browser Compatibility Layer - PRODUCTION: Removed for clean deployment -->
  <!-- <script src="emma-browser-compatibility-fix.js"></script> -->
  
  <!-- Mobile UI Fixes - PRODUCTION: Removed for clean deployment -->
  <!-- <script src="emma-mobile-ui-fixes.js"></script> -->

  <!-- VAULT STATE MONITOR: Real-time auto-lock detection -->
  <script src="emma-vault-extension-fixed/vault-state-monitor.js"></script>

  <style>
    /* Emma Brand Variables */
    :root {
      --emma-gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      --emma-gradient-2: linear-gradient(135deg, #4f46e5 0%, #7c3aed 50%, #a855f7 100%);
      --emma-aurora: linear-gradient(135deg, #667eea20 0%, #764ba240 25%, #f093fb20 50%, #4dabf720 75%, #667eea20 100%);
      --emma-bg-gradient: linear-gradient(135deg, #0a0a0f 0%, #1a1033 50%, #0f0c29 100%);
      --emma-purple: #764ba2;
      --emma-pink: #f093fb;
      --emma-blue: #667eea;
      --emma-dark: #0a0a0f;
      --emma-card-bg: rgba(255, 255, 255, 0.03);
      --emma-glass: rgba(255, 255, 255, 0.05);
      --emma-border: rgba(255, 255, 255, 0.1);
      --emma-text: #ffffff;
      --emma-text-secondary: rgba(255, 255, 255, 0.8);
      --emma-text-tertiary: rgba(255, 255, 255, 0.6);
      --emma-success: #4ade80;
      --emma-error: #f87171;
      --emma-warning: #fbbf24;
      --emma-glow: 0 0 40px rgba(134, 88, 255, 0.6);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--emma-bg-gradient);
      color: var(--emma-text);
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Aurora Background Effect */
    .aurora-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.3;
      z-index: 1;
      pointer-events: none;
    }

    .aurora {
      position: absolute;
      width: 200%;
      height: 200%;
      background: var(--emma-aurora);
      animation: aurora 20s ease-in-out infinite;
      filter: blur(60px);
    }

    @keyframes aurora {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
      33% { transform: translate(-30%, -60%) rotate(120deg) scale(1.1); }
      66% { transform: translate(-70%, -40%) rotate(240deg) scale(0.9); }
    }

    /* Main Container */
    .dashboard {
      position: relative;
      width: 100%;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    /* Central Command Orb Container */
    .command-center {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Emma Orb */
    .emma-orb-container {
      position: relative;
      width: 200px;
      height: 200px;
      cursor: pointer;
      transition: transform 0.3s ease;
    }

    .emma-orb-container:hover {
      transform: scale(1.05);
    }

    .emma-orb-webgl {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-shadow: var(--emma-glow), inset 0 0 40px rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
    }

    .emma-orb-webgl canvas {
      border-radius: 50%;
      width: 100% !important;
      height: 100% !important;
    }

    @keyframes orb-pulse {
      0%, 100% { transform: scale(1); box-shadow: var(--emma-glow), inset 0 0 40px rgba(255, 255, 255, 0.1); }
      50% { transform: scale(1.02); box-shadow: 0 0 60px rgba(134, 88, 255, 0.8), inset 0 0 40px rgba(255, 255, 255, 0.2); }
    }

    @keyframes vault-unlock-pulse {
      0% { transform: scale(1); }
      30% { transform: scale(1.1); box-shadow: 0 0 80px rgba(16, 185, 129, 0.8); }
      60% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    /* Orb status removed - clean WebGL orb only */

    .orb-icon {
      font-size: 48px;
      margin-bottom: 8px;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
    }

    /* Orb text removed - clean WebGL orb only */

    /* Neural Network Menu */
    .neural-network {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* CRITICAL FIX: Lower z-index so nodes appear above connections */
    }

    .neural-canvas {
      width: 100%;
      height: 100%;
    }

    .radial-menu {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
    }

    .radial-menu.active {
      opacity: 1;
      pointer-events: all;
    }

    .radial-item {
      position: absolute;
      width: 90px;
      height: 90px;
      background: var(--emma-glass);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(134, 88, 255, 0.3);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0;
      transform: scale(0);
      box-shadow: 0 0 30px rgba(134, 88, 255, 0.2);
      animation: float 6s ease-in-out infinite;
      z-index: 10;
    }

    .radial-menu.active .radial-item {
      opacity: 1;
      transform: scale(1);
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) scale(1); }
      33% { transform: translateY(-10px) scale(1.02); }
      66% { transform: translateY(5px) scale(0.98); }
    }

    /* Elegant add node glow animation */
    @keyframes addNodeGlow {
      0%, 100% { 
        box-shadow: 
          0 0 20px rgba(16, 185, 129, 0.4),
          0 0 40px rgba(16, 185, 129, 0.2),
          inset 0 0 20px rgba(16, 185, 129, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 30px rgba(16, 185, 129, 0.6),
          0 0 60px rgba(16, 185, 129, 0.3),
          inset 0 0 30px rgba(16, 185, 129, 0.15);
      }
    }

    /* Subtle heartbeat animation for people nodes */
    @keyframes heartbeat {
      0%, 100% { 
        box-shadow: 
          0 8px 32px rgba(139, 92, 246, 0.4),
          0 0 20px rgba(239, 68, 68, 0.3),
          0 0 40px rgba(239, 68, 68, 0.1);
      }
      25% { 
        box-shadow: 
          0 8px 32px rgba(139, 92, 246, 0.4),
          0 0 25px rgba(239, 68, 68, 0.4),
          0 0 50px rgba(239, 68, 68, 0.15);
      }
      50% { 
        box-shadow: 
          0 8px 32px rgba(139, 92, 246, 0.4),
          0 0 20px rgba(239, 68, 68, 0.3),
          0 0 40px rgba(239, 68, 68, 0.1);
      }
      75% { 
        box-shadow: 
          0 8px 32px rgba(139, 92, 246, 0.4),
          0 0 25px rgba(239, 68, 68, 0.4),
          0 0 50px rgba(239, 68, 68, 0.15);
      }
    }

    /* Memory Constellation Styles - Star-like nodes */
    .memory-node {
      font-size: 12px;
      color: white;
      backdrop-filter: blur(15px);
      box-shadow:
        0 0 30px rgba(134, 88, 255, 0.4),
        0 0 60px rgba(134, 88, 255, 0.2),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
    }

    /* Star-like glow effect */
    .memory-node::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      background: linear-gradient(45deg, rgba(134, 88, 255, 0.3), rgba(240, 147, 251, 0.3));
      z-index: -1;
      opacity: 0.7;
      animation: star-pulse 3s ease-in-out infinite;
    }

    @keyframes star-pulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); opacity: 1; }
    }

    .memory-node .memory-thumbnail {
      font-size: 28px;
      margin-bottom: 2px;
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.5));
      text-shadow: 0 0 10px rgba(134, 88, 255, 0.8);
    }

    .memory-node .memory-label {
      font-size: 11px;
      opacity: 0;
      position: absolute;
      top: 75px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17, 17, 27, 0.95);
      padding: 6px 10px;
      border-radius: 6px;
      white-space: nowrap;
      transition: all 0.3s ease;
      pointer-events: none;
      z-index: 1001;
      border: 1px solid rgba(134, 88, 255, 0.3);
      backdrop-filter: blur(10px);
      font-weight: 500;
    }

    .memory-node:hover .memory-label {
      opacity: 1;
      transform: translateX(-50%) translateY(-5px);
    }

    /* Theme-based colors */
    .memory-node[data-theme="family"] {
      box-shadow:
        0 0 30px rgba(255, 105, 135, 0.4),
        0 0 60px rgba(255, 105, 135, 0.2);
    }

    .memory-node[data-theme="travel"] {
      box-shadow:
        0 0 30px rgba(52, 211, 153, 0.4),
        0 0 60px rgba(52, 211, 153, 0.2);
    }

    .memory-node[data-theme="recent"] {
      box-shadow:
        0 0 30px rgba(96, 165, 250, 0.4),
        0 0 60px rgba(96, 165, 250, 0.2);
    }

    .memory-node[data-theme="special"] {
      box-shadow:
        0 0 30px rgba(251, 191, 36, 0.4),
        0 0 60px rgba(251, 191, 36, 0.2);
    }

    .constellation-controls {
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .constellation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .constellation-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .constellation-close {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }

    .constellation-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .constellation-themes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .theme-filter {
      background: rgba(134, 88, 255, 0.2);
      border: 1px solid rgba(134, 88, 255, 0.4);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
    }

    .theme-filter.active {
      background: rgba(134, 88, 255, 0.4);
      border-color: rgba(134, 88, 255, 0.6);
    }

    .theme-filter.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .theme-filter:hover:not(.disabled) {
      background: rgba(134, 88, 255, 0.3);
      transform: translateY(-2px);
    }

    /* Memory Dialog Styles */
    .memory-dialog {
      background: rgba(17, 17, 27, 0.95);
      border: 1px solid rgba(134, 88, 255, 0.3);
      border-radius: 16px;
      padding: 0;
      max-width: 800px;
      width: 90%;
      max-height: 80vh;
      overflow: hidden;
      backdrop-filter: blur(20px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .memory-dialog-overlay[style*="opacity: 1"] .memory-dialog {
      transform: scale(1);
    }

    .memory-dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 32px;
      border-bottom: 1px solid rgba(134, 88, 255, 0.2);
      background: linear-gradient(135deg, rgba(134, 88, 255, 0.1), rgba(240, 147, 251, 0.1));
    }

    .memory-title {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      color: white;
      text-shadow: 0 0 10px rgba(134, 88, 255, 0.5);
    }

    .memory-close {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }

    .memory-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .memory-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
      padding: 32px;
    }

    .memory-slideshow {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .slideshow-container {
      aspect-ratio: 16/9;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(134, 88, 255, 0.1);
      border: 1px solid rgba(134, 88, 255, 0.2);
    }

    .memory-slide {
      width: 100%;
      height: 100%;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .memory-slide.active {
      display: flex;
    }

    .media-placeholder {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
    }

    .media-icon {
      font-size: 48px;
      display: block;
      margin-bottom: 16px;
    }

    .slideshow-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .slide-btn {
      background: rgba(134, 88, 255, 0.2);
      border: 1px solid rgba(134, 88, 255, 0.4);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .slide-btn:hover {
      background: rgba(134, 88, 255, 0.4);
      transform: scale(1.05);
    }

    .slide-indicator {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-weight: 500;
    }

    .memory-details {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .memory-summary h3 {
      margin: 0 0 12px 0;
      font-size: 18px;
      font-weight: 600;
      color: white;
    }

    .memory-summary p {
      margin: 0;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.8);
    }

    .memory-metadata {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .metadata-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(134, 88, 255, 0.1);
    }

    .metadata-item .label {
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
    }

    .metadata-item .value {
      font-weight: 600;
      color: white;
    }

    .value.theme-family { color: rgba(255, 105, 135, 1); }
    .value.theme-travel { color: rgba(52, 211, 153, 1); }
    .value.theme-recent { color: rgba(96, 165, 250, 1); }
    .value.theme-special { color: rgba(251, 191, 36, 1); }

    .memory-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 24px 32px;
      border-top: 1px solid rgba(134, 88, 255, 0.2);
      background: rgba(134, 88, 255, 0.05);
    }

    .action-btn {
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      border: none;
    }

    .action-btn.secondary {
      background: rgba(134, 88, 255, 0.2);
      color: white;
      border: 1px solid rgba(134, 88, 255, 0.4);
    }

    .action-btn.secondary:hover {
      background: rgba(134, 88, 255, 0.3);
      transform: translateY(-2px);
    }

    .action-btn.primary {
      background: linear-gradient(135deg, rgba(134, 88, 255, 1), rgba(240, 147, 251, 0.8));
      color: white;
      border: none;
    }

    .action-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(134, 88, 255, 0.4);
    }

    .radial-item:nth-child(1) { animation-delay: 0s; }
    .radial-item:nth-child(2) { animation-delay: 0.5s; }
    .radial-item:nth-child(3) { animation-delay: 1s; }
    .radial-item:nth-child(4) { animation-delay: 1.5s; }
    .radial-item:nth-child(5) { animation-delay: 2s; }
    .radial-item:nth-child(6) { animation-delay: 2.5s; }
    .radial-item:nth-child(7) { animation-delay: 3s; }
    .radial-item:nth-child(8) { animation-delay: 3.5s; }

    .radial-item:hover {
      background: rgba(134, 88, 255, 0.3);
      border-color: var(--emma-purple);
      transform: scale(1.15);
      box-shadow: 0 0 40px rgba(134, 88, 255, 0.6);
      animation-play-state: paused;
    }

    .radial-item.pulsing {
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 30px rgba(134, 88, 255, 0.2);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 50px rgba(134, 88, 255, 0.5);
        transform: scale(1.05);
      }
    }

    .radial-item-icon {
      font-size: 32px;
      margin-bottom: 4px;
      filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
    }

    .radial-item-label {
      font-size: 12px;
      text-align: center;
      opacity: 0.9;
      font-weight: 500;
    }

    .node-connection {
      stroke: rgba(134, 88, 255, 0.3);
      stroke-width: 2;
      fill: none;
      stroke-dasharray: 5, 5;
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to { stroke-dashoffset: -100; }
    }

    /* Info Panels */
    .info-panel {
      position: fixed;
      background: var(--emma-glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--emma-border);
      border-radius: 20px;
      padding: 24px;
      min-width: 280px;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.4s ease;
      z-index: 10;
    }

    .info-panel.active {
      opacity: 1;
      transform: translateY(0);
    }

    /* Fade panels and header text when neural menu is active */
    body.menu-active .info-panel {
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      filter: blur(2px);
      pointer-events: none;
    }

    body.menu-active .welcome-text {
      opacity: 0 !important;
      transform: translateY(-20px) scale(0.9);
      filter: blur(3px);
      pointer-events: none;
      visibility: hidden;
    }

    body.menu-active .voice-indicator {
      opacity: 0;
      transform: translateX(-50%) translateY(20px) scale(0.9);
      filter: blur(2px);
      pointer-events: none;
    }

    body.menu-active .constellation-canvas {
      opacity: 0;
      filter: blur(3px);
      pointer-events: none;
    }

    /* Constellation Mode - Hide ALL UI except constellation */
    body.constellation-active .info-panel,
    body.constellation-active .welcome-text,
    body.constellation-active .voice-indicator,
    body.constellation-active .constellation-canvas,
    body.constellation-active .quick-stats {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
      transition: all 0.5s ease;
    }

    /* Keep only constellation controls and radial menu visible */
    body.constellation-active .constellation-controls,
    body.constellation-active .radial-menu {
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: all !important;
    }

    /* Hide panels in constellation mode */
    body.constellation-active .info-panel.right-stack,
    body.constellation-active .utility-icons {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* Bottom Left Utility Icons */
    /* Clean Icons - No backgrounds */
    .clean-icons {
      position: fixed;
      bottom: 24px;
      left: 24px;
      display: flex;
      gap: 16px;
      z-index: 1000;
    }

    .clean-icons > div {
      cursor: pointer;
      color: rgba(255, 255, 255, 0.7);
      transition: all 0.3s ease;
      padding: 8px;
    }

    .clean-icons > div:hover {
      color: white;
      transform: scale(1.1);
    }

    /* Hide old utility icons completely */
    .utility-icons {
      display: none !important;
    }

    .utility-item {
      display: none !important;
    }

    .utility-icon {
      display: none !important;
    }

    .utility-label {
      display: none !important;
    }

    /* Burger menu CSS removed for clean interface */

    /* Right side panel stack - hidden by default */
    .info-panel.right-stack {
      position: fixed;
      right: -360px; /* Hidden off-screen */
      width: 320px;
      min-width: 320px;
      max-width: 320px;
      height: 180px;
      min-height: 180px;
      max-height: 180px;
      transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 999;
    }

    /* Show panels when menu is active */
    .panels-visible .info-panel.right-stack {
      right: 24px;
    }

    #daily-brief.right-stack {
      top: 24px;
    }

    #ai-insights.right-stack {
      top: calc(24px + 180px + 16px);
    }

    #quick-actions.right-stack {
      top: calc(24px + 180px + 16px + 180px + 16px);
    }

    /* Legacy positioning for any remaining panels */
    .info-panel.top-left {
      top: 24px;
      left: 24px;
    }

    .info-panel.top-right {
      top: 24px;
      right: 24px;
    }

    .info-panel.bottom-left {
      bottom: 24px;
      left: 24px;
    }

    .info-panel.bottom-right {
      bottom: 24px;
      right: 24px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Adjust content for right stack panels */
    .info-panel.right-stack .panel-content {
      overflow: hidden;
      height: calc(100% - 70px); /* Account for header height */
    }

    .info-panel.right-stack .panel-content p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 8px;
    }

    .panel-icon {
      font-size: 24px;
    }

    .panel-title {
      font-size: 18px;
      font-weight: 600;
    }

    .panel-content {
      font-size: 14px;
      line-height: 1.6;
      color: var(--emma-text-secondary);
    }

    /* Memory Constellation Background */
    .constellation-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      opacity: 0.3;
      pointer-events: none;
    }

    /* Voice Activation Indicator */
    .voice-indicator {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--emma-glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--emma-border);
      border-radius: 30px;
      padding: 12px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
      opacity: 0;
      transform: translateX(-50%) translateY(20px);
      transition: all 0.3s ease;
      z-index: 10;
    }

    .voice-indicator.active {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .voice-waves {
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .voice-wave {
      width: 3px;
      height: 20px;
      background: var(--emma-purple);
      border-radius: 3px;
      animation: wave 1s ease-in-out infinite;
    }

    .voice-wave:nth-child(2) { animation-delay: 0.1s; height: 30px; }
    .voice-wave:nth-child(3) { animation-delay: 0.2s; height: 25px; }
    .voice-wave:nth-child(4) { animation-delay: 0.3s; height: 35px; }
    .voice-wave:nth-child(5) { animation-delay: 0.4s; height: 20px; }

    @keyframes wave {
      0%, 100% { transform: scaleY(0.5); opacity: 0.5; }
      50% { transform: scaleY(1); opacity: 1; }
    }

    /* Quick Stats */
    .quick-stats {
      position: absolute;
      bottom: -80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 32px;
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .command-center:hover .quick-stats {
      opacity: 1;
    }

    .stat-item {
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .stat-item:hover {
      transform: translateY(-4px);
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      background: var(--emma-gradient-1);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .stat-label {
      font-size: 12px;
      color: var(--emma-text-tertiary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* Notification Toast */
    .toast {
      position: fixed;
      top: 24px;
      right: 24px;
      background: var(--emma-glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--emma-border);
      border-radius: 12px;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
      opacity: 0;
      transform: translateX(400px);
      transition: all 0.4s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.success { border-color: var(--emma-success); }
    .toast.error { border-color: var(--emma-error); }
    .toast.info { border-color: var(--emma-blue); }

    /* Loading State */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .loading-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .loading-content {
      text-align: center;
    }

    .loading-orb {
      width: 80px;
      height: 80px;
      margin: 0 auto 20px;
      position: relative;
      /* Emma's orb will be rendered here via WebGL */
    }

    /* Fallback for when WebGL orb isn't available */
    .loading-orb-fallback {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 30% 30%, #8A5EFA, #764ba2, #f093fb);
      border-radius: 50%;
      animation: loading-pulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(138, 94, 250, 0.4);
    }

    @keyframes loading-pulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    /* Welcome Text */
    .welcome-text {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      animation: fade-in 1s ease-out 0.5s forwards;
    }

    .welcome-title {
      font-size: 48px;
      font-weight: 200;
      margin-bottom: 8px;
      background: var(--emma-gradient-1);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .welcome-subtitle {
      font-size: 18px;
      color: var(--emma-text-secondary);
      font-weight: 400;
    }

    @keyframes fade-in {
      to { opacity: 1; }
    }

    /* Vault Modal Styles */
    .vault-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .vault-modal.show {
      opacity: 1;
    }

    .vault-modal-content {
      background: linear-gradient(135deg, rgba(26, 16, 51, 0.98), rgba(45, 27, 105, 0.98));
      border: 1px solid rgba(134, 88, 255, 0.3);
      border-radius: 24px;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .vault-modal.show .vault-modal-content {
      transform: scale(1);
    }

    .vault-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 32px 32px 24px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: linear-gradient(135deg, rgba(134, 88, 255, 0.1), rgba(240, 147, 251, 0.1));
    }

    .vault-header-content {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .vault-icon {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, #8658ff, #f093fb);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
    }

    .vault-title h2 {
      margin: 0 0 4px 0;
      font-size: 28px;
      font-weight: 700;
      color: var(--emma-text);
    }

    .vault-title p {
      margin: 0;
      color: var(--emma-text-secondary);
      font-size: 16px;
    }

    .vault-close {
      width: 48px;
      height: 48px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: var(--emma-text);
      border-radius: 12px;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .vault-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .vault-modal-body {
      padding: 32px;
    }

    .vault-status-section {
      margin-bottom: 32px;
    }

    .vault-status-card {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 24px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      transition: all 0.3s ease;
    }

    .vault-status-card.unlocked {
      border-color: rgba(74, 222, 128, 0.3);
      background: rgba(74, 222, 128, 0.1);
    }

    .vault-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .vault-btn.primary {
      background: linear-gradient(135deg, #8658ff, #f093fb);
      color: white;
    }

    .vault-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(134, 88, 255, 0.4);
    }

    .vault-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--emma-text);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .vault-btn.secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .vault-btn.small {
      padding: 8px 16px;
      font-size: 14px;
    }

    .vault-unlock-section {
      margin-bottom: 32px;
      padding: 24px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .unlock-form label {
      display: block;
      margin-bottom: 8px;
      color: var(--emma-text);
      font-weight: 600;
    }

    .unlock-form input {
      width: 100%;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: var(--emma-text);
      font-size: 16px;
      margin-bottom: 20px;
      text-align: center;
      letter-spacing: 2px;
    }

    .unlock-form input:focus {
      outline: none;
      border-color: var(--emma-purple);
      box-shadow: 0 0 0 3px rgba(134, 88, 255, 0.2);
    }

    .unlock-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    /* Create Vault Section */
    .vault-create-section {
      margin-bottom: 32px;
      padding: 24px;
      background: rgba(16, 185, 129, 0.1);
      border-radius: 16px;
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .create-vault-card {
      text-align: center;
    }

    .create-vault-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .create-vault-content h3 {
      color: var(--emma-text);
      margin-bottom: 8px;
      font-size: 20px;
    }

    .create-vault-content p {
      color: var(--emma-text-secondary);
      margin-bottom: 20px;
      font-size: 16px;
    }

    .vault-qr-section h3 {
      margin: 0 0 8px 0;
      color: var(--emma-text);
      font-size: 20px;
    }

    .vault-qr-section p {
      margin: 0 0 20px 0;
      color: var(--emma-text-secondary);
    }

    .qr-option-card {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .qr-option-card:hover {
      border-color: rgba(134, 88, 255, 0.3);
      background: rgba(134, 88, 255, 0.1);
    }

    .qr-option-icon {
      font-size: 32px;
      min-width: 32px;
    }

    .qr-option-content {
      flex: 1;
    }

    .qr-option-content h4 {
      margin: 0 0 4px 0;
      color: var(--emma-text);
      font-size: 16px;
    }

    .qr-option-content p {
      margin: 0;
      color: var(--emma-text-secondary);
      font-size: 14px;
    }

    .vault-actions-section {
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 24px;
    }

    /* Responsive Design */
    /* Mobile-First Responsive Design */
    @media (max-width: 768px) {
      .radial-menu {
        width: 100vw;
        height: 100vh;
      }

      .radial-item {
        /* 🌌 UNIFIED: Same size for all devices - no more mobile/desktop differences */
        width: 90px !important;
        height: 90px !important;
        font-size: 12px;
        /* 🎯 TOUCH FRIENDLY: Large enough for all devices */
        min-width: 90px;
        min-height: 90px;
        /* 🔗 BOUND TO ORB: Unified positioning */
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
      }

      .radial-item-icon {
        font-size: 28px;
      }

      .radial-item-label {
        font-size: 11px;
        margin-top: 3px;
        font-weight: 500;
      }

      /* 📱 MOBILE OPTIMIZATION: Better visual feedback */
      .radial-item:active {
        transform: scale(0.95) !important;
        background: rgba(134, 88, 255, 0.3) !important;
      }

      .emma-orb-container {
        width: 120px !important;
        height: 120px !important;
      }

      .welcome-title {
        font-size: 2.5rem;
      }

      .welcome-subtitle {
        font-size: 0.9rem;
      }

      /* Mobile constellation filters */
      .constellation-burger-menu {
        top: 10px !important;
        left: 10px !important;
      }

      .constellation-menu-panel {
        width: 280px !important;
        max-height: 70vh !important;
        overflow-y: auto;
      }

      .info-panel,
      .info-panel.right-stack {
        position: fixed;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        top: auto !important;
        width: 100% !important;
        min-width: 100% !important;
        max-width: 100% !important;
        height: auto !important;
        min-height: auto !important;
        max-height: 50vh !important;
        border-radius: 20px 20px 0 0;
        overflow-y: auto;
      }

      /* Stack panels vertically on mobile */
      #daily-brief.right-stack { transform: translateY(0); }
      #ai-insights.right-stack { transform: translateY(0); }
      #quick-actions.right-stack { transform: translateY(0); }
    }

    /* Tablet optimizations */
    @media (max-width: 1024px) and (min-width: 769px) {
      .radial-item {
        /* 🌌 UNIFIED: Same 90px size for tablets too */
        width: 90px;
        height: 90px;
      }

      .emma-orb-container {
        width: 160px;
        height: 160px;
      }
    }

    /* Import Voice Capture Premium Styles */

    /* Person Summary Modal Styles */
    .person-summary-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .person-summary-modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .person-summary-modal {
      /* 🎨 EMMA GLASSMORPHISM: Match chat interface aesthetic */
      background: rgba(26, 16, 51, 0.92);
      backdrop-filter: blur(25px) saturate(150%);
      -webkit-backdrop-filter: blur(25px) saturate(150%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 24px;
      padding: 32px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: transform 0.3s ease;
      position: relative;
      box-shadow: 
        0 25px 80px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }

    .person-summary-modal .modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      font-size: 18px;
      font-weight: 300;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .person-summary-modal .modal-close:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      transform: scale(1.1);
    }

    .person-summary-modal-overlay.active .person-summary-modal {
      transform: scale(1) translateY(0);
    }

    .person-summary-header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 32px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .person-summary-avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 32px;
      overflow: hidden;
    }

    .person-summary-info {
      flex: 1;
    }

    .person-summary-name {
      font-size: 1.8rem;
      font-weight: 600;
      color: white;
      margin: 0 0 8px 0;
    }

    .person-summary-relation {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin: 0 0 4px 0;
      text-transform: capitalize;
    }

    .person-summary-contact {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.5);
      margin: 0;
    }

    .summary-section-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: white;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .summary-section-title::before {
      content: '';
      width: 3px;
      height: 20px;
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      border-radius: 2px;
    }

    .connected-memories {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }

    .connected-memory-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .connected-memory-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .memory-preview {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-size: 20px;
    }

    .memory-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
    }

    .memory-info {
      flex: 1;
    }

    .memory-title {
      font-size: 1rem;
      font-weight: 500;
      color: white;
      margin-bottom: 4px;
    }

    .memory-date {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.6);
    }

    .no-memories {
      text-align: center;
      padding: 40px 20px;
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
    }

    .person-summary-actions {
      display: flex;
      gap: 12px;
    }

    .person-summary-actions .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 16px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .person-summary-actions .btn-primary {
      background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
      color: white;
    }

    .person-summary-actions .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
    }

    .person-summary-actions .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .person-summary-actions .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }
  </style>
</head>
<body>
  <!-- Aurora Background -->
  <div class="aurora-bg">
    <div class="aurora"></div>
  </div>

  <!-- Memory Constellation Canvas -->
  <canvas id="constellation" class="constellation-canvas"></canvas>

  <!-- Welcome Text -->
  <div class="welcome-text">
    <h1 class="welcome-title">emma</h1>
    <p class="welcome-subtitle">Your Intelligent Memory Companion</p>
  </div>

  <!-- Neural Network Background -->
  <div class="neural-network">
    <canvas id="neural-canvas" class="neural-canvas"></canvas>
  </div>

  <!-- Main Dashboard -->
  <div class="dashboard">
    <div class="command-center">
      <!-- Central Emma Orb (WebGL) with Elegant Vault Unlock -->
      <div class="emma-orb-container" id="emma-orb">
        <div class="emma-orb-webgl" id="webgl-orb-container">
          <!-- WebGL Emma Orb will be inserted here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Radial Menu (Clean 4-item layout around Emma orb) -->
  <div class="radial-menu" id="radial-menu">
        <div class="radial-item" data-action="memories">
          <div class="radial-item-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-2.5 2.5M6.5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H6.5z"/>
              <path d="M9 10h6M9 14h4"/>
            </svg>
          </div>
          <div class="radial-item-label">Memories</div>
        </div>
        <div class="radial-item" data-action="people">
          <div class="radial-item-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
              <circle cx="12" cy="7" r="4"/>
            </svg>
          </div>
          <div class="radial-item-label">People</div>
        </div>
        <div class="radial-item" data-action="chat">
          <div class="radial-item-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
          </div>
          <div class="radial-item-label">Chat</div>
        </div>
      </div>

  <!-- Bottom Left Clean Icons -->
  <div class="clean-icons" style="
    position: fixed;
    bottom: 24px;
    left: 24px;
    display: flex;
    gap: 16px;
    z-index: 1000;
  ">
    <!-- Clean Settings Gear Icon -->
    <div onclick="window.location.href='pages/emma-settings-redesigned.html'" style="
      cursor: pointer;
      color: rgba(255, 255, 255, 0.7);
      transition: all 0.3s ease;
      padding: 8px;
    " onmouseover="this.style.color='white'; this.style.transform='scale(1.1)'" onmouseout="this.style.color='rgba(255, 255, 255, 0.7)'; this.style.transform='scale(1)'">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"/>
        <path d="m12 1 1.09 3.26L16 5.64l-1.64 3.36L17 12l-2.64 2.64L16 18.36l-3.26-1.09L12 23l-1.09-3.26L8 18.36l1.64-3.36L7 12l2.64-2.64L8 5.64l3.26 1.09z"/>
      </svg>
    </div>
  </div>

      <!-- Quick Stats -->
      <div class="quick-stats">
        <div class="stat-item" data-stat="memories">
          <div class="stat-value" id="stat-memories">0</div>
          <div class="stat-label">Memories</div>
        </div>
        <div class="stat-item" data-stat="people">
          <div class="stat-value" id="stat-people">0</div>
          <div class="stat-label">People</div>
        </div>

        <!-- Revolutionary Migration Button -->
        <div class="stat-item revolution-upgrade" onclick="openMigrationPage()" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(236, 72, 153, 0.2)); border: 2px solid rgba(139, 92, 246, 0.4); cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden;">
          <div class="stat-value" style="font-size: 1.2rem; color: #8b5cf6;">🌟</div>
          <div class="stat-label" style="color: #ec4899; font-weight: 600; font-size: 0.8rem;">Upgrade to .emma</div>
          <div style="position: absolute; top: 4px; right: 4px; background: linear-gradient(135deg, #8b5cf6, #ec4899); color: white; font-size: 0.6rem; padding: 2px 6px; border-radius: 8px; font-weight: 600;">NEW</div>
        </div>
        <div class="stat-item" data-stat="today">
          <div class="stat-value" id="stat-today">0</div>
          <div class="stat-label">Today</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Burger menu removed for clean interface -->

  <!-- Right Side Panel Stack -->
  <div class="info-panel right-stack" id="daily-brief">
    <div class="panel-header">
      <div class="panel-icon">📅</div>
      <div class="panel-title">Daily Brief</div>
    </div>
    <div class="panel-content">
      <p>Good morning! You have 3 memories from this day last year.</p>
      <p style="margin-top: 12px; font-size: 13px; opacity: 0.8;">
        • Meeting with Sarah about the project<br>
        • Family dinner at Marina Bay<br>
        • Completed the meditation course
      </p>
    </div>
  </div>

  <div class="info-panel right-stack" id="ai-insights">
    <div class="panel-header">
      <div class="panel-icon">💡</div>
      <div class="panel-title">AI Insights</div>
    </div>
    <div class="panel-content">
      <p>I noticed you've been capturing more creative moments lately. Your photography memories have increased by 40% this month!</p>
    </div>
  </div>

  <div class="info-panel right-stack" id="quick-actions">
    <div class="panel-header">
      <div class="panel-icon">⚡</div>
      <div class="panel-title">Quick Actions</div>
    </div>
    <div class="panel-content">
      <p>Press <kbd>Space</kbd> to activate voice capture<br>
      Press <kbd>Cmd+K</kbd> to search memories<br>
      Say "Hey Emma" to start</p>
    </div>
  </div>

  <!-- Voice Indicator -->
  <div class="voice-indicator" id="voice-indicator">
    <div class="voice-waves">
      <div class="voice-wave"></div>
      <div class="voice-wave"></div>
      <div class="voice-wave"></div>
      <div class="voice-wave"></div>
      <div class="voice-wave"></div>
    </div>
    <span>Listening...</span>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div class="loading-content">
      <div class="loading-orb"></div>
      <p style="color: var(--emma-text-secondary);">Loading Emma...</p>
    </div>
  </div>

  <!-- Vault Management Modal -->
  <div id="vault-modal" class="vault-modal" style="display: none;">
    <div class="vault-modal-content">
      <div class="vault-modal-header">
        <div class="vault-header-content">
          <div class="vault-icon">🔐</div>
          <div class="vault-title">
            <h2>Emma Memory Vault</h2>
            <p id="vault-subtitle">Secure access to your encrypted memories</p>
          </div>
        </div>
        <button class="vault-close" id="close-vault-modal">×</button>
      </div>

      <div class="vault-modal-body">
        <!-- Vault Status Section -->
        <div class="vault-status-section">
          <div class="vault-status-card" id="vault-status-card">
            <div class="status-icon" id="status-icon">🔒</div>
            <div class="status-info">
              <h3 id="status-title">Vault Locked</h3>
              <p id="status-description">Enter your vault code to access your memories</p>
            </div>
            <div class="status-action">
              <button id="vault-action-btn" class="vault-btn primary">Unlock Vault</button>
            </div>
          </div>
        </div>

        <!-- Unlock Form Section -->
        <div class="vault-unlock-section" id="unlock-section" style="display: none;">
          <div class="unlock-form">
            <label for="vault-password">Vault Code</label>
            <input type="password" id="vault-password" placeholder="Enter your vault code" autocomplete="current-password">
            <div class="unlock-actions">
              <button id="unlock-btn" class="vault-btn primary">🔓 Unlock</button>
              <button id="cancel-unlock-btn" class="vault-btn secondary">Cancel</button>
            </div>
          </div>
        </div>

        <!-- Create New Vault Section -->
        <div class="vault-create-section" id="create-vault-section" style="display: none;">
          <div class="create-vault-card">
            <div class="create-vault-icon">🆕</div>
            <div class="create-vault-content">
              <h3>No Vault Found</h3>
              <p>Create your first Emma memory vault to get started</p>
              <button id="create-vault-btn" class="vault-btn primary">
                🔐 Create New Vault
              </button>
            </div>
          </div>
        </div>

        <!-- QR Sharing Section -->
        <div class="vault-qr-section" id="qr-section">
          <h3>📱 Quick Share</h3>
          <p>Generate QR codes to securely share your vault or memories</p>

          <div class="qr-options">
            <div class="qr-option-card" id="generate-vault-qr-dashboard">
              <div class="qr-option-icon">🔐</div>
              <div class="qr-option-content">
                <h4>Share Vault</h4>
                <p>Time-limited access to your vault</p>
              </div>
              <div class="qr-option-action">
                <button class="vault-btn secondary small">Generate QR</button>
              </div>
            </div>

            <div class="qr-option-card" id="open-qr-scanner-dashboard">
              <div class="qr-option-icon">📷</div>
              <div class="qr-option-content">
                <h4>Scan QR Code</h4>
                <p>Access shared memories</p>
              </div>
              <div class="qr-option-action">
                <button class="vault-btn secondary small">Open Scanner</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Quick Actions -->
        <div class="vault-actions-section">
          <div class="quick-actions-grid">
            <button class="quick-action" onclick="window.location.href='pages/gallery.html'">
              <span>💝</span>
              <span>View Memory Constellation</span>
            </button>
            <button class="quick-action" onclick="window.location.href='pages/emma-settings-redesigned.html'">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgba(255, 255, 255, 0.8);">
                <circle cx="12" cy="12" r="3"/>
                <path d="m12 1 1.09 3.26L16 5.64l-1.64 3.36L17 12l-2.64 2.64L16 18.36l-3.26-1.09L12 23l-1.09-3.26L8 18.36l1.64-3.36L7 12l2.64-2.64L8 5.64l3.26 1.09z"/>
              </svg>
              <span>Settings</span>
            </button>
            <button class="quick-action" onclick="window.location.href='pages/people-emma.html'">
              <span>👥</span>
              <span>People</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Load all your beautiful Emma components! -->
  <link rel="stylesheet" href="css/voice-capture-minimal.css">
  <link rel="stylesheet" href="css/emma-chat-clean.css">
  <link rel="stylesheet" href="css/emma-share.css">

  <script src="js/base-orb.js"></script>
  <script src="js/emma-orb.js"></script>
  <script src="js/vault-control-panel.js"></script>
  <script src="js/experience-popup-base.js"></script>
  <script src="js/voice-capture-experience.js"></script>
  <script src="js/emma-voice-transcription.js"></script>
  
  <!-- Emma Intelligence & Chat System -->
  <script src="js/emma-vectorless-engine.js"></script>
  <script src="js/emma-intelligent-capture.js"></script>
  <script src="js/emma-chat-experience.js"></script>
  <script src="js/emma-qr-generator.js"></script>
  <script src="js/qr-service.js"></script>
  <script src="js/emma-share-experience.js"></script>
  <script src="js/assistant-experience-popup.js"></script>
  <script src="js/universal-vault-modal.js"></script>
  <script src="js/unified-memory-wizard.js"></script>

  <script>
    // Extension mode - Skip vault session validation

    // Vault initialization moved to end of page after ALL scripts load

    // Dashboard Controller
    class EmmaDashboard {
      constructor() {
        this.orb = document.getElementById('emma-orb');
        this.radialMenu = document.getElementById('radial-menu');
        this.voiceIndicator = document.getElementById('voice-indicator');
        
        // CRITICAL: Expose dashboard globally for Emma Chat Experience
        window.emmaDashboard = this;
        this.loading = document.getElementById('loading');

        console.log('🔧 Constructor - radial items:', this.radialMenu ? this.radialMenu.querySelectorAll('.radial-item').length : 'NULL');
        this.panels = {
          dailyBrief: document.getElementById('daily-brief'),
          aiInsights: document.getElementById('ai-insights'),
          quickActions: document.getElementById('quick-actions')
        };

        // Burger menu removed for clean interface
        this.panelsVisible = false;

        // Utility icons functionality
        this.utilityIcons = document.querySelector('.utility-icons');
        this.setupUtilityIcons();

        this.isMenuOpen = false;
        this.stats = { memories: 0, people: 0, today: 0 };
        this.particles = [];
        this.nodes = [];
        this.neuralCanvas = document.getElementById('neural-canvas');
        this.neuralCtx = this.neuralCanvas.getContext('2d');

        // Neural memory network properties
        this.isConstellationMode = false;
        this.constellationMemories = [];
        this.centralNeuron = null;
        
        // 🔍 ZOOM FUNCTIONALITY: Dashboard constellation zoom/pan state
        this.zoomState = {
          scale: 1,
          translateX: 0,
          translateY: 0,
          isDragging: false,
          lastTouchDistance: 0,
          minScale: 0.3,
          maxScale: 3.0
        };
        this.constellationContainer = null;

        // Initialize WebGL Emma Orb
        this.initEmmaOrb();

        // Listen for vault status changes
        document.addEventListener('vaultStatusChanged', (event) => {

          this.updateVaultNodeStatus();
          this.updateAllVaultIndicators();
        });

        this.init();
      }

      async init() {
        // Show loading
        this.loading.classList.add('active');

        // Initialize Emma's orb in loading screen
        this.initLoadingOrb();

        // Initialize constellation background
        console.log('🔍 DEBUG: About to initialize constellation, DOM ready state:', document.readyState);
        console.log('🔍 DEBUG: Constellation canvas exists?', !!document.getElementById('constellation'));
        this.initConstellation();
        
        // Setup event listeners
        this.setupEventListeners();

        // Load initial data
        await this.loadDashboardData();

        // Animate panels based on time of day
        this.showContextualPanels();

        // Hide loading
        setTimeout(() => {
          this.loading.classList.remove('active');
        }, 1500);

        // 🎯 SAFE AUTO-TRIGGER: Check URL params for constellation or memory creation
        this.handleURLParams();

        // Start background animations
        this.startAnimations();
      }

      initConstellation() {
        const canvas = document.getElementById('constellation');
        if (!canvas) {
          console.warn('⚠️ Constellation canvas not found, skipping initialization');
          return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.warn('⚠️ Could not get constellation canvas context, skipping initialization');
          return;
        }

        // Set canvas size
        const resize = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        };
        resize();
        window.addEventListener('resize', resize);

        // Create memory particles
        const particleCount = 50;
        for (let i = 0; i < particleCount; i++) {
          this.particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 2 + 1,
            opacity: Math.random() * 0.5 + 0.2
          });
        }

        // Animation loop
        const animate = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Update and draw particles
          this.particles.forEach((p, i) => {
            // Update position
            p.x += p.vx;
            p.y += p.vy;

            // Wrap around edges
            if (p.x < 0) p.x = canvas.width;
            if (p.x > canvas.width) p.x = 0;
            if (p.y < 0) p.y = canvas.height;
            if (p.y > canvas.height) p.y = 0;

            // Draw particle
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(134, 88, 255, ${p.opacity})`;
            ctx.fill();

            // Draw connections
            this.particles.forEach((p2, j) => {
              if (i !== j) {
                const dx = p.x - p2.x;
                const dy = p.y - p2.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 100) {
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);
                  ctx.lineTo(p2.x, p2.y);
                  ctx.strokeStyle = `rgba(134, 88, 255, ${(1 - dist / 100) * 0.2})`;
                  ctx.stroke();
                }
              }
            });
          });

          requestAnimationFrame(animate);
        };
        animate();
      }

      setupEventListeners() {
        // Orb click - exit constellation or toggle menu
        this.orb.addEventListener('click', (e) => {
          e.stopPropagation();
          if (this.isConstellationMode) {
            // Simple: Exit constellation mode back to main dashboard
            this.exitMemoryConstellation();
          } else {
            this.toggleRadialMenu();
          }
        });

        // Radial menu items
        this.radialMenu.querySelectorAll('.radial-item').forEach(item => {
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = item.dataset.action;
            this.handleRadialAction(action);
          });
        });

        // Track mouse/touch position for neural effects
        this.mouseX = 0;
        this.mouseY = 0;

        // Mouse support
        document.addEventListener('mousemove', (e) => {
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;
          this.updateNodeProximityEffects();
        });

        // Touch support for mobile
        document.addEventListener('touchmove', (e) => {
          if (e.touches.length > 0) {
            this.mouseX = e.touches[0].clientX;
            this.mouseY = e.touches[0].clientY;
            this.updateNodeProximityEffects();
          }
        }, { passive: true });

        document.addEventListener('touchstart', (e) => {
          if (e.touches.length > 0) {
            this.mouseX = e.touches[0].clientX;
            this.mouseY = e.touches[0].clientY;
          }
        }, { passive: true });

        // Handle window resize for responsive repositioning
        window.addEventListener('resize', () => {
          // Debounce resize events
          clearTimeout(this.resizeTimeout);
          this.resizeTimeout = setTimeout(() => {
            if (this.isMenuOpen) {
              // 🔄 MOBILE FIX: Keep radial menu bound to orb center
              this.repositionMenuToOrb();
              
              // CRITICAL FIX: Resize canvas and redraw connections after repositioning
              if (this.neuralCanvas) {
                this.neuralCanvas.width = window.innerWidth;
                this.neuralCanvas.height = window.innerHeight;
              }
              
              // Force immediate redraw of connections with new positions
              if (this.render && typeof this.render === 'function') {
                this.render();
              } else if (window.neuralRenderer && window.neuralRenderer.render) {
                window.neuralRenderer.render();
              }
            } else if (this.isConstellationMode) {
              // Existing constellation resize handling
              this.repositionNodesOnResize();
              
              if (this.neuralCanvas) {
                this.neuralCanvas.width = window.innerWidth;
                this.neuralCanvas.height = window.innerHeight;
              }
              
              if (this.render && typeof this.render === 'function') {
                this.render();
              } else if (window.neuralRenderer && window.neuralRenderer.render) {
                window.neuralRenderer.render();
              }
            }
          }, 250);
        });
      }

      // Extract proximity effects to separate method for reuse
      updateNodeProximityEffects() {
        // Add proximity effects to nodes (both menu and constellation modes)
        if ((this.isMenuOpen || this.isConstellationMode) && this.nodes.length > 0) {
          this.nodes.forEach(node => {
            const dist = Math.sqrt(
              Math.pow(this.mouseX - node.x, 2) +
              Math.pow(this.mouseY - node.y, 2)
            );

            if (dist < 120) {
              // Subtle attraction to mouse with organic feel
              const force = (120 - dist) / 120;
              const angle = Math.atan2(this.mouseY - node.y, this.mouseX - node.x);

              // Very gentle attraction with organic damping
              const attractionStrength = force * 0.08; // Much more subtle
              node.vx += Math.cos(angle) * attractionStrength;
              node.vy += Math.sin(angle) * attractionStrength;

              // Add glow effect (stronger for memory nodes)
              const glowStrength = this.isConstellationMode ? 60 : 40;
              const baseOpacity = this.isConstellationMode ? 0.8 : 0.6;
              node.element.style.boxShadow = `0 0 ${glowStrength + force * 30}px rgba(134, 88, 255, ${baseOpacity + force * 0.4})`;
            } else {
              // Reset glow when mouse is far
              node.element.style.boxShadow = '';
            }
          });
        }
      }

      // Reposition nodes on window resize for responsive behavior (CONSTELLATION MODE ONLY)
      repositionNodesOnResize() {
        if (!this.nodes || this.nodes.length === 0) return;
        
        // 🚨 CRITICAL: This function is now ONLY for constellation mode
        // Radial menu repositioning is handled by repositionMenuToOrb()
        if (!this.isConstellationMode) {
          console.warn('🚨 repositionNodesOnResize called for non-constellation mode - use repositionMenuToOrb instead');
          return;
        }

        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;

        // Reposition each constellation node
        this.nodes.forEach((node, i) => {
          // For constellation mode, maintain relative positions but scale
          const scaleX = window.innerWidth / (this.lastWindowWidth || window.innerWidth);
          const scaleY = window.innerHeight / (this.lastWindowHeight || window.innerHeight);

          node.x = centerX + (node.x - centerX) * scaleX;
          node.y = centerY + (node.y - centerY) * scaleY;
          node.baseX = node.x;
          node.baseY = node.y;

          // Update DOM position - UNIFIED: Same size for all devices
          if (node.element) {
            const elementSize = 45; // Consistent centering for all devices (90px items)
            node.element.style.left = (node.x - elementSize) + 'px';
            node.element.style.top = (node.y - elementSize) + 'px';
          }
        });

        // Store current window size for next resize
        this.lastWindowWidth = window.innerWidth;
        this.lastWindowHeight = window.innerHeight;

      }

      // Keyboard shortcuts
      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && !e.target.matches('input, textarea')) {
            e.preventDefault();
            this.startVoiceCapture();
          } else if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            this.handleRadialAction('search');
          } else if (e.key === 'Escape' && this.isMenuOpen) {
            this.toggleRadialMenu();
          }
        });

        // Click outside to close menu
        document.addEventListener('click', (e) => {
          if (this.isMenuOpen && !this.orb.contains(e.target) && !this.radialMenu.contains(e.target)) {

            this.toggleRadialMenu();
          }
        });

        // Hover effects for orb
        this.orb.addEventListener('mouseenter', () => {
          document.querySelectorAll('.quick-stats').forEach(el => {
            el.style.opacity = '1';
          });
        });

        // Initialize keyboard shortcuts
        this.setupKeyboardShortcuts();

        // CRITICAL FIX: Listen for vault status changes from extension
        this.setupVaultStatusListener();
        
        // Auto-trigger constellation mode if hash is present
        if (window.location.hash === '#constellation') {
          console.log('🌟 DASHBOARD: Auto-triggering constellation mode from URL hash');
          setTimeout(() => {
            this.enterMemoryConstellation();
          }, 1000); // Wait for vault to load
        }
      }

      // Listen for vault status changes and update UI
      setupVaultStatusListener() {
        window.addEventListener('vault-status-changed', (event) => {

          // Update global status
          window.currentVaultStatus = event.detail;

          // Update vault node status in UI
          this.updateVaultNodeStatus();

          // Update any vault-dependent UI elements
          this.refreshVaultDependentUI();
        });

        // Also listen for extension-vault-ready directly
        window.addEventListener('extension-vault-ready', (event) => {

          // Ensure vault status is updated
          if (window.webVaultStatus) {
            window.webVaultStatus.status.isUnlocked = true;
            window.webVaultStatus.status.hasVault = true;
            window.webVaultStatus.status.name = event.detail.vaultName;
            window.currentVaultStatus = window.webVaultStatus.status;
          }

          // Update UI immediately
          this.updateVaultNodeStatus();
        });

        // CRITICAL: Listen for memory additions from Emma Chat
        window.addEventListener('emmaMemoryAdded', (event) => {
          console.log('🔄 DASHBOARD: Memory added event received, refreshing constellation');
          
          if (this.isConstellationMode) {
            // Force constellation refresh with new data - longer delay to ensure vault sync
            setTimeout(() => {
              this.enterMemoryConstellation();
              console.log('🔄 DASHBOARD: Constellation refreshed after memory addition');
            }, 300); // Increased delay for better data consistency
          }
        });
      }

      // Refresh UI elements that depend on vault status
      refreshVaultDependentUI() {
        // Update any vault-dependent elements
        const vaultElements = document.querySelectorAll('[data-vault-dependent]');
        vaultElements.forEach(element => {
          if (window.currentVaultStatus && window.currentVaultStatus.isUnlocked) {
            element.classList.remove('vault-locked');
            element.classList.add('vault-unlocked');
          } else {
            element.classList.remove('vault-unlocked');
            element.classList.add('vault-locked');
          }
        });
      }

      initNeuralNetwork() {
        // 🎯 BACK TO BASICS: Orb-relative positioning that actually works
        console.log('🔧 initNeuralNetwork: Using orb-relative positioning');

        const items = this.radialMenu.querySelectorAll('.radial-item');
        
        // 🔥 GET ACTUAL ORB POSITION: Don't force it, work with it
        const orbRect = this.orb.getBoundingClientRect();
        const orbCenterX = orbRect.left + orbRect.width / 2;
        const orbCenterY = orbRect.top + orbRect.height / 2;

        console.log('🎯 Actual orb center:', { x: orbCenterX, y: orbCenterY, orbRect });

        // 🌌 SIMPLIFIED: One radius that works great for all devices - true orbiting feel
        const radius = 140; // Proper orbiting distance - feels like satellites around Emma orb

        console.log('🌌 Using unified orbiting radius:', radius, 'px for all devices');

        // Clear existing nodes
        this.nodes = [];

        items.forEach((item, i) => {
          const angle = (i / items.length) * Math.PI * 2 - Math.PI / 2;
          
          // 🔗 ORB-RELATIVE: Calculate position relative to actual orb center
          const targetX = orbCenterX + Math.cos(angle) * radius;
          const targetY = orbCenterY + Math.sin(angle) * radius;

          // 🎬 ANIMATION SETUP: Start at actual orb center for animate-out effect
          const startX = orbCenterX;
          const startY = orbCenterY;

          // Position at orb center initially (for animation)
          item.style.left = (startX - 45) + 'px'; // Center the 90px item
          item.style.top = (startY - 45) + 'px';
          item.style.transform = 'scale(0)';
          item.style.opacity = '0';

          console.log(`🎯 Item ${i}: start(${startX}, ${startY}) → target(${targetX}, ${targetY})`);

          // Store both current and target positions
          const nodeData = {
            element: item,
            x: startX,      // Current position (starts at orb center)
            y: startY,
            targetX: targetX,  // Final position
            targetY: targetY,
            vx: 0,
            vy: 0,
            baseX: targetX,    // Base position for physics
            baseY: targetY,
            angle: angle,
            connections: [],
            orbBound: true     // Flag to indicate this is bound to orb
          };

          this.nodes.push(nodeData);
        });

        // Create connections between nodes
        this.nodes.forEach((node, i) => {
          // Connect to adjacent nodes
          const next = this.nodes[(i + 1) % this.nodes.length];
          const prev = this.nodes[(i - 1 + this.nodes.length) % this.nodes.length];
          node.connections.push(next, prev);

          // Connect to opposite node for cross-connections
          const opposite = this.nodes[(i + Math.floor(this.nodes.length / 2)) % this.nodes.length];
          if (opposite !== node) {
            node.connections.push(opposite);
          }
        });

        // Add central orb as a node at actual orb center
        this.centralNode = {
          x: orbCenterX,
          y: orbCenterY,
          element: this.orb
        };

        // Connect all nodes to center
        this.nodes.forEach(node => {
          node.connections.push(this.centralNode);
        });
      }

      // Removed initRadialNeuralNetwork - no longer needed since we exit constellation instead of showing menu overlay

      toggleRadialMenu() {
        this.isMenuOpen = !this.isMenuOpen;

        if (this.isMenuOpen) {
          this.radialMenu.classList.add('active');
          document.body.classList.add('menu-active'); // Fade ALL UI elements

          this.updateVaultNodeStatus(); // Update vault node based on status

          // Initialize neural network bound to orb center
          this.initNeuralNetwork();
          this.animateNeuralNetwork();

          // 🧠 NEURAL EXPANSION: Use physics to expand nodes naturally from orb
          this.expandRadialNeuralNetwork();

        } else {
          // 🧠 NEURAL COLLAPSE: Use physics to collapse nodes back to orb naturally
          this.collapseRadialNeuralNetwork();

          // Cleanup after natural physics collapse
          setTimeout(() => {
            this.radialMenu.classList.remove('active');
            document.body.classList.remove('menu-active');

            // Clear neural animation
            if (this.neuralAnimationId) {
              cancelAnimationFrame(this.neuralAnimationId);
              this.neuralCtx.clearRect(0, 0, this.neuralCanvas.width, this.neuralCanvas.height);
            }

            // Reset nodes array
            this.nodes = [];
          }, 200); // Allow time for natural neural collapse
        }
      }

      // 🧠 NEURAL EXPANSION: Expand radial nodes using neural network physics
      expandRadialNeuralNetwork() {
        console.log('🧠 Expanding radial neural network from orb center');
        
        this.nodes.forEach((node, i) => {
          // Set target position for neural physics to move toward
          node.baseX = node.targetX;
          node.baseY = node.targetY;
          
          // Add initial velocity toward target (like constellation nodes)
          const dx = node.targetX - node.x;
          const dy = node.targetY - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 1) {
            // Give it momentum toward target
            node.vx = (dx / distance) * 3; // Fast initial velocity
            node.vy = (dy / distance) * 3;
          }
          
          // Show and scale the node
          setTimeout(() => {
            node.element.style.transition = 'opacity 0.1s ease, transform 0.1s ease';
            node.element.style.opacity = '1';
            node.element.style.transform = 'scale(1)';
            
            // Pause float animation during menu display
            node.element.style.animationPlayState = 'paused';
            
            console.log(`🧠 Node ${i} neural expansion initiated to (${node.targetX}, ${node.targetY})`);
          }, i * 15); // Fast stagger
        });
      }

      // 🧠 NEURAL COLLAPSE: Collapse radial nodes back to orb using neural physics
      collapseRadialNeuralNetwork() {
        console.log('🧠 Collapsing radial neural network back to orb center');
        
        // Get actual orb center position
        const orbRect = this.orb.getBoundingClientRect();
        const orbCenterX = orbRect.left + orbRect.width / 2;
        const orbCenterY = orbRect.top + orbRect.height / 2;
        
        this.nodes.forEach((node, i) => {
          // Set orb center as the new target for neural physics
          node.baseX = orbCenterX;
          node.baseY = orbCenterY;
          node.targetX = orbCenterX;
          node.targetY = orbCenterY;
          
          // Add velocity toward orb center (like constellation nodes)
          const dx = orbCenterX - node.x;
          const dy = orbCenterY - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 1) {
            // Give it momentum toward orb center
            node.vx = (dx / distance) * 4; // Fast collapse velocity
            node.vy = (dy / distance) * 4;
          }
          
          // Hide and scale down the node
          setTimeout(() => {
            node.element.style.transition = 'opacity 0.15s ease, transform 0.15s ease';
            node.element.style.opacity = '0';
            node.element.style.transform = 'scale(0)';
            
            // Re-enable float animation when menu closes
            node.element.style.animationPlayState = 'running';
            
            console.log(`🧠 Node ${i} neural collapse initiated to orb (${orbCenterX}, ${orbCenterY})`);
          }, (this.nodes.length - 1 - i) * 20); // Fast reverse stagger
        });
      }

      // 🔄 NEW: Reposition menu items to stay bound to orb (for resize/orientation changes)
      repositionMenuToOrb() {
        if (!this.isMenuOpen || this.nodes.length === 0) return;
        
        console.log('🔄 Repositioning menu items to stay bound to orb');
        
        // Get current orb position (don't force it, work with it)
        const orbRect = this.orb.getBoundingClientRect();
        const orbCenterX = orbRect.left + orbRect.width / 2;
        const orbCenterY = orbRect.top + orbRect.height / 2;
        
        // 🌌 SIMPLIFIED: Same orbiting radius for all devices
        const radius = 140; // Consistent orbiting distance - satellites around Emma orb
        
        // Update all node positions relative to actual orb center
        this.nodes.forEach((node, i) => {
          const angle = (i / this.nodes.length) * Math.PI * 2 - Math.PI / 2;
          const newTargetX = orbCenterX + Math.cos(angle) * radius;
          const newTargetY = orbCenterY + Math.sin(angle) * radius;
          
          // Update positions with fast smooth transition
          const item = node.element;
          item.style.transition = 'all 0.15s ease';
          item.style.left = (newTargetX - 45) + 'px';
          item.style.top = (newTargetY - 45) + 'px';
          
          // Update node data
          node.x = newTargetX;
          node.y = newTargetY;
          node.targetX = newTargetX;
          node.targetY = newTargetY;
          node.baseX = newTargetX;
          node.baseY = newTargetY;
        });
      }

      initLoadingOrb() {
        try {
          const loadingOrbContainer = document.querySelector('.loading-orb');
          if (!loadingOrbContainer) {
            console.warn('🌟 Loading orb container not found');
            return;
          }

          if (window.EmmaOrb) {
            // Create WebGL Emma Orb for loading screen
            this.loadingOrb = new window.EmmaOrb(loadingOrbContainer, {
              hue: 270, // Emma's signature purple-pink
              hoverIntensity: 0.5,
              rotateOnHover: false,
              forceHoverState: true // Always show active state during loading
            });

          } else {
            console.warn('🌟 EmmaOrb class not available for loading, using fallback');
            // Fallback to gradient orb if WebGL not available
            const fallbackDiv = document.createElement('div');
            fallbackDiv.className = 'loading-orb-fallback';
            loadingOrbContainer.appendChild(fallbackDiv);
          }
        } catch (error) {
          console.error('🚨 Error initializing Loading Emma Orb:', error);
          // Fallback on error
          const loadingOrbContainer = document.querySelector('.loading-orb');
          if (loadingOrbContainer) {
            const fallbackDiv = document.createElement('div');
            fallbackDiv.className = 'loading-orb-fallback';
            loadingOrbContainer.appendChild(fallbackDiv);
          }
        }
      }

      initEmmaOrb() {
        try {
          const orbContainer = document.getElementById('webgl-orb-container');
          if (!orbContainer) {
            console.warn('🌟 WebGL orb container not found');
            return;
          }          if (window.EmmaOrb) {
            try {
              // Create WebGL Emma Orb with Emma's signature purple-pink hue
              this.webglOrb = new window.EmmaOrb(orbContainer, {
                hue: 270, // Purple-pink Emma colors
                hoverIntensity: 0.35,
                rotateOnHover: true,
                forceHoverState: false
              });

            } catch (webglError) {
              console.error('❌ WebGL orb creation failed:', webglError);
              // Force fallback
              window.EmmaOrb = null;
            }
          }

          if (!window.EmmaOrb || !this.webglOrb) {
            console.warn('🌟 EmmaOrb class not available, using fallback');
            // Fallback to beautiful gradient if EmmaOrb class not loaded
            orbContainer.style.background = 'radial-gradient(circle at 30% 30%, #8658ff, #4f46e5, #f093fb)';
            orbContainer.style.borderRadius = '50%';
            orbContainer.style.width = '100%';
            orbContainer.style.height = '100%';
            orbContainer.style.boxShadow = '0 0 40px rgba(134, 88, 255, 0.6), inset 0 0 40px rgba(255, 255, 255, 0.1)';
            orbContainer.style.animation = 'orb-pulse 3s ease-in-out infinite';

          }

          // Clean Emma orb - no vault unlock needed on dashboard
        } catch (error) {
          console.error('🚨 Error initializing Emma Orb:', error);
          // Ensure fallback is applied
          const orbContainer = document.getElementById('webgl-orb-container');
          if (orbContainer) {
            orbContainer.style.background = 'radial-gradient(circle at 30% 30%, #8658ff, #4f46e5)';
            orbContainer.style.borderRadius = '50%';
            orbContainer.style.width = '100%';
            orbContainer.style.height = '100%';
          }
        }
      }

      updateVaultNodeStatus() {
        try {

          const vaultNode = document.getElementById('vault-node');
          if (!vaultNode) {
            console.warn('⚠️ Vault node not found, skipping status update');
            // Try alternative selectors
            const altVaultNode = document.querySelector('[data-action="vault"], .radial-item[onclick*="vault"]');
            if (altVaultNode) {

              this.updateAlternativeVaultNode(altVaultNode);
            }
            return;
          }

          const vaultIcon = vaultNode.querySelector('.radial-item-icon');
          if (!vaultIcon) {
            console.warn('⚠️ Vault icon not found, trying alternative selector');
            const altIcon = vaultNode.querySelector('span, .icon');
            if (altIcon) {

              this.updateVaultIcon(altIcon, vaultNode);
              return;
            }
            return;
          }

          this.updateVaultIcon(vaultIcon, vaultNode);
        } catch (error) {
          console.warn('⚠️ Error updating vault node status:', error);
        }
      }

      updateVaultIcon(vaultIcon, vaultNode) {
        if (window.currentVaultStatus && window.currentVaultStatus.isUnlocked) {

          vaultIcon.textContent = '🔓';
          vaultNode.style.background = 'rgba(74, 222, 128, 0.1)'; // Green tint when unlocked
          vaultNode.style.borderColor = 'rgba(74, 222, 128, 0.3)';
          vaultNode.style.boxShadow = '0 0 20px rgba(74, 222, 128, 0.4)';
        } else {

          vaultIcon.textContent = '🔒';
          vaultNode.style.background = 'var(--emma-glass)'; // Default when locked
          vaultNode.style.borderColor = 'rgba(134, 88, 255, 0.3)';
          vaultNode.style.boxShadow = '0 0 20px rgba(134, 88, 255, 0.2)';
        }
      }

      updateAlternativeVaultNode(node) {
        const icon = node.querySelector('span') || node;
        if (window.currentVaultStatus && window.currentVaultStatus.isUnlocked) {
          icon.textContent = '🔓';
          node.style.background = 'rgba(74, 222, 128, 0.1)';
        } else {
          icon.textContent = '🔒';
          node.style.background = 'var(--emma-glass)';
        }
      }

      updateAllVaultIndicators() {

        // Update any vault-related elements
        const vaultElements = document.querySelectorAll('[data-action="vault"], .vault-indicator, #vault-node');
        vaultElements.forEach(element => {
          const icon = element.querySelector('span, .radial-item-icon') || element;
          if (window.currentVaultStatus && window.currentVaultStatus.isUnlocked) {
            if (icon.textContent) icon.textContent = '🔓';
            element.style.background = 'rgba(74, 222, 128, 0.1)';
            element.style.borderColor = 'rgba(74, 222, 128, 0.3)';
            element.style.boxShadow = '0 0 20px rgba(74, 222, 128, 0.4)';
          } else {
            if (icon.textContent) icon.textContent = '🔒';
            element.style.background = 'var(--emma-glass)';
            element.style.borderColor = 'rgba(134, 88, 255, 0.3)';
            element.style.boxShadow = '0 0 20px rgba(134, 88, 255, 0.2)';
          }
        });

      }

      // Check if a line intersects with Emma orb circle
      lineIntersectsCircle(x1, y1, x2, y2, cx, cy, radius) {
        // Vector from point1 to point2
        const dx = x2 - x1;
        const dy = y2 - y1;

        // Vector from point1 to circle center
        const fx = x1 - cx;
        const fy = y1 - cy;

        // Quadratic equation coefficients
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = (fx * fx + fy * fy) - radius * radius;

        const discriminant = b * b - 4 * a * c;

        // No intersection if discriminant is negative
        if (discriminant < 0) return false;

        // Check if intersection points are within the line segment
        const sqrt_discriminant = Math.sqrt(discriminant);
        const t1 = (-b - sqrt_discriminant) / (2 * a);
        const t2 = (-b + sqrt_discriminant) / (2 * a);

        // If either intersection point is within [0,1], line intersects circle
        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
      }

      animateNeuralNetwork() {
        // Resize canvas
        this.neuralCanvas.width = window.innerWidth;
        this.neuralCanvas.height = window.innerHeight;

        const animate = () => {
          if (!this.isMenuOpen && !this.isConstellationMode) return;

          // Clear canvas
          this.neuralCtx.clearRect(0, 0, this.neuralCanvas.width, this.neuralCanvas.height);

          // Draw subtle grid background when menu is open or in constellation mode
          if (this.isMenuOpen || this.isConstellationMode) {
            this.neuralCtx.strokeStyle = 'rgba(134, 88, 255, 0.03)';
            this.neuralCtx.lineWidth = 1;
            const gridSize = 50;

            // Draw vertical lines
            for (let x = 0; x < this.neuralCanvas.width; x += gridSize) {
              this.neuralCtx.beginPath();
              this.neuralCtx.moveTo(x, 0);
              this.neuralCtx.lineTo(x, this.neuralCanvas.height);
              this.neuralCtx.stroke();
            }

            // Draw horizontal lines
            for (let y = 0; y < this.neuralCanvas.height; y += gridSize) {
              this.neuralCtx.beginPath();
              this.neuralCtx.moveTo(0, y);
              this.neuralCtx.lineTo(this.neuralCanvas.width, y);
              this.neuralCtx.stroke();
            }
          }

          // Update node positions with organic movement (only for visible nodes)
          const time = Date.now() * 0.001;
          this.nodes.forEach((node, i) => {
            // CRITICAL FIX: Only animate visible nodes
            const nodeElement = node.element || document.getElementById(node.id);
            if (!nodeElement || nodeElement.style.display === 'none') {
              return; // Skip animation for hidden nodes
            }
            // Different floating movement for radial vs constellation nodes
            let floatX, floatY;
            if (node.orbBound) {
              // 🎯 RADIAL MENU NODES: Much tighter floating to stay within 50px radius
              floatX = Math.sin(time * 0.3 + i) * 3; // Reduced from 12px to 3px
              floatY = Math.cos(time * 0.2 + i * 0.5) * 2; // Reduced from 8px to 2px
            } else {
              // 🌌 CONSTELLATION NODES: Normal floating movement
              floatX = Math.sin(time * 0.3 + i) * 12;
              floatY = Math.cos(time * 0.2 + i * 0.5) * 8;
            }

            // Gentle elastic force back to base position (petri dish feel)
            const dx = (node.baseX + floatX) - node.x;
            const dy = (node.baseY + floatY) - node.y;

            node.vx += dx * 0.005; // Much gentler elastic force
            node.vy += dy * 0.005;

            // Apply more damping for organic feel
            node.vx *= 0.98;
            node.vy *= 0.98;

            // Add repulsion from Emma orb (prevent overlap)
            if (this.centralNode && this.isConstellationMode) {
              const orbDx = node.x - this.centralNode.x;
              const orbDy = node.y - this.centralNode.y;
              const orbDist = Math.sqrt(orbDx * orbDx + orbDy * orbDy);

              // Repulsion zone around Emma orb
              const repulsionRadius = 150;
              if (orbDist < repulsionRadius && orbDist > 0) {
                const repulsionForce = (repulsionRadius - orbDist) / repulsionRadius;
                const forceStrength = repulsionForce * 0.3; // Gentle but firm repulsion

                const normalizedDx = orbDx / orbDist;
                const normalizedDy = orbDy / orbDist;

                node.vx += normalizedDx * forceStrength;
                node.vy += normalizedDy * forceStrength;
              }
            }

            // Add gentle repulsion between memory nodes (prevent overlap)
            if (this.isConstellationMode) {
              this.nodes.forEach((otherNode, j) => {
                if (i !== j) {
                  // CRITICAL FIX: Only calculate repulsion with visible nodes
                  const otherElement = otherNode.element || document.getElementById(otherNode.id);
                  if (!otherElement || otherElement.style.display === 'none') {
                    return; // Skip repulsion with hidden nodes
                  }
                  const nodeDx = node.x - otherNode.x;
                  const nodeDy = node.y - otherNode.y;
                  const nodeDist = Math.sqrt(nodeDx * nodeDx + nodeDy * nodeDy);

                  // Minimum distance between nodes
                  const minNodeDistance = 110;
                  if (nodeDist < minNodeDistance && nodeDist > 0) {
                    const repulsionForce = (minNodeDistance - nodeDist) / minNodeDistance;
                    const forceStrength = repulsionForce * 0.1; // Very gentle node repulsion

                    const normalizedDx = nodeDx / nodeDist;
                    const normalizedDy = nodeDy / nodeDist;

                    node.vx += normalizedDx * forceStrength;
                    node.vy += normalizedDy * forceStrength;
                  }
                }
              });
            }

            // Update position
            node.x += node.vx;
            node.y += node.vy;

            // 🎯 RADIAL MENU CONSTRAINT: Hard limit radial nodes with proper breathing room from orb
            if (node.orbBound && this.orbNeuralNode) {
              const orbDx = node.x - this.orbNeuralNode.x;
              const orbDy = node.y - this.orbNeuralNode.y;
              const orbDistance = Math.sqrt(orbDx * orbDx + orbDy * orbDy);
              
              // 🌌 SIMPLIFIED: One max distance for all devices - orbiting constraint
              const MAX_RADIAL_DISTANCE = 150; // Orbiting distance + small buffer for physics
              
              if (orbDistance > MAX_RADIAL_DISTANCE) {
                // Constrain to max distance from orb center
                const constrainedX = this.orbNeuralNode.x + (orbDx / orbDistance) * MAX_RADIAL_DISTANCE;
                const constrainedY = this.orbNeuralNode.y + (orbDy / orbDistance) * MAX_RADIAL_DISTANCE;
                node.x = constrainedX;
                node.y = constrainedY;
                
                // Zero out velocity to prevent further drift
                node.vx *= 0.5;
                node.vy *= 0.5;
              }
            }

            // Update DOM element position
            node.element.style.left = node.x - 45 + 'px';
            node.element.style.top = node.y - 45 + 'px';
          });

          // Draw connections with gradients (only between visible nodes)
          this.nodes.forEach(node => {
            // CRITICAL FIX: Check if source node is visible before drawing connections
            const sourceElement = node.element || document.getElementById(node.id);
            if (!sourceElement || sourceElement.style.display === 'none') {
              return; // Skip connections from hidden nodes
            }

            node.connections.forEach(target => {
              // CRITICAL FIX: Check if target node is visible before drawing connection
              const targetElement = target.element || document.getElementById(target.id);
              if (!targetElement || targetElement.style.display === 'none') {
                return; // Skip connections to hidden nodes
              }

              // Check if line would pass through Emma orb area - if so, skip drawing
              const centerX = window.innerWidth / 2;
              const centerY = window.innerHeight / 2;
              const orbRadius = 110; // Clean boundary around orb

              if (this.lineIntersectsCircle(node.x, node.y, target.x, target.y, centerX, centerY, orbRadius)) {
                return; // Skip drawing this connection - it would cross the orb
              }

              // Calculate distance for opacity
              const dist = Math.sqrt(
                Math.pow(node.x - target.x, 2) +
                Math.pow(node.y - target.y, 2)
              );

              // Different opacity for main menu vs memory constellation
              const isMemoryMode = this.isConstellationMode && !this.isMenuOpen;
              const gradient = this.neuralCtx.createLinearGradient(
                node.x, node.y, target.x, target.y
              );

              if (isMemoryMode) {
                // Visible connections for memory constellation
                gradient.addColorStop(0, 'rgba(134, 88, 255, 0.2)');
                gradient.addColorStop(0.5, 'rgba(240, 147, 251, 0.15)');
                gradient.addColorStop(1, 'rgba(134, 88, 255, 0.2)');
                this.neuralCtx.lineWidth = 1.2 + Math.sin(time + dist * 0.01) * 0.2;
              } else {
                // Subtle connections for main menu (original loved style)
                gradient.addColorStop(0, 'rgba(134, 88, 255, 0.03)');
                gradient.addColorStop(0.5, 'rgba(240, 147, 251, 0.02)');
                gradient.addColorStop(1, 'rgba(134, 88, 255, 0.03)');
                this.neuralCtx.lineWidth = 0.5 + Math.sin(time + dist * 0.01) * 0.1;
              }

              this.neuralCtx.strokeStyle = gradient;

              this.neuralCtx.beginPath();
              this.neuralCtx.moveTo(node.x, node.y);

              // Gentle organic curved connections
              const midX = (node.x + target.x) / 2;
              const midY = (node.y + target.y) / 2;
              const curve1 = Math.sin(time * 0.4 + node.x * 0.005) * 15;
              const curve2 = Math.cos(time * 0.3 + node.y * 0.005) * 10;

              this.neuralCtx.bezierCurveTo(
                node.x + curve1,
                node.y + curve2,
                target.x - curve2,
                target.y - curve1,
                target.x,
                target.y
              );

              this.neuralCtx.stroke();
            });
          });

          // Remove energy pulses - too aggressive

          this.neuralAnimationId = requestAnimationFrame(animate);
        };

        animate();
      }

      // 🎯 SAFE URL PARAM HANDLER: Auto-trigger constellation or memory creation
      handleURLParams() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          
          if (urlParams.get('constellation') === 'true') {
            // Auto-enter constellation mode after a brief delay
            setTimeout(() => {
              console.log('🎯 AUTO-TRIGGERING: Constellation mode from URL param');
              this.enterMemoryConstellation();
            }, 2000); // Wait for dashboard to fully load
          }
          
          if (urlParams.get('create') === 'true') {
            // Auto-start voice capture for memory creation
            setTimeout(() => {
              console.log('🎯 AUTO-TRIGGERING: Memory creation from URL param');
              this.startVoiceCapture();
            }, 2000); // Wait for dashboard to fully load
          }
        } catch (error) {
          console.warn('🔧 URL param handling failed (non-critical):', error);
          // Safe fallback - do nothing if URL parsing fails
        }
      }

      async handleRadialAction(action) {

        switch(action) {
          case 'capture':
            this.startVoiceCapture();
            break;
          case 'memories':
            await this.enterMemoryConstellation();
            break;
          case 'people':
            window.location.href = 'pages/people-emma.html';
            break;
          case 'chat':
            this.startEmmaChatExperience();
            break;
        }

        // Close menu after action
        if (this.isMenuOpen) {
          this.toggleRadialMenu();
        }
      }

      async startVoiceCapture() {

        // Calculate elegant position relative to Emma orb
        const orbRect = this.orb.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Position the panel optimally
        let left = orbRect.right + 24;
        let top = Math.max(40, orbRect.top - 80);

        // Ensure it fits in viewport
        const panelWidth = 480;
        const panelHeight = 700;

        if (left + panelWidth > viewportWidth - 40) {
          left = orbRect.left - panelWidth - 24;
        }

        if (top + panelHeight > viewportHeight - 40) {
          top = viewportHeight - panelHeight - 40;
        }

        const position = {
          left: Math.max(40, left),
          top: Math.max(40, top),
          width: panelWidth,
          height: panelHeight
        };

        // Create and show voice capture experience
        this.voiceCaptureExperience = new VoiceCaptureExperience(position, {
          voiceEnabled: true,
          autoStart: false // Let user initiate
        });

        try {
          await this.voiceCaptureExperience.show();

        } catch (error) {
          console.error('🎤 Failed to open voice capture:', error);
          this.showToast('Failed to open Voice Memory Studio. Please try again.', 'error');
        }
      }

      async startEmmaChatExperience() {

        // Center chat in the middle of the page
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Chat panel dimensions
        const panelWidth = 600; // Wider for comfortable chat
        const panelHeight = 700;

        // Center position in the middle of the page
        const position = {
          left: (viewportWidth - panelWidth) / 2,
          top: (viewportHeight - panelHeight) / 2,
          width: panelWidth,
          height: panelHeight
        };

        // Create and show Emma chat experience
        this.emmaChatExperience = new EmmaChatExperience(position, {
          contextAware: true,
          memoryIntegration: true
        });

        try {
          await this.emmaChatExperience.show();

        } catch (error) {
          console.error('💬 Failed to open Emma Chat:', error);
          this.showToast('Failed to open Chat with Emma. Please try again.', 'error');
        }
      }

      openVaultModal() {
        // Check if extension is available first
        if (window.emmaWebVault && window.emmaWebVault.extensionAvailable) {
          // Extension is managing vault - dashboard should work automatically

          return; // Don't show vault modal, extension handles everything
        }

        const modal = document.getElementById('vault-modal');
        const statusIcon = document.getElementById('status-icon');
        const statusTitle = document.getElementById('status-title');
        const statusDescription = document.getElementById('status-description');
        const actionBtn = document.getElementById('vault-action-btn');
        const statusCard = document.getElementById('vault-status-card');
        const unlockSection = document.getElementById('unlock-section');
        const createVaultSection = document.getElementById('create-vault-section');

        // Check if .emma vault is active (only if extension not available)
        const vaultActive = sessionStorage.getItem('emmaVaultActive') === 'true';
        const vaultName = sessionStorage.getItem('emmaVaultName') || 'Unknown Vault';
        const extensionVaultActive = false; // Extension not available in this branch

        if (extensionVaultActive) {
          // Extension is managing vault - show connected status
          statusIcon.textContent = '🔗';
          statusTitle.textContent = 'Extension Connected';
          statusDescription.textContent = 'Vault managed by Emma Extension - changes auto-save to local file';
          actionBtn.textContent = '🔒 Manage via Extension';
          actionBtn.onclick = () => alert('Click the Emma extension icon 🔒 in your browser toolbar to manage your vault!');
          actionBtn.style.display = 'block';
          unlockSection.style.display = 'none';
          createVaultSection.style.display = 'none';
          statusCard.classList.add('unlocked'); // Show as unlocked/connected
        } else if (window.currentVaultStatus && window.currentVaultStatus.isUnlocked) {
          statusIcon.textContent = '🔓';
          statusTitle.textContent = `${vaultName} - Unlocked`;
          statusDescription.textContent = `Your .emma vault file is open and your memories are accessible`;
          actionBtn.textContent = '🔒 Lock Vault';
          actionBtn.onclick = () => this.lockVault();
          actionBtn.style.display = 'block';
          statusCard.classList.add('unlocked');
          unlockSection.style.display = 'none';
          createVaultSection.style.display = 'none';
        } else {
          statusIcon.textContent = '🔒';
          statusTitle.textContent = 'Vault Locked';
          statusDescription.textContent = 'Enter your vault code to access your memories';
          actionBtn.textContent = 'Unlock Vault';
          actionBtn.onclick = () => this.showUnlockForm();
          actionBtn.style.display = 'block';
          statusCard.classList.remove('unlocked');
          unlockSection.style.display = 'none';
          createVaultSection.style.display = 'none';
        }

        modal.style.display = 'flex';
        setTimeout(() => {
          modal.classList.add('show');
        }, 10);

        // Store reference for global access
        window.openVaultModal = () => this.openVaultModal();
      }

      closeVaultModal() {
        const modal = document.getElementById('vault-modal');
        modal.classList.remove('show');
        setTimeout(() => {
          modal.style.display = 'none';
        }, 300);
      }

      showUnlockForm() {
        // Use beautiful universal vault modal instead of inline form
        universalVaultModal.show({
          title: "Unlock Vault",
          message: "Enter your vault passphrase to access your secure memories",
          onSuccess: (result) => {

            // Update vault status using unified manager
            const vaultName = sessionStorage.getItem('emmaVaultName') || 'Web Vault';
            window.webVaultStatus.unlock(vaultName);

            // Refresh dashboard data and UI
            this.loadDashboardData();

            // IMMEDIATE vault icon update
            const vaultIcon = document.querySelector('#vault-node .radial-item-icon');
            if (vaultIcon) {
              vaultIcon.textContent = '🔓';

            }

            // Update vault node with delay to ensure DOM is ready
            setTimeout(() => {
              this.updateVaultNodeStatus();

              // Also try to update any other vault indicators
              this.updateAllVaultIndicators();

              // Force another immediate update
              const vaultIconAgain = document.querySelector('#vault-node .radial-item-icon');
              if (vaultIconAgain) {
                vaultIconAgain.textContent = '🔓';

              }
            }, 100);

            // Don't reopen modal - let it close naturally
            // The next time user opens it, it will show correct status

            this.showToast('✅ Vault unlocked successfully!', 'success');

          },
          onCancel: () => {

          }
        });
      }

      hideUnlockForm() {
        const unlockSection = document.getElementById('unlock-section');
        const passwordInput = document.getElementById('vault-password');
        unlockSection.style.display = 'none';
        passwordInput.value = '';
      }

      async unlockVault() {
        const passwordInput = document.getElementById('vault-password');
        const unlockBtn = document.getElementById('unlock-btn');
        const password = passwordInput.value.trim();

        if (!password) {
          passwordInput.focus();
          return;
        }

        try {
          unlockBtn.disabled = true;
          unlockBtn.textContent = '🔓 Unlocking...';

          if (window.emmaAPI && window.emmaAPI.vault) {
            const result = await window.emmaAPI.vault.unlock({ passphrase: password });

            if (result && result.success) {
              // Success - update status and close form
              window.currentVaultStatus = { isUnlocked: true };
              await this.loadDashboardData();
              this.updateVaultNodeStatus(); // Update the floating vault node
              this.hideUnlockForm();
              this.openVaultModal(); // Refresh modal with new status
              this.showToast('✅ Vault unlocked successfully!', 'success');
            } else {
              throw new Error(result?.error || 'Unlock failed');
            }
          } else {
            // No API available
            throw new Error('Vault API not available');
          }
        } catch (error) {
          console.error('🏠 Dashboard: Unlock error:', error);
          this.showToast('❌ Failed to unlock vault: ' + error.message, 'error');
        } finally {
          unlockBtn.disabled = false;
          unlockBtn.textContent = '🔓 Unlock';
        }
      }

      async lockVault() {
        try {
          if (window.emmaAPI && window.emmaAPI.vault) {
            const result = await window.emmaAPI.vault.lock();

            if (result && result.success) {
              window.currentVaultStatus = { isUnlocked: false };
              await this.loadDashboardData();
              this.updateVaultNodeStatus(); // Update the floating vault node
              this.openVaultModal(); // Refresh modal with new status
              this.showToast('🔒 Vault locked successfully!', 'success');
            } else {
              throw new Error(result?.error || 'Lock failed');
            }
          } else {
            // Demo mode
            console.warn('🏠 Dashboard: No Emma API - demo lock');
            window.currentVaultStatus = { isUnlocked: false };
            await this.loadDashboardData();
            this.updateVaultNodeStatus(); // Update the floating vault node
            this.openVaultModal();
            this.showToast('🎭 Demo vault locked!', 'info');
          }
        } catch (error) {
          console.error('🏠 Dashboard: Lock error:', error);
          this.showToast('❌ Failed to lock vault: ' + error.message, 'error');
        }
      }

      // Clean dashboard - vault unlock handled by index.html

      async showQRShare() {

        // Check if classes are available
        if (typeof EmmaShareExperience === 'undefined') {
          console.error('🔗 EmmaShareExperience class not found');
          this.showToast('Share feature unavailable. Please refresh the page.', 'error');
          return;
        }

        if (typeof QRService === 'undefined') {
          console.warn('🔗 QRService class not found - will use fallback');
        }

        // Calculate elegant position relative to Emma orb
        const orbRect = this.orb.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;        // Position the share panel optimally
        let left = orbRect.right + 24;
        let top = Math.max(40, orbRect.top - 120);

        // Share panel dimensions
        const panelWidth = 650; // Wider for share content
        const panelHeight = 720;

        // Ensure it fits in viewport
        if (left + panelWidth > viewportWidth - 40) {
          left = orbRect.left - panelWidth - 24;
        }

        if (top + panelHeight > viewportHeight - 40) {
          top = viewportHeight - panelHeight - 40;
        }

        const position = {
          left: Math.max(40, left),
          top: Math.max(40, top),
          width: panelWidth,
          height: panelHeight
        };

        try {
          // Create and show Emma share experience
          this.emmaShareExperience = new EmmaShareExperience(position, {
            contextAware: true,
            vaultIntegration: true
          });

          // Set global reference for share actions
          window.shareExperience = this.emmaShareExperience;

          await this.emmaShareExperience.show();

        } catch (error) {
          console.error('🔗 Failed to open Emma Share:', error);
          this.showToast('Failed to open Share interface: ' + error.message, 'error');
        }
      }

      async loadDashboardData() {
        try {
          // Use WebVaultStatus instead of old Electron API

          // Don't override vault status - WebVaultStatus manages it
          // window.currentVaultStatus is set by WebVaultStatus manager

          // Keep central orb neutral - Emma branding only (text removed)

          // Load stats from web vault
          try {
            if (window.emmaWebVault && window.webVaultStatus && window.webVaultStatus.isUnlocked()) {
              const stats = window.emmaWebVault.getStats();
              this.updateStats({
                memories: stats.memoryCount || 0,
                people: stats.peopleCount || 0,
                today: 0 // TODO: Calculate today's memories
              });
            } else {
              this.updateStats({ memories: 0, people: 0, today: 0 });
            }
          } catch (e) {
            console.warn('⚠️ Web vault stats unavailable:', e.message);
            this.updateStats({ memories: 0, people: 0, today: 0 });
          }
        } catch (error) {
          console.error('🚨 Dashboard data load error:', error);
          // Fallback to demo data - but DON'T override vault status!
          // WebVaultStatus manager handles vault status, not this function
          this.updateStats({ memories: 0, people: 0, today: 0 });
        }
      }

      updateStats(newStats) {
        Object.assign(this.stats, newStats);

        // Animate number changes
        Object.keys(newStats).forEach(key => {
          const element = document.getElementById(`stat-${key}`);
          if (element) {
            const start = parseInt(element.textContent) || 0;
            const end = this.stats[key];
            const duration = 1000;
            const startTime = Date.now();

            const animate = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const current = Math.floor(start + (end - start) * progress);
              element.textContent = current;

              if (progress < 1) {
                requestAnimationFrame(animate);
              }
            };
            animate();
          }
        });
      }

      showContextualPanels() {
        // Panels are now hidden by default and shown via burger menu
        // No longer auto-showing panels to reduce visual distraction

      }

      // Burger menu removed for clean interface

      setupUtilityIcons() {
        if (!this.utilityIcons) {
          return;
        }

        // Add click handlers to utility items
        this.utilityIcons.querySelectorAll('.utility-item').forEach(item => {
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = item.dataset.action;
            this.handleUtilityAction(action);
          });
        });

      }

      handleUtilityAction(action) {

        switch(action) {
          case 'settings':
            window.location.href = 'pages/emma-settings-redesigned.html';
            break;
          default:

        }
      }

      togglePanels() {
        this.panelsVisible = !this.panelsVisible;

        // Toggle body class for CSS animations
        if (this.panelsVisible) {
          document.body.classList.add('panels-visible');
          this.burgerMenuBtn.classList.add('active');

          // Also add active class to each panel for visibility
          if (this.panels.dailyBrief) this.panels.dailyBrief.classList.add('active');
          if (this.panels.aiInsights) this.panels.aiInsights.classList.add('active');
          if (this.panels.quickActions) this.panels.quickActions.classList.add('active');
        } else {
          document.body.classList.remove('panels-visible');
          this.burgerMenuBtn.classList.remove('active');

          // Remove active class from panels
          if (this.panels.dailyBrief) this.panels.dailyBrief.classList.remove('active');
          if (this.panels.aiInsights) this.panels.aiInsights.classList.remove('active');
          if (this.panels.quickActions) this.panels.quickActions.classList.remove('active');
        }

      }

      startAnimations() {
        // Subtle pulse animation for WebGL orb
        setInterval(() => {
          if (window.currentVaultStatus && !window.currentVaultStatus.isUnlocked) {
            const orbContainer = this.orb.querySelector('.emma-orb-webgl');
            if (orbContainer) {
              orbContainer.style.animation = 'orb-pulse 2s ease-in-out';
            }
          }
        }, 5000);
      }      // Enter memory constellation mode
      async enterMemoryConstellation() {

        // CRITICAL: Clear any existing memory nodes first (prevents duplicates)
        this.clearAllMemoryNodesFromDOM();

        this.isConstellationMode = true;

        // PERSISTENCE: Save constellation state for page refresh
        localStorage.setItem('emmaConstellationActive', 'true');

        // Add constellation-active class to hide all UI
        document.body.classList.add('constellation-active');

        // Shrink central orb
        this.shrinkCentralOrb();

        // 🔍 CREATE ZOOMABLE CONSTELLATION CONTAINER
        this.createConstellationContainer();

        // Load memory data for constellation
        await this.loadMemoriesForConstellation();

        // Fade out current nodes
        await this.fadeOutMenuNodes();

        // Create memory constellation (await for real memories)
        await this.createMemoryConstellation();

        // Show constellation UI with zoom controls
        this.showConstellationUI();
      }

      // Shrink central Emma orb when memories are visible
      shrinkCentralOrb() {

        
        // 🎭 FADE OUT orb first
        this.orb.style.transition = 'opacity 0.4s ease, transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
        this.orb.style.opacity = '0';
        
        // After fade out, reposition to bottom center
        setTimeout(() => {
          // 📍 REPOSITION: Move to bottom center
          this.orb.style.position = 'fixed';
          this.orb.style.top = 'auto';
          this.orb.style.bottom = '40px';
          this.orb.style.left = '50%';
          this.orb.style.transform = 'translateX(-50%) scale(0.6)';
          this.orb.style.zIndex = '99999'; // CRITICAL: Above ALL overlays and constellation nodes
          this.orb.style.pointerEvents = 'auto'; // CRITICAL: Ensure orb is clickable
          
          // 🎭 FADE IN at new position
          setTimeout(() => {
            this.orb.style.opacity = '0.9';

          }, 100);
          
        }, 400); // Wait for fade out to complete

        // Add hover effects for memory mode
        this.addOrbHoverEffects();
      }

      // Add hover effects to orb in memory mode
      addOrbHoverEffects() {
        if (this.orbHoverAdded) return;
        this.orbHoverAdded = true;

        const orbContainer = this.orb.querySelector('.emma-orb-webgl');

        this.orb.addEventListener('mouseenter', () => {
          if (this.isConstellationMode) {
            // 🎯 HOVER: Scale up while maintaining bottom center position
            this.orb.style.transform = 'translateX(-50%) scale(0.8)';
            this.orb.style.opacity = '1';
          }
        });

        this.orb.addEventListener('mouseleave', () => {
          if (this.isConstellationMode) {
            // 🎯 HOVER OUT: Return to normal size at bottom center
            this.orb.style.transform = 'translateX(-50%) scale(0.6)';
            this.orb.style.opacity = '0.9';
          }
        });
      }

      // Restore central Emma orb to original center position
      restoreCentralOrb() {

        
        // 🎭 FADE OUT from bottom position
        this.orb.style.transition = 'opacity 0.3s ease';
        this.orb.style.opacity = '0';
        
        setTimeout(() => {
          // 📍 RESTORE: Move back to center
          this.orb.style.position = 'fixed';
          this.orb.style.top = '50%';
          this.orb.style.bottom = 'auto';
          this.orb.style.left = '50%';
          this.orb.style.transform = 'translate(-50%, -50%) scale(1)';
          this.orb.style.zIndex = '10';
          
          // Reset transitions for normal behavior
          this.orb.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
          
          // 🎭 FADE IN at center
          setTimeout(() => {
            this.orb.style.opacity = '1';

          }, 100);
          
        }, 300); // Wait for fade out
      }

      // Load memories for constellation
      async loadMemoriesForConstellation() {
        try {
          // Get memories from API
          let memories = await this.getMemories();

          if (memories.length > 0) {

            console.log('💝 CONSTELLATION DEBUG: Memory titles:', memories.map(m => m.title));
          }

          // Add debugging info about available APIs

          this.constellationMemories = this.organizeMemoriesByTheme(memories);

          // Count total memories
          const totalMemories = Object.values(this.constellationMemories).reduce((sum, theme) => sum + theme.length, 0);

          // If no memories, suggest user create some
          if (totalMemories === 0) {

          }

        } catch (error) {

          this.constellationMemories = {family: [], travel: [], recent: [], special: []};
        }
      }

      // Get memories from vault (same API as gallery)
      async getMemories() {
        try {
          let allMemories = [];

          // 1. FIRST: Get vault memories (if available)
          if (window.emmaWebVault && window.emmaWebVault.isOpen && window.emmaWebVault.vaultData) {

            const vaultMemories = window.emmaWebVault.vaultData.content?.memories || {};
            const vaultMedia = window.emmaWebVault.vaultData.content?.media || {};

            // Convert vault memories to array format with LIGHTWEIGHT LOADING for constellation
            const memories = Object.values(vaultMemories).map(memory => {
              // 🚀 PERFORMANCE FIX: Only create lightweight attachment previews for constellation
              // Full media will be loaded on-demand when memory is clicked
              const attachmentPreviews = (memory.attachments || []).map(attachment => {
                const mediaItem = vaultMedia[attachment.id];
                return {
                  id: attachment.id,
                  type: attachment.type,
                  name: attachment.name,
                  size: attachment.size,
                  // 💡 LAZY LOADING: Store media ID for on-demand loading, don't load data URL yet
                  mediaId: attachment.id,
                  hasMedia: !!(mediaItem && mediaItem.data),
                  isLazyLoaded: true, // Flag to indicate this needs full loading on click
                  // Only create preview thumbnail for first image attachment
                  previewUrl: null // Will be set below for first image only
                };
              });

              // 🎯 OPTIMIZATION: Only load preview for FIRST image attachment (for constellation thumbnail)
              if (attachmentPreviews.length > 0) {
                const firstImageAttachment = attachmentPreviews.find(att => 
                  att.hasMedia && (att.type?.startsWith('image/') || !att.type?.startsWith('video/'))
                );
                
                if (firstImageAttachment) {
                  const mediaItem = vaultMedia[firstImageAttachment.id];
                  if (mediaItem && mediaItem.data) {
                    // Only load the first image for constellation thumbnail
                    firstImageAttachment.previewUrl = mediaItem.data.startsWith('data:')
                      ? mediaItem.data
                      : `data:${mediaItem.type};base64,${mediaItem.data}`;
                  }
                }
              }

              return {
                ...memory,
                // FIXED: Transform like gallery pages do - extract title from content/metadata
                title: memory.metadata?.title || memory.title || memory.subject || memory.summary || memory.content?.substring(0, 50) + '...' || `Memory`,
                attachments: attachmentPreviews, // Lightweight previews only
                attachmentCount: attachmentPreviews.length,
                hasMedia: attachmentPreviews.some(att => att.hasMedia),
                isVaultMemory: true
              };
            });

            // Add thumbnail from first attachment for constellation display
            const memoriesWithThumbnails = memories.map(memory => {
              const attachments = memory.attachments || [];
              let thumbnail = memory.thumbnail;

              // 🎯 PERFORMANCE: Use previewUrl from first image attachment for thumbnail
              if (!thumbnail && attachments.length > 0) {
                const firstImageWithPreview = attachments.find(att => att.previewUrl);
                if (firstImageWithPreview) {
                  thumbnail = firstImageWithPreview.previewUrl;
                }
              }

              return {
                ...memory,
                thumbnail
              };
            });

            allMemories = [...memoriesWithThumbnails];
            console.log('💝 CONSTELLATION: Loaded', allMemories.length, 'vault memories');
            console.log('💝 CONSTELLATION DEBUG: First memory structure:', allMemories[0]);
            console.log('💝 CONSTELLATION DEBUG: First memory keys:', Object.keys(allMemories[0] || {}));
          }

          // Note: All memories should be stored directly in vault - no fallback needed

          return allMemories;

        } catch (error) {
          console.error('💝 CONSTELLATION: Error loading memories from vault:', error);
          return [];
        }
      }

      // Helper to detect category from memory content
      detectCategoryFromContent(memory) {
        const content = ((memory.title || '') + ' ' + (memory.content || '')).toLowerCase();
        if (content.includes('family') || content.includes('mom') || content.includes('dad')) return 'family';
        if (content.includes('travel') || content.includes('trip') || content.includes('vacation')) return 'travel';
        if (memory.timestamp && new Date() - new Date(memory.timestamp) < 30 * 24 * 60 * 60 * 1000) return 'recent';
        return 'special';
      }

      // Generate organic neural network positions (NOT circular)
      generateNeuralNetworkPositions(nodeCount, centerX, centerY, width, height, minDistance) {
        const positions = [];
        const maxAttempts = 100;

        // First position: Create Memory node in top-center area
        positions.push({
          x: centerX + (Math.random() - 0.5) * 100,
          y: centerY - height * 0.25 + (Math.random() - 0.5) * 80
        });

        // Generate remaining positions with organic scatter
        for (let i = 1; i < nodeCount; i++) {
          let placed = false;
          let attempts = 0;

          while (!placed && attempts < maxAttempts) {
            // Use clustered random distribution (not uniform)
            const clusterX = centerX + (Math.random() - 0.5) * width;
            const clusterY = centerY + (Math.random() - 0.5) * height;

            // Add some organic bias toward clusters
            const biasStrength = Math.random() * 0.3;
            const biasAngle = Math.random() * Math.PI * 2;
            const x = clusterX + Math.cos(biasAngle) * biasStrength * 150;
            const y = clusterY + Math.sin(biasAngle) * biasStrength * 150;

            // Check minimum distance from all existing nodes AND center orb
            let validPosition = true;

            // Check distance from center Emma orb (exclusion zone)
            const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            if (distFromCenter < 150) { // 150px exclusion zone around Emma orb
              validPosition = false;
            }

            // Check distance from other nodes
            if (validPosition) {
              for (const pos of positions) {
                const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                if (dist < minDistance) {
                  validPosition = false;
                  break;
                }
              }
            }

            // Keep nodes within bounds
            if (validPosition &&
                x > centerX - width/2 + 50 && x < centerX + width/2 - 50 &&
                y > centerY - height/2 + 50 && y < centerY + height/2 - 50) {
              positions.push({ x, y });
              placed = true;
            }

            attempts++;
          }

          // Fallback if can't place after max attempts
          if (!placed) {
            const angle = (i / nodeCount) * Math.PI * 2;
            const fallbackRadius = 200 + Math.random() * 100;
            positions.push({
              x: centerX + Math.cos(angle) * fallbackRadius,
              y: centerY + Math.sin(angle) * fallbackRadius
            });
          }
        }

        return positions;
      }      // Generate memory thumbnail based on theme
      generateMemoryThumbnail(theme) {
        const themeEmojis = {
          family: ['👨‍👩‍👧‍👦', '🏠', '❤️', '🍽️', '🎂'],
          travel: ['✈️', '🗺️', '📸', '🏖️', '🏔️'],
          recent: ['📱', '☕', '🌅', '🎵', '📚'],
          special: ['🎉', '💝', '🌟', '🎈', '🎊']
        };
        const emojis = themeEmojis[theme] || ['💫'];
        return emojis[Math.floor(Math.random() * emojis.length)];
      }

      // Organize memories by theme for constellations
      organizeMemoriesByTheme(memories) {
        const organized = {
          family: [],
          travel: [],
          recent: [],
          special: []
        };

        memories.forEach(memory => {
          const theme = memory.theme || this.detectMemoryTheme(memory);
          if (organized[theme]) {
            organized[theme].push(memory);
          } else {
            organized.special.push(memory);
          }
        });

        return organized;
      }

      // Detect memory theme from content
      detectMemoryTheme(memory) {
        // Use category first, then fallback to content analysis
        if (memory.category) {
          return memory.category;
        }

        const content = (memory.title + ' ' + (memory.content || memory.description || '')).toLowerCase();
        if (content.includes('family') || content.includes('mom') || content.includes('dad')) return 'family';
        if (content.includes('travel') || content.includes('trip') || content.includes('vacation')) return 'travel';
        if (memory.date && new Date() - new Date(memory.date) < 30 * 24 * 60 * 60 * 1000) return 'recent';
        return 'special';
      }

      // Fade out menu nodes
      async fadeOutMenuNodes() {
        return new Promise(resolve => {
          this.radialMenu.querySelectorAll('.radial-item').forEach((item, i) => {
            setTimeout(() => {
              item.style.transition = 'all 0.5s ease';
              item.style.opacity = '0';
              item.style.transform = 'scale(0)';
            }, i * 50);
          });

          setTimeout(resolve, 500);
        });
      }

      // Create memory constellation using EXACT working neural network system
      async createMemoryConstellation() {

        // CRITICAL: Remove any existing memory nodes from DOM first
        this.clearAllMemoryNodesFromDOM();

        // Clear existing nodes array
        this.nodes = [];

        // Don't reload memories - use already loaded ones from enterMemoryConstellation()

        // Get memories for constellation
        const allMemories = [];
        Object.keys(this.constellationMemories).forEach(theme => {
          this.constellationMemories[theme].forEach(memory => {
            allMemories.push({ ...memory, theme });
          });
        });

        // Load people from vault for constellation
        const allPeople = await this.loadPeopleForConstellation();
        this.constellationPeople = allPeople; // Store for filtering

        if (allMemories.length === 0 && allPeople.length === 0) {
          console.warn('💝 No memories or people found in vault - constellation will show only the Create Memory node');
        }

        // Create memory and people nodes using EXACT same pattern as main menu
        this.initMemoryNeuralNetwork(allMemories, allPeople);

        // Set up for constellation mode without triggering menu
        this.isMenuOpen = false; // CRITICAL: Constellation mode starts with menu closed
        this.radialMenu.classList.remove('active'); // Ensure menu is hidden
        document.body.classList.remove('menu-active');

        // Start the neural animation (EXACT same as main menu)
        this.animateNeuralNetwork();

      }

      // Load people from vault for constellation
      async loadPeopleForConstellation() {
        try {

          if (window.emmaAPI && window.emmaAPI.people && window.emmaAPI.people.list) {
            const result = await window.emmaAPI.people.list();

            if (result && result.success && Array.isArray(result.items)) {

              return result.items;
            }
          }

          return [];

        } catch (error) {
          console.error('👥 CONSTELLATION: Error loading people:', error);
          return [];
        }
      }

      // Initialize memory neural network using EXACT same pattern as working main menu
      initMemoryNeuralNetwork(memories, people = []) {

        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        // Neural network layout parameters
        const networkWidth = Math.min(window.innerWidth * 0.7, 800);
        const networkHeight = Math.min(window.innerHeight * 0.7, 600);
        const minDistance = 120; // Minimum distance between nodes

        // Take up to 12 memories and up to 8 people for balanced constellation
        const selectedMemories = memories.slice(0, 12);
        const selectedPeople = people.slice(0, 8);
        const totalNodes = selectedMemories.length + selectedPeople.length + 1; // +1 for create node

        // Generate organic neural network positions
        const positions = this.generateNeuralNetworkPositions(totalNodes, centerX, centerY, networkWidth, networkHeight, minDistance);

        // Always add "Create New Memory" node at the first position (top-center area)
        const createPos = positions[0];
        const createMemoryElement = this.createCreateMemoryNodeElement(createPos.x, createPos.y);
        this.nodes.push({
          element: createMemoryElement,
          x: createPos.x,
          y: createPos.y,
          vx: 0,
          vy: 0,
          baseX: createPos.x,
          baseY: createPos.y,
          connections: [],
          isCreateNode: true
        });

        // Create memory nodes in organic neural pattern
        selectedMemories.forEach((memory, i) => {
          const pos = positions[i + 1]; // Skip position 0 (create node)

          // Create memory node element
          const memoryElement = this.createMemoryNodeElement(memory, pos.x, pos.y);

          this.nodes.push({
            element: memoryElement,
            x: pos.x,
            y: pos.y,
            vx: 0,
            vy: 0,
            baseX: pos.x,
            baseY: pos.y,
            connections: [],
            memory: memory,
            type: 'memory'
          });
        });

        // Create people nodes in remaining positions
        selectedPeople.forEach((person, i) => {
          const posIndex = selectedMemories.length + i + 1; // Skip create node and memory nodes
          const pos = positions[posIndex];

          if (pos) { // Make sure we have a position
            // Create person node element
            const personElement = this.createPersonNodeElement(person, pos.x, pos.y);

            this.nodes.push({
              element: personElement,
              x: pos.x,
              y: pos.y,
              vx: 0,
              vy: 0,
              baseX: pos.x,
              baseY: pos.y,
              connections: [],
              person: person,
              type: 'person'
            });
          }
        });

        // Create intelligent connections between memories and people
        this.createMemoryPeopleConnections(selectedMemories, selectedPeople);

        // Create organic neural network connections (NOT spoked wheel)
        this.nodes.forEach((node, i) => {
          // Connect to 2-4 nearby nodes within a certain distance (organic clustering)
          this.nodes.forEach((otherNode, j) => {
            if (i !== j) {
              const dist = Math.sqrt(
                Math.pow(node.x - otherNode.x, 2) +
                Math.pow(node.y - otherNode.y, 2)
              );

              // Connect to nodes within a reasonable distance (creates natural clusters)
              if (dist < 250 && node.connections.length < 4) {
                node.connections.push(otherNode);
              }
            }
          });

          // Ensure each node has at least 2 connections (prevent isolated nodes)
          if (node.connections.length < 2) {
            // Find the 2 closest nodes
            const distances = this.nodes
              .map((otherNode, j) => ({ node: otherNode, index: j, dist: j === i ? Infinity : Math.sqrt(Math.pow(node.x - otherNode.x, 2) + Math.pow(node.y - otherNode.y, 2)) }))
              .sort((a, b) => a.dist - b.dist)
              .slice(0, 2);

            distances.forEach(({ node: closestNode }) => {
              if (!node.connections.includes(closestNode)) {
                node.connections.push(closestNode);
              }
            });
          }
        });

        // Add central orb as a special node (but only some memory nodes connect to it)
        this.centralNode = {
          x: centerX,
          y: centerY,
          element: this.orb
        };

        // Only 3-4 random memory nodes connect to center (not all - avoids spoked wheel)
        const centralConnections = Math.min(4, Math.floor(this.nodes.length / 3));
        const shuffledNodes = [...this.nodes].sort(() => Math.random() - 0.5);
        shuffledNodes.slice(0, centralConnections).forEach(node => {
          node.connections.push(this.centralNode);
        });

      }

      // Create memory node element that opens memory capsule dialog
      createMemoryNodeElement(memory, x, y) {
        const memoryElement = document.createElement('div');
        memoryElement.className = 'memory-node';

        // Add theme data attribute for styling
        memoryElement.setAttribute('data-theme', memory.theme);

        // CLEAN CIRCULAR NODE - No text labels, pure image capsule
        memoryElement.style.cssText = `
          position: fixed;
          left: ${x}px;
          top: ${y}px;
          width: 80px;
          height: 80px;
          border-radius: 50%;
          border: 3px solid rgba(139, 92, 246, 0.6);
          cursor: pointer;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          opacity: 0;
          transform: scale(0);
          box-shadow: 0 8px 32px rgba(139, 92, 246, 0.4);
          z-index: 1500; /* CRITICAL FIX: Higher z-index to appear above all connections */
          overflow: hidden;
          display: flex;
          align-items: center;
          justify-content: center;
          pointer-events: auto; /* CRITICAL: Ensure nodes are clickable even with container pointer-events: none */
        `;

        // APPLY BACKGROUND AFTER BASE STYLING: Memory capsule as single node with image background
        if (memory.thumbnail) {
          // Use image as background of the entire node - NO separate elements
          memoryElement.style.backgroundImage = `url('${memory.thumbnail}')`;
          memoryElement.style.backgroundSize = 'cover';
          memoryElement.style.backgroundPosition = 'center';

        } else {
          // Fallback to gradient with emoji
          memoryElement.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%)';
          const emojiDiv = document.createElement('div');
          emojiDiv.style.cssText = 'font-size: 24px; color: white;';
          emojiDiv.textContent = '💝';
          memoryElement.appendChild(emojiDiv);

        }

        // Add click handler to open memory capsule dialog
        memoryElement.addEventListener('click', (e) => {
          e.stopPropagation();
          this.openMemoryCapsuleDialog(memory);
        });

        // Add hover effects
        memoryElement.addEventListener('mouseenter', () => {
          memoryElement.style.transform = 'scale(1.1)';
          memoryElement.style.boxShadow = '0 0 40px rgba(139, 92, 246, 0.6), 0 0 80px rgba(139, 92, 246, 0.4)';
        });

        memoryElement.addEventListener('mouseleave', () => {
          memoryElement.style.transform = 'scale(1)';
          memoryElement.style.boxShadow = '0 8px 32px rgba(139, 92, 246, 0.4)';
        });

        // 🔍 ZOOM FIX: Add to constellation container instead of body
        const targetContainer = this.constellationContainer || document.body;
        targetContainer.appendChild(memoryElement);

        // Animate in with random delay for organic feel
        const delay = Math.random() * 500 + 100;
        setTimeout(() => {
          memoryElement.style.transform = 'scale(1)';
          memoryElement.style.opacity = '1';
        }, delay);

        return memoryElement;
      }

      // Create the "Create New Memory" node element with elegant SVG +
      createCreateMemoryNodeElement(x, y) {
        const createElement = document.createElement('div');
        createElement.className = 'memory-node create-memory-node';
        
        // Create elegant SVG + icon
        const svgPlus = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgPlus.setAttribute('width', '24');
        svgPlus.setAttribute('height', '24');
        svgPlus.setAttribute('viewBox', '0 0 24 24');
        svgPlus.style.cssText = `
          filter: drop-shadow(0 0 8px rgba(16, 185, 129, 0.8));
          transition: all 0.3s ease;
        `;
        
        // Create + lines with elegant styling
        const horizontalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        horizontalLine.setAttribute('x1', '6');
        horizontalLine.setAttribute('y1', '12');
        horizontalLine.setAttribute('x2', '18');
        horizontalLine.setAttribute('y2', '12');
        horizontalLine.setAttribute('stroke', 'rgba(16, 185, 129, 1)');
        horizontalLine.setAttribute('stroke-width', '2');
        horizontalLine.setAttribute('stroke-linecap', 'round');
        
        const verticalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        verticalLine.setAttribute('x1', '12');
        verticalLine.setAttribute('y1', '6');
        verticalLine.setAttribute('x2', '12');
        verticalLine.setAttribute('y2', '18');
        verticalLine.setAttribute('stroke', 'rgba(16, 185, 129, 1)');
        verticalLine.setAttribute('stroke-width', '2');
        verticalLine.setAttribute('stroke-linecap', 'round');
        
        svgPlus.appendChild(horizontalLine);
        svgPlus.appendChild(verticalLine);
        createElement.appendChild(svgPlus);

        // Smaller, more elegant styling with compelling glow
        createElement.style.cssText = `
          position: fixed;
          left: ${x - 30}px;
          top: ${y - 30}px;
          width: 60px;
          height: 60px;
          background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 197, 94, 0.15));
          backdrop-filter: blur(20px);
          border: 2px solid rgba(16, 185, 129, 0.5);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          opacity: 0;
          transform: scale(0);
          box-shadow: 
            0 0 20px rgba(16, 185, 129, 0.4),
            0 0 40px rgba(16, 185, 129, 0.2),
            inset 0 0 20px rgba(16, 185, 129, 0.1);
          animation: addNodeGlow 3s ease-in-out infinite;
          z-index: 1500; /* CRITICAL FIX: Higher z-index to appear above all connections */
          pointer-events: auto; /* CRITICAL: Ensure create node is clickable even with container pointer-events: none */
        `;

        // Add hover effect with enhanced SVG glow
        createElement.addEventListener('mouseenter', () => {
          createElement.style.transform = 'scale(1.15)';
          createElement.style.boxShadow = `
            0 0 30px rgba(16, 185, 129, 0.6),
            0 0 60px rgba(16, 185, 129, 0.4),
            inset 0 0 30px rgba(16, 185, 129, 0.2)
          `;
          svgPlus.style.filter = 'drop-shadow(0 0 12px rgba(16, 185, 129, 1))';
        });

        createElement.addEventListener('mouseleave', () => {
          createElement.style.transform = 'scale(1)';
          createElement.style.boxShadow = `
            0 0 20px rgba(16, 185, 129, 0.4),
            0 0 40px rgba(16, 185, 129, 0.2),
            inset 0 0 20px rgba(16, 185, 129, 0.1)
          `;
          svgPlus.style.filter = 'drop-shadow(0 0 8px rgba(16, 185, 129, 0.8))';
        });

        // Add click handler to open Emma chat for memory creation
        createElement.addEventListener('click', (e) => {
          e.stopPropagation();

          // Open Emma chat experience for intelligent memory creation
          this.startEmmaChatExperience();
        });

        // 🔍 ZOOM FIX: Add to constellation container instead of body
        const targetContainer = this.constellationContainer || document.body;
        targetContainer.appendChild(createElement);

        // Animate in
        setTimeout(() => {
          createElement.style.transform = 'scale(1)';
          createElement.style.opacity = '1';
        }, 100);

        return createElement;
      }

      // Open Emma memory creation wizard (proper capture wizard)
      openEmmaMemoryWizard() {

        // CRITICAL FIX: Debug and ensure AssistantExperience is available

        console.log('🧠 DEBUG: Available window objects:', Object.keys(window).filter(k => k.includes('Assistant') || k.includes('Experience')));

        try {
          // Wait a moment for scripts to load, then check again
          setTimeout(() => {

            if (window.AssistantExperience) {

              // Create and show the full assistant experience popup
              const assistantInstance = new window.AssistantExperience(
                { x: window.innerWidth / 2, y: window.innerHeight / 2 },
                { showCloseButton: true }
              );
              // Show the full popup - this will open with the voice wizard tab active
              assistantInstance.show();
              // Store reference for global access
              window.assistantInstance = assistantInstance;
            } else {
              console.error('🧠 AssistantExperience STILL not available after delay!');
              console.log('🧠 Available classes:', Object.keys(window).filter(k => k.endsWith('Experience')));
              this.showToast('❌ Emma Assistant not loaded', 'error');
            }
          }, 100);

        } catch (error) {
          console.error('Failed to open Emma memory wizard:', error);
          this.showToast('❌ Failed to open memory wizard', 'error');
        }
      }

      // Fallback voice memory wizard
      openVoiceMemoryWizard() {
        console.log('🧠 Opening voice memory wizard (fallback)');

        // Create a voice memory wizard modal similar to AssistantExperience
        const modalHTML = `
          <div class="voice-wizard-modal" style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(25px) saturate(180%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
          ">
            <div class="voice-wizard-content" style="
              /* 🎨 EMMA GLASSMORPHISM: Match chat interface aesthetic */
              background: rgba(26, 16, 51, 0.92);
              backdrop-filter: blur(25px) saturate(150%);
              border-radius: 20px;
              padding: 40px;
              width: 90%;
              max-width: 600px;
              border: 1px solid rgba(255, 255, 255, 0.12);
              box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.12);
              color: white;
              text-align: center;
            ">
              <div class="emma-section">
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px; margin-bottom: 8px;">EMMA ASKS</div>
                <h1 style="margin: 0 0 24px 0; font-size: 28px; font-weight: 700;">
                  What's your favorite memory with Mom? Take your time, I'm listening.
                </h1>
                <div class="suggestions" style="margin-bottom: 32px; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                  <button class="suggestion-chip" style="
                    padding: 8px 16px;
                    background: rgba(255, 255, 255, 0.2);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    border-radius: 20px;
                    color: white;
                    font-size: 14px;
                    cursor: pointer;
                  ">Holiday traditions</button>
                  <button class="suggestion-chip" style="
                    padding: 8px 16px;
                    background: rgba(255, 255, 255, 0.2);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    border-radius: 20px;
                    color: white;
                    font-size: 14px;
                    cursor: pointer;
                  ">Her wisdom</button>
                  <button class="suggestion-chip" style="
                    padding: 8px 16px;
                    background: rgba(255, 255, 255, 0.2);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    border-radius: 20px;
                    color: white;
                    font-size: 14px;
                    cursor: pointer;
                  ">Family meals</button>
                </div>
              </div>

              <div class="voice-capture" style="margin-bottom: 32px;">
                <div class="voice-button-container" style="margin-bottom: 16px;">
                  <button class="voice-button" style="
                    width: 80px;
                    height: 80px;
                    border-radius: 50%;
                    background: rgba(255, 255, 255, 0.2);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    color: white;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto;
                  ">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                      <line x1="12" x2="12" y1="19" y2="22"/>
                      <line x1="8" x2="16" y1="22" y2="22"/>
                    </svg>
                  </button>
                </div>
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px;">Tap to start recording</div>
              </div>

              <div class="transcription" style="margin-bottom: 32px;">
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px; margin-bottom: 8px;">YOUR STORY</div>
                <div style="
                  background: rgba(255, 255, 255, 0.1);
                  border-radius: 12px;
                  padding: 20px;
                  min-height: 80px;
                  font-style: italic;
                  color: rgba(255, 255, 255, 0.6);
                ">Your words will appear here as you speak...</div>
              </div>

              <div style="margin-bottom: 24px;">
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px; margin-bottom: 8px;">1 of 5 questions</div>
                <div style="
                  width: 100%;
                  height: 4px;
                  background: rgba(255, 255, 255, 0.2);
                  border-radius: 2px;
                  overflow: hidden;
                ">
                  <div style="
                    width: 20%;
                    height: 100%;
                    background: linear-gradient(90deg, #ffffff, rgba(255, 255, 255, 0.8));
                    border-radius: 2px;
                  "></div>
                </div>
              </div>

              <div style="display: flex; gap: 12px; justify-content: center;">
                <button class="skip-btn" style="
                  padding: 14px 28px;
                  border: 2px solid rgba(255, 255, 255, 0.3);
                  background: rgba(255, 255, 255, 0.1);
                  color: white;
                  border-radius: 10px;
                  cursor: pointer;
                  font-size: 14px;
                  font-weight: 500;
                ">Skip</button>
                <button class="continue-btn" style="
                  padding: 14px 28px;
                  border: none;
                  background: rgba(255, 255, 255, 0.9);
                  color: #6b46c1;
                  border-radius: 10px;
                  cursor: pointer;
                  font-size: 14px;
                  font-weight: 600;
                ">Continue →</button>
              </div>
            </div>
          </div>
        `;

        // Create and show modal - SECURITY FIX: Use safe DOM creation
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = 'vault-migration-modal';
        modal.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(25px) saturate(180%); z-index: 10000; align-items: center; justify-content: center;';

        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        modalContent.style.cssText = 'background: rgba(26, 16, 51, 0.92); backdrop-filter: blur(25px) saturate(150%); border: 1px solid rgba(255, 255, 255, 0.12); box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.12); padding: 40px; border-radius: 20px; max-width: 500px; text-align: center;';

        const title = document.createElement('h2');
        title.textContent = '🔄 Vault Migration Available';
        title.style.cssText = 'color: white; margin-bottom: 20px; font-size: 24px;';

        const description = document.createElement('p');
        description.textContent = 'A new vault storage system is available with enhanced security and performance. Would you like to migrate your existing vault?';
        description.style.cssText = 'color: rgba(255, 255, 255, 0.8); margin-bottom: 30px; line-height: 1.6;';

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 15px; justify-content: center;';

        const skipBtn = document.createElement('button');
        skipBtn.className = 'skip-btn';
        skipBtn.textContent = 'Skip for Now';
        skipBtn.style.cssText = 'padding: 12px 24px; background: rgba(255, 255, 255, 0.1); color: white; border: none; border-radius: 8px; cursor: pointer;';

        const continueBtn = document.createElement('button');
        continueBtn.className = 'continue-btn';
        continueBtn.textContent = 'Migrate Vault';
        continueBtn.style.cssText = 'padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); color: white; border: none; border-radius: 8px; cursor: pointer;';

        buttonContainer.appendChild(skipBtn);
        buttonContainer.appendChild(continueBtn);
        modalContent.appendChild(title);
        modalContent.appendChild(description);
        modalContent.appendChild(buttonContainer);
        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // Add event listeners
        const skipBtnQuery = modal.querySelector('.skip-btn');
        const continueBtnQuery = modal.querySelector('.continue-btn');

        skipBtnQuery.addEventListener('click', () => modal.remove());
        continueBtnQuery.addEventListener('click', () => {
          // For now, just show a message and close
          this.showToast('🎤 Voice wizard coming soon!', 'info');
          modal.remove();
        });

        // Close on outside click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove();
          }
        });
      }

      // Open memory capsule dialog (reuses existing memory dialog system)
      openMemoryCapsuleDialog(memory) {

        this.openMemoryDialog(memory);
      }

      // Create neural branches from central Emma neuron
      createNeuralBranches(memories) {

        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;

        // First layer - primary neurons directly connected to Emma
        const primaryCount = Math.min(8, memories.length); // Max 8 primary branches
        const primaryAngleStep = (Math.PI * 2) / primaryCount;
        const primaryRadius = 200;

        // Create primary neurons
        const primaryNeurons = [];
        for (let i = 0; i < primaryCount; i++) {
          const angle = i * primaryAngleStep - Math.PI / 2;
          const x = centerX + Math.cos(angle) * primaryRadius;
          const y = centerY + Math.sin(angle) * primaryRadius;

          if (memories[i]) {
            const neuron = this.createMemoryNode(memories[i], x, y, memories[i].theme);
            neuron.isPrimary = true;
            neuron.connections.push(this.centralNeuron);
            this.centralNeuron.connections.push(neuron);
            primaryNeurons.push(neuron);
            this.nodes.push(neuron);
          }
        }

        // Create secondary and tertiary neurons branching from primaries
        let memoryIndex = primaryCount;
        primaryNeurons.forEach((primaryNeuron, primaryIndex) => {
          // Calculate how many secondary neurons this primary should have
          const remainingMemories = memories.length - memoryIndex;
          const remainingPrimaries = primaryCount - primaryIndex;
          const secondaryCount = Math.ceil(remainingMemories / remainingPrimaries);

          // Create secondary neurons
          for (let j = 0; j < secondaryCount && memoryIndex < memories.length; j++) {
            const memory = memories[memoryIndex++];

            // Position secondary neurons in an arc around the primary
            const secondaryAngle = primaryIndex * primaryAngleStep +
              (j - secondaryCount/2) * (Math.PI / 6) / secondaryCount;
            const secondaryRadius = 120 + Math.random() * 60;

            const x = primaryNeuron.x + Math.cos(secondaryAngle) * secondaryRadius;
            const y = primaryNeuron.y + Math.sin(secondaryAngle) * secondaryRadius;

            // Ensure within bounds
            const padding = 100;
            const finalX = Math.max(padding, Math.min(window.innerWidth - padding, x));
            const finalY = Math.max(padding, Math.min(window.innerHeight - padding, y));

            const secondaryNeuron = this.createMemoryNode(memory, finalX, finalY, memory.theme);
            secondaryNeuron.isSecondary = true;
            secondaryNeuron.connections.push(primaryNeuron);
            primaryNeuron.connections.push(secondaryNeuron);
            this.nodes.push(secondaryNeuron);
          }
        });

      }

      // Create individual memory node
      createMemoryNode(memory, x, y, theme) {
        console.log(`🌟 Creating memory node element for "${memory.title}" at (${x}, ${y})`);

        const memoryElement = document.createElement('div');
        memoryElement.className = 'memory-node';

        // SECURITY FIX: Use safe DOM creation instead of innerHTML
        const thumbnail = document.createElement('div');
        thumbnail.className = 'memory-thumbnail';
        thumbnail.textContent = memory.thumbnail; // Safe text content

        const label = document.createElement('div');
        label.className = 'memory-label';
        label.textContent = memory.title; // Safe text content

        memoryElement.appendChild(thumbnail);
        memoryElement.appendChild(label);

        // Add theme data attribute for styling
        memoryElement.setAttribute('data-theme', theme);

        // Style the memory node
        memoryElement.style.cssText = `
          position: fixed;
          left: ${x}px;
          top: ${y}px;
          width: 70px;
          height: 70px;
          border-radius: 50%;
          background: radial-gradient(circle, rgba(255, 255, 255, 0.1), rgba(134, 88, 255, 0.2));
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          transform: scale(0);
          opacity: 0;
          z-index: 1000;
          color: white;
        `;

        // Add click handler for elegant memory dialog
        memoryElement.addEventListener('click', (e) => {
          e.stopPropagation();
          this.openMemoryDialog(memory);
        });

        // Add hover effects with theme-based glow
        memoryElement.addEventListener('mouseenter', () => {
          const themeColors = {
            family: 'rgba(255, 105, 135, 0.8)',
            travel: 'rgba(52, 211, 153, 0.8)',
            recent: 'rgba(96, 165, 250, 0.8)',
            special: 'rgba(251, 191, 36, 0.8)'
          };

          memoryElement.style.transform = 'scale(1.3)';
          memoryElement.style.boxShadow = `0 0 60px ${themeColors[theme] || 'rgba(134, 88, 255, 0.8)'}, 0 0 100px ${themeColors[theme] || 'rgba(134, 88, 255, 0.4)'}`;
          memoryElement.style.zIndex = '1600'; /* CRITICAL FIX: Even higher on hover to stay above everything */
        });

        memoryElement.addEventListener('mouseleave', () => {
          memoryElement.style.transform = 'scale(1)';
          memoryElement.style.boxShadow = '';
          memoryElement.style.zIndex = '1500'; /* CRITICAL FIX: Maintain high z-index even when not hovering */
        });

        // 🔍 ZOOM FIX: Add to constellation container for proper zoom behavior
        const targetContainer = this.constellationContainer || document.querySelector('.dashboard') || document.body;
        targetContainer.appendChild(memoryElement);

        // Animate in with staggered timing
        const delay = Math.random() * 500 + 200; // 200-700ms delay
        setTimeout(() => {

          memoryElement.style.transform = 'scale(1)';
          memoryElement.style.opacity = '1';
        }, delay);

        return {
          element: memoryElement,
          x: x,
          y: y,
          baseX: x,
          baseY: y,
          vx: 0,
          vy: 0,
          memory: memory,
          theme: theme,
          connections: []
        };
      }

      // Create person node element for constellation with heartbeat effect
      createPersonNodeElement(person, x, y) {
        const personElement = document.createElement('div');
        personElement.className = 'person-node';

        // Create person avatar with first letter of name
        const avatar = person.name.charAt(0).toUpperCase();
        const relationColor = this.getRelationColor(person.relation);

        // Create BIGGER avatar circle with subtle heartbeat glow - NO TEXT LABELS
        personElement.style.cssText = `
          position: absolute;
          left: ${x}px;
          top: ${y}px;
          width: 85px;
          height: 85px;
          border-radius: 50%;
          background: ${relationColor.gradient};
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-weight: 700;
          font-size: 28px;
          border: 3px solid ${relationColor.border};
          box-shadow: 
            0 8px 32px ${relationColor.glow},
            0 0 20px rgba(239, 68, 68, 0.3),
            0 0 40px rgba(239, 68, 68, 0.1);
          overflow: hidden;
          cursor: pointer;
          transform: scale(0);
          opacity: 0;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          animation: heartbeat 4s ease-in-out infinite;
          z-index: 1500; /* CRITICAL FIX: Higher z-index to appear above all connections */
          pointer-events: auto; /* CRITICAL: Ensure person nodes are clickable even with container pointer-events: none */
        `;

        // Start with letter, then try to load avatar image
        personElement.textContent = avatar;

        // Try to load actual avatar image if person has one
        if (person.avatarId) {
          this.loadPersonAvatar(person, personElement, avatar);
        }

        // Add click handler to open person summary modal
        personElement.addEventListener('click', (e) => {
          e.stopPropagation();
          this.openPersonSummaryModal(person);
        });

        // Add hover effects with relation-based glow
        personElement.addEventListener('mouseenter', () => {
          personElement.style.transform = 'scale(1.2)';
          personElement.style.boxShadow = `0 0 40px ${relationColor.glow}, 0 0 80px ${relationColor.glow}`;
          personElement.style.zIndex = '1600'; /* CRITICAL FIX: Even higher on hover to stay above everything */
        });

        personElement.addEventListener('mouseleave', () => {
          personElement.style.transform = 'scale(1)';
          personElement.style.boxShadow = '';
          personElement.style.zIndex = '1500'; /* CRITICAL FIX: Maintain high z-index even when not hovering */
        });

        // 🔗 CRITICAL FIX: Append to constellation container for zoom/pan anchoring
        if (this.constellationContainer) {
          this.constellationContainer.appendChild(personElement);
        } else {
          const container = document.querySelector('.dashboard') || document.body;
          container.appendChild(personElement);
        }

        // Animate in with staggered timing
        const delay = Math.random() * 500 + 300; // 300-800ms delay
        setTimeout(() => {

          personElement.style.transform = 'scale(1)';
          personElement.style.opacity = '1';
        }, delay);

        return personElement;
      }

      // Load actual avatar image for person node
      async loadPersonAvatar(person, personElement, fallbackLetter) {
        try {

          // FIXED: Use avatarUrl directly from extension (already reconstructed)
          if (person.avatarUrl) {
            // Create image element
            const img = document.createElement('img');
            img.src = person.avatarUrl;
            img.alt = `${person.name} avatar`;
            img.style.cssText = `
              width: 100%;
              height: 100%;
              object-fit: cover;
              border-radius: 50%;
            `;

            img.onload = () => {
              // Replace letter with image once loaded
              personElement.innerHTML = '';
              personElement.appendChild(img);

            };

            img.onerror = () => {
              console.error('📷 CONSTELLATION: Failed to display avatar for:', person.name);
              // Keep the letter fallback
            };
          } else {
            console.warn('📷 CONSTELLATION: No avatar URL for:', person.name);
          }
        } catch (error) {
          console.error('📷 CONSTELLATION: Error loading avatar for:', person.name, error);
          // Keep the letter fallback
        }
      }

      // Open revolutionary migration page
      openMigrationPage() {

        window.location.href = 'pages/vault-migration.html';
      }

      // Open person summary modal with connected memories
      async openPersonSummaryModal(person) {

        // 🎯 FIXED: Use same memory loading approach as people-emma.html
        let connectedMemories = [];
        try {
          if (!window.emmaWebVault || !window.emmaWebVault.vaultData?.content) {
            console.error('❌ CONSTELLATION: Vault data not available');
            return;
          }

          const vaultData = window.emmaWebVault.vaultData;
          const allMemories = vaultData.content.memories || {};

          // Find memories that include this person - SAME LOGIC AS PEOPLE-EMMA.HTML
          for (const [memoryId, memory] of Object.entries(allMemories)) {
            // Check if person is in memory's people metadata
            if (memory.metadata && memory.metadata.people && 
                Array.isArray(memory.metadata.people) && 
                memory.metadata.people.includes(person.id)) {
              connectedMemories.push(memory);
            }
            
            // Also check if person's name is mentioned in content
            if (memory.content) {
              const personName = person.name.toLowerCase();
              const memoryContent = memory.content.toLowerCase();
              if (memoryContent.includes(personName)) {
                // Avoid duplicates
                if (!connectedMemories.find(m => m.id === memory.id)) {
                  connectedMemories.push(memory);
                }
              }
            }
          }

          console.log(`🔗 CONSTELLATION: Found ${connectedMemories.length} memories for person ${person.id}`);

        } catch (error) {
          console.error('❌ CONSTELLATION: Error loading memories:', error);
        }

        // Create modal HTML
        const modalHTML = `
          <div class="person-summary-modal-overlay" id="person-summary-overlay" onclick="window.memoryConstellation.closePersonSummaryModal()">
            <div class="person-summary-modal" onclick="event.stopPropagation()">
              <button class="modal-close" onclick="window.memoryConstellation.closePersonSummaryModal()">×</button>

              <div class="person-summary-header">
                <div class="person-summary-avatar" id="person-summary-avatar">
                  ${person.name.charAt(0).toUpperCase()}
                </div>
                <div class="person-summary-info">
                  <h2 class="person-summary-name">${person.name}</h2>
                  <p class="person-summary-relation">${person.relation || 'other'}</p>
                  <p class="person-summary-contact">${person.contact || 'No contact info'}</p>
                </div>
              </div>

              <div class="person-summary-content">
                <h3 class="summary-section-title">Connected Memories</h3>
                <div class="connected-memories">
                  ${connectedMemories.length > 0 ?
                    connectedMemories.map(memory => {
                      // Get thumbnail from attachments or fallback
                      const thumbnail = memory.thumbnail ||
                                       (memory.attachments && memory.attachments.length > 0 && memory.attachments[0].url ? memory.attachments[0].url : null);
                      const memoryTitle = memory.metadata?.title || memory.title || memory.subject || 'Untitled Memory';
                      const memoryDate = memory.created || memory.date || memory.timestamp;

                      return `
                        <div class="connected-memory-item" onclick="window.memoryConstellation.openMemoryFromPerson('${memory.id}')">
                          <div class="memory-preview">
                            ${thumbnail ? `<img src="${thumbnail}" alt="Memory">` : '💝'}
                          </div>
                          <div class="memory-info">
                            <div class="memory-title">${memoryTitle}</div>
                            <div class="memory-date">${memoryDate ? new Date(memoryDate).toLocaleDateString() : 'Unknown date'}</div>
                          </div>
                        </div>
                      `;
                    }).join('') :
                    '<div class="no-memories">No connected memories yet</div>'
                  }
                </div>

                <div class="person-summary-actions">
                  <button class="btn btn-primary" onclick="window.memoryConstellation.createMemoryWithPersonFromConstellation('${person.id}')">
                    <span>✨</span>
                    Create Memory Together
                  </button>
                  <button class="btn btn-secondary" onclick="window.location.href='pages/people-emma.html'">
                    <span>👥</span>
                    Manage People
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;

        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        // Make constellation functions globally accessible for modal
        window.memoryConstellation = this;

        // Load avatar if available - CRITICAL for showing person's image
        if (person.avatarUrl) {
          this.loadAvatarForSummary(person);
        } else {

        }

        // Show modal with animation
        setTimeout(() => {
          document.getElementById('person-summary-overlay').classList.add('active');
        }, 10);
      }

      async loadAvatarForSummary(person) {
        try {

          // FIXED: Use avatarUrl directly (same as constellation nodes and people page)
          if (person.avatarUrl) {
            const avatarElement = document.getElementById('person-summary-avatar');
            if (avatarElement) {

              avatarElement.innerHTML = `<img src="${person.avatarUrl}" alt="${person.name}" style="
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 50%;
              ">`;

            } else {
              console.error('📷 SUMMARY: Avatar element not found in DOM');
            }
          } else {
            console.warn('📷 SUMMARY: No avatarUrl available for:', person.name);
          }
        } catch (error) {
          console.error('📷 SUMMARY: Error loading avatar for:', person.name, error);
        }
      }

      closePersonSummaryModal() {
        const overlay = document.getElementById('person-summary-overlay');
        if (overlay) {
          overlay.classList.remove('active');
          setTimeout(() => overlay.remove(), 300);
        }
      }

      createMemoryWithPersonFromConstellation(personId) {
        this.closePersonSummaryModal();
        window.location.href = `dashboard-new.html?createMemory=true&person=${personId}`;
      }

      async openMemoryFromPerson(memoryId) {

        this.closePersonSummaryModal();

        // Find the memory in our loaded memories
        try {
          let allMemories = [];
          if (window.emmaWebVault && window.emmaWebVault.extensionAvailable) {
            allMemories = await window.emmaWebVault.listMemories(1000);
          }

          const memory = allMemories.find(m => m.id === memoryId);
          if (memory) {
            this.openMemoryDialog(memory);
          } else {
            console.error('💝 Memory not found:', memoryId);
            this.showToast('❌ Memory not found', 'error');
          }
        } catch (error) {
          console.error('💝 Error opening memory from person:', error);
          this.showToast('❌ Error opening memory', 'error');
        }
      }

      // Get relation-specific colors for people nodes
      getRelationColor(relation) {
        const colors = {
          family: {
            gradient: 'linear-gradient(135deg, #ef4444, #f87171)',
            border: 'rgba(239, 68, 68, 0.6)',
            glow: 'rgba(239, 68, 68, 0.8)'
          },
          friend: {
            gradient: 'linear-gradient(135deg, #3b82f6, #60a5fa)',
            border: 'rgba(59, 130, 246, 0.6)',
            glow: 'rgba(59, 130, 246, 0.8)'
          },
          colleague: {
            gradient: 'linear-gradient(135deg, #10b981, #34d399)',
            border: 'rgba(16, 185, 129, 0.6)',
            glow: 'rgba(16, 185, 129, 0.8)'
          },
          romantic: {
            gradient: 'linear-gradient(135deg, #ec4899, #f472b6)',
            border: 'rgba(236, 72, 153, 0.6)',
            glow: 'rgba(236, 72, 153, 0.8)'
          }
        };

        return colors[relation] || colors.friend; // Default to friend colors
      }

      // Open person dialog (placeholder)
      openPersonDialog(person) {

        this.showToast(`👥 ${person.name} (${person.relation})`, 'info');
      }

      // Create intelligent connections between memory nodes and people nodes
      createMemoryPeopleConnections(memories, people) {

        const memoryNodes = this.nodes.filter(node => node.type === 'memory');
        const peopleNodes = this.nodes.filter(node => node.type === 'person');

        // For each memory, connect to people who were involved
        memoryNodes.forEach(memoryNode => {
          const memory = memoryNode.memory;

          // Check if memory has people data (from wizard selections or manual input)
          if (memory.selectedPeople && Array.isArray(memory.selectedPeople)) {
            // Connect to people selected in wizard
            memory.selectedPeople.forEach(personId => {
              const personNode = peopleNodes.find(pNode => pNode.person.id === personId);
              if (personNode && !memoryNode.connections.includes(personNode)) {
                memoryNode.connections.push(personNode);
                personNode.connections.push(memoryNode);

              }
            });
          }

          // Also check if people are mentioned in memory content/responses
          const memoryText = (memory.content || '').toLowerCase() + ' ' +
                            (memory.responses || []).join(' ').toLowerCase();

          peopleNodes.forEach(personNode => {
            const personName = personNode.person.name.toLowerCase();

            // If person's name is mentioned in the memory text, create connection
            if (memoryText.includes(personName) && !memoryNode.connections.includes(personNode)) {
              memoryNode.connections.push(personNode);
              personNode.connections.push(memoryNode);
              console.log(`🔗 Auto-connected memory "${memory.title}" to person "${personNode.person.name}" (name mentioned)`);
            }
          });
        });

        // Create some random connections for people who aren't connected to anything
        peopleNodes.forEach(personNode => {
          if (personNode.connections.length === 0) {
            // Connect to the closest memory node
            let closestMemory = null;
            let closestDistance = Infinity;

            memoryNodes.forEach(memoryNode => {
              const dx = personNode.x - memoryNode.x;
              const dy = personNode.y - memoryNode.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < closestDistance && memoryNode.connections.length < 3) {
                closestDistance = distance;
                closestMemory = memoryNode;
              }
            });

            if (closestMemory) {
              personNode.connections.push(closestMemory);
              closestMemory.connections.push(personNode);

            }
          }
        });

      }      // Update neural network node positions with overlap prevention
      updateConstellationNodes() {
        const time = Date.now() * 0.001;

        // Update all memory nodes
        this.nodes.forEach((node, i) => {
          // Reset forces
          let forceX = 0;
          let forceY = 0;

          // Repulsion from other nodes to prevent overlap
          this.nodes.forEach((otherNode, j) => {
            if (i !== j) {
              const dx = node.x - otherNode.x;
              const dy = node.y - otherNode.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              const minDistance = node.isPrimary || otherNode.isPrimary ? 150 : 120;
              if (distance < minDistance) {
                const force = (minDistance - distance) / distance * 0.3;
                forceX += dx * force;
                forceY += dy * force;
              }
            }
          });

          // Also repel from central neuron
          if (this.centralNeuron) {
            const dx = node.x - this.centralNeuron.x;
            const dy = node.y - this.centralNeuron.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 150) {
              const force = (150 - distance) / distance * 0.4;
              forceX += dx * force;
              forceY += dy * force;
            }
          }

          // Gentle attraction to base position
          const baseAttraction = node.isPrimary ? 0.03 : 0.02;
          forceX += (node.baseX - node.x) * baseAttraction;
          forceY += (node.baseY - node.y) * baseAttraction;

          // Subtle floating motion - less for primary nodes
          const floatAmplitude = node.isPrimary ? 1.5 : 2.5;
          const floatX = Math.sin(time * 0.15 + i * 0.7) * floatAmplitude;
          const floatY = Math.cos(time * 0.12 + i * 0.5) * floatAmplitude;

          // Apply forces
          node.vx = (node.vx + forceX) * 0.92; // Damping
          node.vy = (node.vy + forceY) * 0.92;

          // Update position
          node.x += node.vx + floatX * 0.4;
          node.y += node.vy + floatY * 0.4;

          // Keep within bounds
          const padding = 80;
          node.x = Math.max(padding, Math.min(window.innerWidth - padding, node.x));
          node.y = Math.max(padding, Math.min(window.innerHeight - padding, node.y));

          // Update DOM position
          if (node.element) {
            node.element.style.left = node.x + 'px';
            node.element.style.top = node.y + 'px';
          }
        });

        // The central neuron (Emma orb) stays fixed at center
        if (this.centralNeuron) {
          this.centralNeuron.x = window.innerWidth / 2;
          this.centralNeuron.y = window.innerHeight / 2;
        }
      }

      // Show elegant constellation burger menu
      showConstellationUI() {
        // Initialize constellation filters state
        this.constellationFilters = {
          memories: true,
          people: true,
          family: true,
          travel: true,
          recent: true,
          special: true
        };

        // Create elegant burger menu
        const burgerMenu = document.createElement('div');
        burgerMenu.className = 'constellation-burger-menu';
        burgerMenu.innerHTML = `
          <!-- Burger Button -->
          <button class="constellation-burger-btn" id="constellationBurger">
            <div class="burger-lines">
              <span></span>
              <span></span>
              <span></span>
          </div>
            <div class="burger-label">Filters</div>
          </button>

          <!-- Expandable Menu Panel -->
          <div class="constellation-menu-panel" id="constellationPanel">
            <div class="panel-header">
              <h3>🌟 Constellation Filters</h3>
              <button class="panel-close" onclick="dashboard.exitMemoryConstellation()">✕</button>
            </div>

            <div class="filter-section">
              <h4>Node Types</h4>
              <div class="filter-toggles">
                <label class="filter-toggle">
                  <input type="checkbox" id="filter-memories" checked>
                  <span class="toggle-slider"></span>
                  <span class="toggle-label">💝 Memories</span>
                  <span class="toggle-count" id="count-memories">0</span>
                </label>

                <label class="filter-toggle">
                  <input type="checkbox" id="filter-people" checked>
                  <span class="toggle-slider"></span>
                  <span class="toggle-label">👤 People</span>
                  <span class="toggle-count" id="count-people">0</span>
                </label>
              </div>
            </div>

            <div class="filter-section">
              <h4>Memory Themes</h4>
              <div class="filter-toggles">
                <label class="filter-toggle">
                  <input type="checkbox" id="filter-family" checked>
                  <span class="toggle-slider family"></span>
                  <span class="toggle-label">👨‍👩‍👧‍👦 Family</span>
                  <span class="toggle-count" id="count-family">0</span>
                </label>

                <label class="filter-toggle">
                  <input type="checkbox" id="filter-travel" checked>
                  <span class="toggle-slider travel"></span>
                  <span class="toggle-label">✈️ Travel</span>
                  <span class="toggle-count" id="count-travel">0</span>
                </label>

                <label class="filter-toggle">
                  <input type="checkbox" id="filter-recent" checked>
                  <span class="toggle-slider recent"></span>
                  <span class="toggle-label">🕒 Recent</span>
                  <span class="toggle-count" id="count-recent">0</span>
                </label>

                <label class="filter-toggle">
                  <input type="checkbox" id="filter-special" checked>
                  <span class="toggle-slider special"></span>
                  <span class="toggle-label">⭐ Special</span>
                  <span class="toggle-count" id="count-special">0</span>
                </label>
              </div>
            </div>

            <div class="filter-actions">
              <button class="filter-btn secondary" id="reset-filters-btn">
                Reset All
              </button>
              <button class="filter-btn primary" id="apply-filters-btn">
                Apply Filters
              </button>
            </div>
          </div>
        `;

        // Add elegant styles
        const styles = document.createElement('style');
        styles.textContent = `
          .constellation-burger-menu {
          position: fixed;
          top: 20px;
          left: 20px;
            z-index: 2000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          }

          .constellation-burger-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: rgba(17, 17, 27, 0.95);
            border: 1px solid rgba(134, 88, 255, 0.4);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(134, 88, 255, 0.15);
          }

          .constellation-burger-btn:hover {
            background: rgba(134, 88, 255, 0.1);
            border-color: rgba(134, 88, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(134, 88, 255, 0.25);
          }

          .burger-lines {
            display: flex;
            flex-direction: column;
            gap: 3px;
          }

          .burger-lines span {
            width: 18px;
            height: 2px;
            background: rgba(134, 88, 255, 0.8);
            border-radius: 1px;
            transition: all 0.3s ease;
          }

          .constellation-burger-btn:hover .burger-lines span {
            background: rgba(134, 88, 255, 1);
          }

          .burger-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
          }

          .constellation-menu-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            background: rgba(17, 17, 27, 0.98);
          border: 1px solid rgba(134, 88, 255, 0.3);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            transform: translateX(-100%) scale(0.95);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
          }

          .constellation-menu-panel.active {
            transform: translateX(0) scale(1);
            opacity: 1;
            visibility: visible;
          }

          .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px 16px;
            border-bottom: 1px solid rgba(134, 88, 255, 0.2);
          }

          .panel-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: white;
          }

          .panel-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            transition: all 0.2s ease;
          }

          .panel-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
          }

          .filter-section {
            padding: 20px 24px;
            border-bottom: 1px solid rgba(134, 88, 255, 0.1);
          }

          .filter-section:last-of-type {
            border-bottom: none;
          }

          .filter-section h4 {
            margin: 0 0 16px 0;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
          }

          .filter-toggles {
            display: flex;
            flex-direction: column;
            gap: 12px;
          }

          .filter-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 8px 0;
            transition: all 0.2s ease;
          }

          .filter-toggle:hover {
            background: rgba(134, 88, 255, 0.05);
            border-radius: 8px;
            padding: 8px 8px;
            margin: 0 -8px;
          }

          .filter-toggle input[type="checkbox"] {
            display: none;
          }

          .toggle-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            transition: all 0.3s ease;
            flex-shrink: 0;
          }

          .toggle-slider:before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
          }

          .filter-toggle input:checked + .toggle-slider {
            background: rgba(134, 88, 255, 0.8);
          }

          .filter-toggle input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background: white;
          }

          /* Theme-specific toggle colors */
          .toggle-slider.family:before { background: rgba(255, 105, 135, 0.1); }
          .filter-toggle input:checked + .toggle-slider.family { background: rgba(255, 105, 135, 0.8); }

          .toggle-slider.travel:before { background: rgba(52, 211, 153, 0.1); }
          .filter-toggle input:checked + .toggle-slider.travel { background: rgba(52, 211, 153, 0.8); }

          .toggle-slider.recent:before { background: rgba(96, 165, 250, 0.1); }
          .filter-toggle input:checked + .toggle-slider.recent { background: rgba(96, 165, 250, 0.8); }

          .toggle-slider.special:before { background: rgba(251, 191, 36, 0.1); }
          .filter-toggle input:checked + .toggle-slider.special { background: rgba(251, 191, 36, 0.8); }

          .toggle-label {
            flex: 1;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
          }

          .toggle-count {
            background: rgba(134, 88, 255, 0.2);
            color: rgba(134, 88, 255, 1);
            padding: 2px 8px;
          border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
          }

          .filter-actions {
            padding: 20px 24px;
            display: flex;
            gap: 12px;
          }

          .filter-btn {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          }

          .filter-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
          }

          .filter-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
          }

          .filter-btn.primary {
            background: rgba(134, 88, 255, 0.8);
            color: white;
          }

          .filter-btn.primary:hover {
            background: rgba(134, 88, 255, 1);
            transform: translateY(-1px);
          }
        `;

        document.head.appendChild(styles);
        document.body.appendChild(burgerMenu);

        // Set up burger menu interactions
        this.setupConstellationMenu();

        // Update counts
        this.updateConstellationCounts();

        this.constellationUI = burgerMenu;
        
        // 🎯 NO CONTROLS NEEDED: Natural gestures (wheel zoom, drag pan, pinch) are intuitive
      }

      // Set up constellation menu interactions
      setupConstellationMenu() {
        const burgerBtn = document.getElementById('constellationBurger');
        const panel = document.getElementById('constellationPanel');

        // Toggle menu on burger click
        burgerBtn.addEventListener('click', () => {
          panel.classList.toggle('active');
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!burgerBtn.contains(e.target) && !panel.contains(e.target)) {
            panel.classList.remove('active');
          }
        });

        // Set up filter toggle event listeners
        const filterInputs = panel.querySelectorAll('input[type="checkbox"]');
        filterInputs.forEach(input => {
          input.addEventListener('change', (e) => {
            const filterType = e.target.id.replace('filter-', '');
            this.toggleConstellationFilter(filterType, e.target.checked);
          });
        });

        // Set up action button event listeners
        document.getElementById('reset-filters-btn').addEventListener('click', () => {
          this.resetConstellationFilters();
        });

        document.getElementById('apply-filters-btn').addEventListener('click', () => {
          this.hideConstellationMenu();
        });
      }

      // Toggle constellation filter and update display
      toggleConstellationFilter(filterType, enabled) {
        this.constellationFilters[filterType] = enabled;

        // Apply filters with smooth animation
        this.applyConstellationFilters();
      }

      // Apply constellation filters with smooth animations
      applyConstellationFilters() {
        const nodes = document.querySelectorAll('.memory-node, .person-node');

        nodes.forEach(node => {
          const nodeType = node.classList.contains('memory-node') ? 'memory' : 'person';
          const theme = node.dataset.theme || 'recent';

          let shouldShow = false;

          // Check if node type is enabled
          if (nodeType === 'memory' && this.constellationFilters.memories) {
            // Check if memory theme is enabled
            shouldShow = this.constellationFilters[theme];
          } else if (nodeType === 'person' && this.constellationFilters.people) {
            shouldShow = true;
          }

          // Smooth animation for show/hide
          if (shouldShow && node.style.display === 'none') {
            // Show with fade in
            node.style.display = 'block';
            node.style.opacity = '0';
            node.style.transform = 'scale(0.8)';

            requestAnimationFrame(() => {
              node.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
              node.style.opacity = '1';
              node.style.transform = 'scale(1)';
            });
          } else if (!shouldShow && node.style.display !== 'none') {
            // Hide with fade out
            node.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            node.style.opacity = '0';
            node.style.transform = 'scale(0.8)';

            setTimeout(() => {
              node.style.display = 'none';
            }, 300);
          }
        });

        // Neural connections now update automatically in animation loop based on node visibility
      }

      // Neural connections now handled automatically in main animation loop

      // Update constellation counts in the menu
      updateConstellationCounts() {
        // Count memories by theme
        const themeCounts = {
          family: 0,
          travel: 0,
          recent: 0,
          special: 0
        };

        Object.keys(this.constellationMemories || {}).forEach(theme => {
          themeCounts[theme] = (this.constellationMemories[theme] || []).length;
        });

        // Count people
        const peopleCount = this.constellationPeople ? this.constellationPeople.length : 0;
        const totalMemories = Object.values(themeCounts).reduce((sum, count) => sum + count, 0);

        // Update count displays
        const updateCount = (id, count) => {
          const element = document.getElementById(id);
          if (element) element.textContent = count;
        };

        updateCount('count-memories', totalMemories);
        updateCount('count-people', peopleCount);
        updateCount('count-family', themeCounts.family);
        updateCount('count-travel', themeCounts.travel);
        updateCount('count-recent', themeCounts.recent);
        updateCount('count-special', themeCounts.special);
      }

      // Reset all constellation filters
      resetConstellationFilters() {
        // Reset all filters to true
        this.constellationFilters = {
          memories: true,
          people: true,
          family: true,
          travel: true,
          recent: true,
          special: true
        };

        // Update checkboxes
        const checkboxes = document.querySelectorAll('#constellationPanel input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          checkbox.checked = true;
        });

        // Apply filters
        this.applyConstellationFilters();

      }

      // Hide constellation menu
      hideConstellationMenu() {
        const panel = document.getElementById('constellationPanel');
        if (panel) {
          panel.classList.remove('active');
        }
      }

      // 🔍 CREATE ZOOMABLE CONSTELLATION CONTAINER
      createConstellationContainer() {
        // Remove any existing constellation container
        const existingContainer = document.getElementById('constellation-zoom-container');
        if (existingContainer) {
          existingContainer.remove();
        }

        // Create zoomable container for constellation nodes
        this.constellationContainer = document.createElement('div');
        this.constellationContainer.id = 'constellation-zoom-container';
        this.constellationContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1400;
          transform-origin: center center;
          transition: transform 0.2s ease-out;
        `;
        
        // 🔧 CRITICAL FIX: Container doesn't block events, but child nodes can still be clicked
        // Child nodes will have pointer-events: auto set individually

        // Reset zoom state
        this.zoomState.scale = 1;
        this.zoomState.translateX = 0;
        this.zoomState.translateY = 0;

        // Add to dashboard
        document.body.appendChild(this.constellationContainer);

        // Enable zoom/pan interaction on the container
        this.setupConstellationZoom();

        console.log('🔍 ZOOM: Created constellation container with zoom functionality');
      }

      // 🔍 SETUP ZOOM AND PAN FUNCTIONALITY
      setupConstellationZoom() {
        // Enable pointer events for zoom interaction
        document.addEventListener('wheel', (e) => {
          if (this.isConstellationMode) {
            // 🚫 SMART SCROLL: Don't intercept wheel events over dialogs/modals/chat
            const isOverDialog = e.target.closest('.memory-preview-dialog') || 
                                e.target.closest('.person-summary-modal') ||
                                e.target.closest('.voice-wizard-modal') ||
                                e.target.closest('.modal-overlay') ||
                                e.target.closest('.responsive-memory-container') ||
                                
                                // 💬 CHAT WINDOW EXCLUSIONS
                                e.target.closest('.experience-popup') ||
                                e.target.closest('.chat-container') ||
                                e.target.closest('.message-container') ||
                                e.target.closest('.messages-container') ||
                                e.target.closest('.chat-messages') ||
                                e.target.closest('.emma-chat') ||
                                e.target.closest('[class*="chat"]') ||
                                e.target.closest('[class*="message"]') ||
                                e.target.closest('[class*="popup"]');
            
            if (!isOverDialog) {
              // Only zoom constellation when NOT scrolling in a dialog
              e.preventDefault();
              this.handleConstellationZoom(e);
            }
            // If over dialog, allow natural scrolling behavior
          }
        }, { passive: false });

        // 🎯 IMPROVED MOUSE DRAG PANNING - More responsive for Debbe
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragStartZoom = { ...this.zoomState };

        document.addEventListener('mousedown', (e) => {
          // 🚫 DISABLE CLICK-TO-PAN: Let users click nodes without drag interference
          // Only enable drag on the constellation container itself or document body
          if (this.isConstellationMode && 
              (e.target === this.constellationContainer || 
               e.target === document.body || 
               e.target.classList.contains('dashboard'))) {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            dragStartZoom = { ...this.zoomState };
            document.body.style.cursor = 'grabbing';
            e.preventDefault(); // Only prevent when starting drag on empty space
          }
        });

        document.addEventListener('mousemove', (e) => {
          if (isDragging && this.isConstellationMode) {
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            
            this.zoomState.translateX = dragStartZoom.translateX + deltaX;
            this.zoomState.translateY = dragStartZoom.translateY + deltaY;
            
            this.updateConstellationTransform();
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            document.body.style.cursor = '';
          }
        });

        // 📱 TOUCH GESTURES for tablets/phones
        let startTouches = [];
        let startZoomState = { ...this.zoomState };

        document.addEventListener('touchstart', (e) => {
          if (this.isConstellationMode) {
            startTouches = Array.from(e.touches);
            startZoomState = { ...this.zoomState };
          }
        });

        document.addEventListener('touchmove', (e) => {
          if (this.isConstellationMode && startTouches.length > 0) {
            e.preventDefault();
            this.handleConstellationTouchMove(e, startTouches, startZoomState);
          }
        }, { passive: false });

        document.addEventListener('touchend', () => {
          startTouches = [];
        });

        // ⌨️ KEYBOARD NAVIGATION for accessibility
        document.addEventListener('keydown', (e) => {
          if (this.isConstellationMode) {
            this.handleConstellationKeyboard(e);
          }
        });
      }

      // 📱 HANDLE TOUCH GESTURES (PINCH TO ZOOM + PAN)
      handleConstellationTouchMove(e, startTouches, startZoomState) {
        const currentTouches = Array.from(e.touches);

        if (currentTouches.length === 2 && startTouches.length === 2) {
          // Pinch to zoom
          const startDistance = Math.hypot(
            startTouches[0].clientX - startTouches[1].clientX,
            startTouches[0].clientY - startTouches[1].clientY
          );
          const currentDistance = Math.hypot(
            currentTouches[0].clientX - currentTouches[1].clientX,
            currentTouches[0].clientY - currentTouches[1].clientY
          );

          const scaleChange = currentDistance / startDistance;
          const newScale = Math.max(this.zoomState.minScale,
                           Math.min(this.zoomState.maxScale,
                           startZoomState.scale * scaleChange));

          // Zoom towards pinch center
          const centerX = (currentTouches[0].clientX + currentTouches[1].clientX) / 2;
          const centerY = (currentTouches[0].clientY + currentTouches[1].clientY) / 2;
          
          const scaleRatio = newScale / this.zoomState.scale;
          this.zoomState.translateX = centerX - (centerX - this.zoomState.translateX) * scaleRatio;
          this.zoomState.translateY = centerY - (centerY - this.zoomState.translateY) * scaleRatio;
          this.zoomState.scale = newScale;
          
          this.updateConstellationTransform();
        } else if (currentTouches.length === 1 && startTouches.length === 1) {
          // Single finger pan
          const deltaX = currentTouches[0].clientX - startTouches[0].clientX;
          const deltaY = currentTouches[0].clientY - startTouches[0].clientY;

          this.zoomState.translateX = startZoomState.translateX + deltaX;
          this.zoomState.translateY = startZoomState.translateY + deltaY;
          this.updateConstellationTransform();
        }
      }

      // ⌨️ KEYBOARD NAVIGATION for constellation
      handleConstellationKeyboard(e) {
        const panStep = 50; // Pixels to pan per key press
        const zoomStep = 0.05; // 🎯 GENTLE: 5% per key press instead of 10%

        switch(e.key) {
          case 'ArrowUp':
            e.preventDefault();
            this.zoomState.translateY += panStep;
            this.updateConstellationTransform();
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.zoomState.translateY -= panStep;
            this.updateConstellationTransform();
            break;
          case 'ArrowLeft':
            e.preventDefault();
            this.zoomState.translateX += panStep;
            this.updateConstellationTransform();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.zoomState.translateX -= panStep;
            this.updateConstellationTransform();
            break;
          case '+':
          case '=':
            e.preventDefault();
            this.zoomState.scale = Math.min(this.zoomState.maxScale, this.zoomState.scale * (1 + zoomStep));
            this.updateConstellationTransform();
            break;
          case '-':
            e.preventDefault();
            this.zoomState.scale = Math.max(this.zoomState.minScale, this.zoomState.scale * (1 - zoomStep));
            this.updateConstellationTransform();
            break;
          case '0':
            e.preventDefault();
            this.fitAllMemories();
            break;
        }
      }

      // 🔍 HANDLE MOUSE WHEEL ZOOM
      handleConstellationZoom(e) {
        // 🎯 GENTLE ZOOM: Much less aggressive (3% per scroll instead of 10%)
        const zoomFactor = e.deltaY > 0 ? 0.97 : 1.03;
        const newScale = Math.max(this.zoomState.minScale, 
                         Math.min(this.zoomState.maxScale, 
                         this.zoomState.scale * zoomFactor));

        // Zoom towards mouse position
        const mouseX = e.clientX;
        const mouseY = e.clientY;

        // Calculate offset to zoom towards mouse
        const scaleRatio = newScale / this.zoomState.scale;
        this.zoomState.translateX = mouseX - (mouseX - this.zoomState.translateX) * scaleRatio;
        this.zoomState.translateY = mouseY - (mouseY - this.zoomState.translateY) * scaleRatio;
        this.zoomState.scale = newScale;

        this.updateConstellationTransform();
      }

      // 🔍 UPDATE CONSTELLATION TRANSFORM
      updateConstellationTransform() {
        const transform = `translate(${this.zoomState.translateX}px, ${this.zoomState.translateY}px) scale(${this.zoomState.scale})`;
        
        // Apply transform to constellation container (memory nodes)
        if (this.constellationContainer) {
          this.constellationContainer.style.transform = transform;
        }
        
        // 💥 CRITICAL FIX: Apply same transform to neural canvas (connections)
        // This ensures connections stay anchored to nodes when zooming/panning
        if (this.neuralCanvas) {
          this.neuralCanvas.style.transform = transform;
          this.neuralCanvas.style.transformOrigin = 'center center';
        }
        
        console.log('🔗 TRANSFORM: Applied zoom/pan to both nodes and connections');
      }

      // 🔍 ADD ELEGANT EMMA-BRANDED ZOOM CONTROLS
      addConstellationZoomControls() {
        // Remove any existing zoom controls
        const existingControls = document.getElementById('constellation-zoom-controls');
        if (existingControls) {
          existingControls.remove();
        }

        // Create Emma-branded zoom controls container
        const zoomControls = document.createElement('div');
        zoomControls.id = 'constellation-zoom-controls';
        zoomControls.style.cssText = `
          position: fixed;
          bottom: 40px;
          right: 40px;
          display: flex;
          flex-direction: column;
          gap: 12px;
          z-index: 9999;
          opacity: 1;
          transition: all 0.3s ease;
        `;

        // Emma-branded button base style
        const buttonBaseStyle = `
          width: 56px;
          height: 56px;
          border-radius: 50%;
          border: 1px solid rgba(255, 255, 255, 0.15);
          background: linear-gradient(135deg, 
            rgba(139, 92, 246, 0.9) 0%, 
            rgba(124, 58, 237, 0.8) 50%,
            rgba(109, 40, 217, 0.9) 100%
          );
          backdrop-filter: blur(20px) saturate(150%);
          color: white;
          font-size: 18px;
          cursor: pointer;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 
            0 8px 32px rgba(139, 92, 246, 0.3),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          display: flex;
          align-items: center;
          justify-content: center;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-weight: 500;
          position: relative;
          overflow: hidden;
        `;

        // Zoom in button
        const zoomInBtn = document.createElement('button');
        zoomInBtn.innerHTML = '+';
        zoomInBtn.title = 'Zoom In to Explore';
        zoomInBtn.style.cssText = buttonBaseStyle;
        
        zoomInBtn.addEventListener('click', () => {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          // 🎯 GENTLE: 15% per button click instead of 30%
          const newScale = Math.min(this.zoomState.maxScale, this.zoomState.scale * 1.15);
          
          // Zoom towards center for smooth experience
          const scaleRatio = newScale / this.zoomState.scale;
          this.zoomState.translateX = centerX - (centerX - this.zoomState.translateX) * scaleRatio;
          this.zoomState.translateY = centerY - (centerY - this.zoomState.translateY) * scaleRatio;
          this.zoomState.scale = newScale;
          
          this.updateConstellationTransform();
        });

        // Zoom out button
        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.innerHTML = '−';
        zoomOutBtn.title = 'Zoom Out to See More';
        zoomOutBtn.style.cssText = buttonBaseStyle;
        
        zoomOutBtn.addEventListener('click', () => {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          // 🎯 GENTLE: 15% per button click instead of 30%
          const newScale = Math.max(this.zoomState.minScale, this.zoomState.scale / 1.15);
          
          // Zoom from center for smooth experience
          const scaleRatio = newScale / this.zoomState.scale;
          this.zoomState.translateX = centerX - (centerX - this.zoomState.translateX) * scaleRatio;
          this.zoomState.translateY = centerY - (centerY - this.zoomState.translateY) * scaleRatio;
          this.zoomState.scale = newScale;
          
          this.updateConstellationTransform();
        });

        // Fit all button - special Emma green
        const resetBtn = document.createElement('button');
        resetBtn.innerHTML = '⌂';
        resetBtn.title = 'Show All Memories';
        resetBtn.style.cssText = buttonBaseStyle.replace(
          'rgba(139, 92, 246, 0.9) 0%, rgba(124, 58, 237, 0.8) 50%, rgba(109, 40, 217, 0.9) 100%',
          'rgba(16, 185, 129, 0.9) 0%, rgba(5, 150, 105, 0.8) 50%, rgba(4, 120, 87, 0.9) 100%'
        ).replace(
          'rgba(139, 92, 246, 0.3)',
          'rgba(16, 185, 129, 0.3)'
        );
        
        resetBtn.addEventListener('click', () => {
          this.fitAllMemories();
        });

        // Add elegant hover effects
        [zoomInBtn, zoomOutBtn, resetBtn].forEach(btn => {
          btn.addEventListener('mouseenter', () => {
            btn.style.transform = 'scale(1.05) translateY(-2px)';
            btn.style.boxShadow = `
              0 12px 40px rgba(139, 92, 246, 0.4),
              0 0 0 1px rgba(255, 255, 255, 0.1),
              inset 0 1px 0 rgba(255, 255, 255, 0.2)
            `;
          });
          
          btn.addEventListener('mouseleave', () => {
            btn.style.transform = 'scale(1) translateY(0)';
            btn.style.boxShadow = `
              0 8px 32px rgba(139, 92, 246, 0.3),
              0 0 0 1px rgba(255, 255, 255, 0.05),
              inset 0 1px 0 rgba(255, 255, 255, 0.1)
            `;
          });

          // Add subtle click effect
          btn.addEventListener('mousedown', () => {
            btn.style.transform = 'scale(0.95)';
          });
          
          btn.addEventListener('mouseup', () => {
            btn.style.transform = 'scale(1.05) translateY(-2px)';
          });
        });

        zoomControls.appendChild(zoomInBtn);
        zoomControls.appendChild(zoomOutBtn);
        zoomControls.appendChild(resetBtn);
        document.body.appendChild(zoomControls);

        // 🧭 ADD NAVIGATION ARROWS for easy panning
        this.addConstellationPanControls();

        console.log('🎨 ZOOM: Added elegant Emma-branded zoom controls');
      }

      // 🧭 ADD DEMENTIA-FRIENDLY PAN CONTROLS
      addConstellationPanControls() {
        // Remove any existing pan controls
        const existingPanControls = document.getElementById('constellation-pan-controls');
        if (existingPanControls) {
          existingPanControls.remove();
        }

        // Create navigation controls container
        const panControls = document.createElement('div');
        panControls.id = 'constellation-pan-controls';
        panControls.style.cssText = `
          position: fixed;
          bottom: 40px;
          left: 40px;
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          grid-template-rows: 1fr 1fr 1fr;
          gap: 8px;
          z-index: 9999;
          opacity: 1;
          transition: all 0.3s ease;
          width: 144px;
          height: 144px;
        `;

        // Emma-branded button style for arrows
        const arrowButtonStyle = `
          width: 44px;
          height: 44px;
          border-radius: 50%;
          border: 1px solid rgba(255, 255, 255, 0.15);
          background: linear-gradient(135deg, 
            rgba(139, 92, 246, 0.85) 0%, 
            rgba(124, 58, 237, 0.75) 50%,
            rgba(109, 40, 217, 0.85) 100%
          );
          backdrop-filter: blur(20px) saturate(150%);
          color: white;
          font-size: 16px;
          cursor: pointer;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          box-shadow: 
            0 6px 24px rgba(139, 92, 246, 0.25),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          display: flex;
          align-items: center;
          justify-content: center;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-weight: 600;
        `;

        const panStep = 100; // Distance to pan in pixels

        // Create directional buttons in a 3x3 grid pattern
        const directions = [
          { pos: [0, 1], arrow: '↑', title: 'Pan Up', dx: 0, dy: panStep },
          { pos: [1, 0], arrow: '←', title: 'Pan Left', dx: panStep, dy: 0 },
          { pos: [1, 1], arrow: '⊕', title: 'Center View', dx: 0, dy: 0, special: 'center' },
          { pos: [1, 2], arrow: '→', title: 'Pan Right', dx: -panStep, dy: 0 },
          { pos: [2, 1], arrow: '↓', title: 'Pan Down', dx: 0, dy: -panStep }
        ];

        directions.forEach(({ pos, arrow, title, dx, dy, special }) => {
          const button = document.createElement('button');
          button.innerHTML = arrow;
          button.title = title;
          button.style.cssText = arrowButtonStyle;
          button.style.gridColumn = pos[1] + 1;
          button.style.gridRow = pos[0] + 1;

          // Special styling for center button
          if (special === 'center') {
            button.style.background = `linear-gradient(135deg, 
              rgba(16, 185, 129, 0.85) 0%, 
              rgba(5, 150, 105, 0.75) 50%,
              rgba(4, 120, 87, 0.85) 100%
            )`;
            button.style.boxShadow = `
              0 6px 24px rgba(16, 185, 129, 0.25),
              0 0 0 1px rgba(255, 255, 255, 0.05),
              inset 0 1px 0 rgba(255, 255, 255, 0.1)
            `;
          }

          button.addEventListener('click', () => {
            if (special === 'center') {
              // Center the view (reset translation)
              this.zoomState.translateX = 0;
              this.zoomState.translateY = 0;
            } else {
              // Pan in the specified direction
              this.zoomState.translateX += dx;
              this.zoomState.translateY += dy;
            }
            this.updateConstellationTransform();
          });

          // Add hover effects
          button.addEventListener('mouseenter', () => {
            button.style.transform = 'scale(1.05)';
            if (special === 'center') {
              button.style.boxShadow = `
                0 8px 32px rgba(16, 185, 129, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2)
              `;
            } else {
              button.style.boxShadow = `
                0 8px 32px rgba(139, 92, 246, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2)
              `;
            }
          });

          button.addEventListener('mouseleave', () => {
            button.style.transform = 'scale(1)';
            if (special === 'center') {
              button.style.boxShadow = `
                0 6px 24px rgba(16, 185, 129, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1)
              `;
            } else {
              button.style.boxShadow = `
                0 6px 24px rgba(139, 92, 246, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1)
              `;
            }
          });

          // Add click effect
          button.addEventListener('mousedown', () => {
            button.style.transform = 'scale(0.95)';
          });

          button.addEventListener('mouseup', () => {
            button.style.transform = 'scale(1.05)';
          });

          panControls.appendChild(button);
        });

        document.body.appendChild(panControls);

        console.log('🧭 PAN: Added dementia-friendly navigation controls');
      }

      // 🔍 FIT ALL MEMORIES IN VIEW
      fitAllMemories() {
        if (!this.nodes || this.nodes.length === 0) {
          // Reset to center if no nodes
          this.zoomState.scale = 1;
          this.zoomState.translateX = 0;
          this.zoomState.translateY = 0;
          this.updateConstellationTransform();
          return;
        }

        // Find bounding box of all nodes
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        this.nodes.forEach(node => {
          if (node.x !== undefined && node.y !== undefined) {
            minX = Math.min(minX, node.x - 50); // Add padding
            minY = Math.min(minY, node.y - 50);
            maxX = Math.max(maxX, node.x + 50);
            maxY = Math.max(maxY, node.y + 50);
          }
        });

        if (minX === Infinity) {
          // No valid positions, just center
          this.zoomState.scale = 1;
          this.zoomState.translateX = 0;
          this.zoomState.translateY = 0;
          this.updateConstellationTransform();
          return;
        }

        // Calculate optimal scale and position
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        const scaleX = (viewportWidth * 0.8) / contentWidth;
        const scaleY = (viewportHeight * 0.8) / contentHeight;
        const optimalScale = Math.min(scaleX, scaleY, this.zoomState.maxScale);
        const finalScale = Math.max(optimalScale, this.zoomState.minScale);

        // Center the content
        const contentCenterX = (minX + maxX) / 2;
        const contentCenterY = (minY + maxY) / 2;
        
        this.zoomState.scale = finalScale;
        this.zoomState.translateX = viewportWidth / 2 - contentCenterX * finalScale;
        this.zoomState.translateY = viewportHeight / 2 - contentCenterY * finalScale;

        this.updateConstellationTransform();
        
        console.log('🏠 ZOOM: Fitted all memories in view for Debbe');
      }

      // Removed fadeOutMemoryNodes and fadeInMemoryNodes - no longer needed since constellation mode exits to main dashboard

      // Completely clear all memory nodes from DOM (prevents duplicates)
      clearAllMemoryNodesFromDOM() {

        // Remove all memory-node, person-node, and create-memory-node elements (including orphaned ones)
        const existingMemoryNodes = document.querySelectorAll('.memory-node, .create-memory-node, .person-node');
        existingMemoryNodes.forEach(node => {

          node.remove();
        });

        // Clear ONLY memory nodes from the nodes array (preserve radial menu items)
        if (this.nodes) {
          this.nodes.forEach(node => {
            if (node.element && node.element.parentNode) {
              // Only remove if it's a constellation node, NOT a radial menu item
              if (node.element.classList.contains('memory-node') ||
                  node.element.classList.contains('create-memory-node') ||
                  node.element.classList.contains('person-node')) {

                node.element.remove();
              } else {

              }
            }
          });
          // Filter out only the constellation nodes, keep radial items
          this.nodes = this.nodes.filter(node =>
            !node.element.classList.contains('memory-node') &&
            !node.element.classList.contains('create-memory-node') &&
            !node.element.classList.contains('person-node')
          );
        }

        // Reset central node
        this.centralNode = null;

      }

      // Exit constellation mode
      exitMemoryConstellation() {

        this.isConstellationMode = false;

        // PERSISTENCE: Clear constellation state
        localStorage.removeItem('emmaConstellationActive');

        // Stop neural animation (EXACT same as main menu)
        this.isMenuOpen = false;
        if (this.neuralAnimationId) {
          cancelAnimationFrame(this.neuralAnimationId);
          this.neuralCtx.clearRect(0, 0, this.neuralCanvas.width, this.neuralCanvas.height);
        }

        // 🔍 RESET ZOOM STATE: Reset neural canvas transform and clean up
        if (this.neuralCanvas) {
          this.neuralCanvas.style.transform = '';
          this.neuralCanvas.style.transformOrigin = '';
        }
        
        // Remove constellation container  
        const constellationContainer = document.getElementById('constellation-zoom-container');
        if (constellationContainer) {
          constellationContainer.remove();
        }
        
        // Reset zoom state
        this.zoomState.scale = 1;
        this.zoomState.translateX = 0;
        this.zoomState.translateY = 0;
        this.constellationContainer = null;

        // Remove constellation-active class to restore UI
        document.body.classList.remove('constellation-active');
        document.body.classList.remove('menu-active');
        this.radialMenu.classList.remove('active');

        // Restore central orb size
        this.restoreCentralOrb();

        // Remove constellation UI
        if (this.constellationUI) {
          this.constellationUI.remove();
          this.constellationUI = null;
        }

        // CRITICAL: Use thorough DOM cleanup to prevent duplicates
        this.clearAllMemoryNodesFromDOM();

        // Clear animation
        if (this.neuralAnimationId) {
          cancelAnimationFrame(this.neuralAnimationId);
          this.neuralCtx.clearRect(0, 0, this.neuralCanvas.width, this.neuralCanvas.height);
        }

        // Reset nodes
        this.nodes = [];

        // Hide radial menu
        this.radialMenu.classList.remove('active');
        this.isMenuOpen = false;

        // Reset radial menu items to default state
        const radialItems = this.radialMenu.querySelectorAll('.radial-item');

        radialItems.forEach((item, i) => {

          item.style.opacity = '0';
          item.style.transform = 'scale(0)';
          // CRITICAL: Reset positioning to default
          item.style.left = '';
          item.style.top = '';
          item.style.animationPlayState = 'running';
        });
      }

      // Sanitize title to remove base64 or corrupted data
      sanitizeTitle(title) {
        if (!title || typeof title !== 'string') return 'Untitled Memory';

        // Check if it looks like base64 or corrupted data
        if (title.length > 50 || /^[A-Za-z0-9+\/=]{20,}$/.test(title)) {
          return 'Memory Capsule';
        }

        // Remove any non-printable characters and limit length
        const cleaned = title.replace(/[^\x20-\x7E]/g, '').trim();
        return cleaned.length > 0 ? cleaned.substring(0, 50) : 'Untitled Memory';
      }

      // 📱💻🖥️ RESPONSIVE MEMORY DIALOG - Works on ALL screen sizes!
      async openMemoryDialog(memory) {
        console.log('🎯 DASHBOARD: Opening responsive memory dialog for:', memory.title || memory.id);
        
        // 🚀 CRITICAL FIX: Load full media if lazy-loaded (from performance optimization)
        const memoryWithFullMedia = await this.loadFullMediaForMemory(memory);
        
        // 📱💻🖥️ USE THE NEW RESPONSIVE MEMORY DIALOG!
        this.showResponsiveMemoryDialog(memoryWithFullMedia);
      }

      /**
       * 🚀 PERFORMANCE OPTIMIZATION: Load full media data on-demand for lazy-loaded attachments
       * (Reused from memories.js constellation)
       */
      async loadFullMediaForMemory(memory) {
        // Check if this memory has lazy-loaded attachments that need full loading
        const hasLazyAttachments = memory.attachments?.some(att => att.isLazyLoaded && att.hasMedia);
        
        if (!hasLazyAttachments) {
          console.log('💾 DASHBOARD: Memory already has full media, no loading needed');
          return memory;
        }
        
        console.log('🚀 DASHBOARD: Loading full media for', memory.attachments?.length || 0, 'attachments');
        
        try {
          // Get vault media data
          const vaultMedia = window.emmaWebVault?.vaultData?.content?.media || {};
          
          // Load full media data for lazy-loaded attachments
          const fullAttachments = memory.attachments.map(attachment => {
            if (attachment.isLazyLoaded && attachment.hasMedia && attachment.mediaId) {
              const mediaItem = vaultMedia[attachment.mediaId];
              if (mediaItem && mediaItem.data) {
                console.log('💾 DASHBOARD: Loading full media for:', attachment.name);
                return {
                  ...attachment,
                  url: mediaItem.data.startsWith('data:')
                    ? mediaItem.data
                    : `data:${mediaItem.type};base64,${mediaItem.data}`,
                  dataUrl: mediaItem.data.startsWith('data:')
                    ? mediaItem.data
                    : `data:${mediaItem.type};base64,${mediaItem.data}`,
                  data: mediaItem.data,
                  isLazyLoaded: false, // Mark as fully loaded
                  isPersisted: true
                };
              }
            }
            
            // Return attachment as-is if already loaded or no media
            return attachment;
          });
          
          console.log('✅ DASHBOARD: Successfully loaded full media data');
          
          return {
            ...memory,
            attachments: fullAttachments
          };
          
        } catch (error) {
          console.error('❌ DASHBOARD: Failed to load full media:', error);
          // Return original memory if loading fails
          return memory;
        }
      }

      /**
       * 📱💻🖥️ RESPONSIVE MEMORY DIALOG - Works on ALL screen sizes!
       */
      showResponsiveMemoryDialog(memory) {
        // Prepare memory data  
        const hasImages = memory.attachments?.some(att => att.type?.startsWith('image/')) || 
                         memory.mediaItems?.some(item => item.type?.startsWith('image/'));
        const hasVideo = memory.attachments?.some(att => att.type?.startsWith('video/')) || 
                        memory.mediaItems?.some(item => item.type?.startsWith('video/'));
        const peopleList = memory.metadata?.people || memory.people || [];
        
        // Create fully responsive dialog for ALL screen sizes
        const dialog = document.createElement('div');
        dialog.className = 'memory-preview-dialog responsive dashboard';
        dialog.style.cssText = `
          position: fixed !important;
          top: 0 !important;
          left: 0 !important;
          width: 100% !important;
          height: 100% !important;
          z-index: 10000 !important;
          display: flex !important;
          align-items: flex-start !important;
          justify-content: center !important;
          opacity: 0;
          animation: dialogFadeIn 0.3s ease forwards;
          background: rgba(0, 0, 0, 0.6) !important;
          backdrop-filter: blur(25px) saturate(180%) !important;
          padding: 20px;
          overflow-y: auto !important;
          box-sizing: border-box;
          pointer-events: auto !important;
        `;

        dialog.innerHTML = `
          <style>
            /* 🎯 RESPONSIVE DIALOG STYLES FOR ALL SCREEN SIZES */
            @keyframes dialogFadeIn {
              from { opacity: 0; transform: scale(0.95); }
              to { opacity: 1; transform: scale(1); }
            }
            
            .responsive-memory-container {
              /* 🎨 EMMA GLASSMORPHISM: Match chat interface aesthetic */
              background: rgba(26, 16, 51, 0.92);
              backdrop-filter: blur(25px) saturate(150%);
              border-radius: clamp(16px, 3vw, 24px);
              max-width: 95vw;
              max-height: 95vh;
              width: 100%;
              overflow-y: auto;
              position: relative;
              animation: dialogFadeIn 0.3s ease forwards;
              border: 1px solid rgba(255, 255, 255, 0.12);
              box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.12);
            }
            
            /* 📱 MOBILE FIRST (320px+) */
            .responsive-memory-container {
              margin: 10px;
              padding: 20px;
            }
            
            /* 📱 TABLET (768px+) */
            @media (min-width: 768px) {
              .responsive-memory-container {
                margin: 20px;
                padding: 30px;
                max-width: 700px;
              }
            }
            
            /* 💻 LAPTOP (1024px+) */
            @media (min-width: 1024px) {
              .responsive-memory-container {
                margin: 40px;
                padding: 40px;
                max-width: 900px;
              }
            }
            
            /* 🖥️ DESKTOP (1440px+) */
            @media (min-width: 1440px) {
              .responsive-memory-container {
                max-width: 1100px;
                padding: 50px;
              }
            }
            
            /* HEADER STYLES */
            .memory-header {
              display: flex;
              justify-content: space-between;
              align-items: flex-start;
              margin-bottom: clamp(20px, 4vw, 30px);
              flex-wrap: wrap;
              gap: 15px;
            }
            
            .header-info h2 {
              margin: 0;
              color: white;
              font-size: clamp(20px, 4vw, 28px);
              font-weight: 700;
              line-height: 1.2;
              text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            
            .memory-date {
              color: rgba(255, 255, 255, 0.8);
              font-size: clamp(14px, 2.5vw, 16px);
              margin-top: 5px;
            }
            
            .close-btn {
              background: rgba(255, 255, 255, 0.15);
              border: none;
              color: white;
              width: clamp(40px, 6vw, 48px);
              height: clamp(40px, 6vw, 48px);
              border-radius: 50%;
              cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);
              flex-shrink: 0;
            }
            
            .close-btn:hover {
              background: rgba(255, 255, 255, 0.25);
              transform: scale(1.1);
            }
            
            /* HERO CAROUSEL STYLES */
            .hero-carousel {
              margin-bottom: clamp(25px, 5vw, 35px);
              border-radius: clamp(12px, 2.5vw, 16px);
            overflow: hidden;
            position: relative;
              aspect-ratio: 16/9;
              background: rgba(0, 0, 0, 0.3);
            }
            
            .carousel-container {
              position: relative;
              width: 100%;
              height: 100%;
            }
            
            .hero-image {
                position: absolute;
                top: 0;
                left: 0;
              width: 100%;
              height: 100%;
              background-size: cover;
              background-position: center;
              opacity: 0;
              transition: opacity 0.5s ease;
            }
            
            .hero-image.active {
              opacity: 1;
            }
            
            .image-overlay {
              position: absolute;
                bottom: 0;
              left: 0;
              right: 0;
              height: 50%;
              background: linear-gradient(transparent, rgba(0, 0, 0, 0.4));
            }
            
            .carousel-dots {
              position: absolute;
              bottom: 15px;
              left: 50%;
              transform: translateX(-50%);
                    display: flex;
              gap: 8px;
            }
            
            .dot {
              width: 10px;
              height: 10px;
              border-radius: 50%;
              background: rgba(255, 255, 255, 0.5);
              cursor: pointer;
              transition: all 0.3s ease;
            }
            
            .dot.active {
              background: white;
              transform: scale(1.2);
            }
            
            /* PEOPLE SECTION */
            .people-section {
              margin-bottom: clamp(25px, 5vw, 35px);
            }
            
            .section-title {
              color: white;
              font-size: clamp(16px, 3vw, 20px);
              font-weight: 600;
              margin: 0 0 clamp(15px, 3vw, 20px) 0;
              text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            
            .people-grid {
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(clamp(80px, 15vw, 120px), 1fr));
              gap: clamp(12px, 3vw, 20px);
              justify-items: center;
            }
            
            .memory-person-avatar {
              width: clamp(70px, 12vw, 100px);
              height: clamp(70px, 12vw, 100px);
                                border-radius: 50%;
              border: 3px solid rgba(255, 255, 255, 0.9);
                                overflow: hidden;
              position: relative;
              background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
                            display: flex;
                            flex-direction: column;
                              align-items: center;
                              justify-content: center;
              font-size: clamp(12px, 2.5vw, 16px);
                              font-weight: 600;
              color: white;
                    transition: all 0.3s ease;
              cursor: pointer;
              text-align: center;
              box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            }
            
            .memory-person-avatar:hover {
              transform: scale(1.05);
              border-color: white;
              box-shadow: 0 6px 20px rgba(139, 92, 246, 0.5);
            }
            
            .memory-person-avatar img {
              width: 100%;
              height: 100%;
              object-fit: cover;
            }
            
            /* CONTENT SECTION */
            .content-section {
              margin-bottom: clamp(25px, 5vw, 35px);
            }
            
            .memory-story p {
              color: white;
              font-size: clamp(16px, 3vw, 18px);
                line-height: 1.6;
              margin: 0 0 clamp(15px, 3vw, 20px) 0;
              text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            }
            
            .memory-tags {
                      display: flex;
                      align-items: center;
              gap: clamp(10px, 2vw, 15px);
              margin-bottom: clamp(10px, 2vw, 15px);
              flex-wrap: wrap;
            }
            
            .tag-label {
              font-size: clamp(16px, 3vw, 18px);
              flex-shrink: 0;
            }
            
            .emotions-list {
                    display: flex;
              gap: clamp(6px, 1.5vw, 10px);
              flex-wrap: wrap;
            }
            
            .emotion-tag, .location-tag {
              background: rgba(255, 255, 255, 0.15);
              color: white;
              padding: clamp(4px, 1vw, 6px) clamp(8px, 2vw, 12px);
              border-radius: clamp(12px, 2vw, 16px);
              font-size: clamp(12px, 2.5vw, 14px);
                      font-weight: 500;
              border: 1px solid rgba(255, 255, 255, 0.2);
              backdrop-filter: blur(10px);
            }
            
            /* MEDIA SECTION */
            .media-section {
              margin-bottom: clamp(25px, 5vw, 35px);
            }
            
            .media-grid {
                    display: grid;
              grid-template-columns: repeat(auto-fill, minmax(clamp(120px, 25vw, 200px), 1fr));
              gap: clamp(10px, 2vw, 15px);
            }
            
            .media-item {
              aspect-ratio: 1;
              border-radius: clamp(8px, 2vw, 12px);
                          overflow: hidden;
              background: rgba(255, 255, 255, 0.1);
                          position: relative;
              transition: transform 0.3s ease;
            }
            
            .media-item:hover {
              transform: scale(1.05);
            }
            
            .media-item img, .media-item video {
                              width: 100%;
                              height: 100%;
              object-fit: cover;
            }
            
            .video-play-overlay {
                                position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: clamp(20px, 4vw, 30px);
              color: white;
              text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            }
            
            /* ACTION BUTTONS */
            .action-buttons {
              display: flex;
              gap: clamp(12px, 3vw, 20px);
              margin-top: clamp(30px, 5vw, 40px);
              flex-wrap: wrap;
            }
            
            .action-btn {
              flex: 1;
              min-width: clamp(120px, 25vw, 150px);
              padding: clamp(12px, 2.5vw, 16px) clamp(20px, 4vw, 30px);
              border: none;
              border-radius: clamp(10px, 2vw, 14px);
              font-size: clamp(14px, 2.5vw, 16px);
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
              gap: clamp(6px, 1.5vw, 8px);
              text-decoration: none;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            
            .action-btn.primary {
              background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
              color: #8b5cf6;
              border: 2px solid rgba(255, 255, 255, 0.3);
            }
            
            .action-btn.primary:hover {
              transform: translateY(-2px);
              box-shadow: 0 6px 20px rgba(255, 255, 255, 0.3);
            }
            
            .action-btn.secondary {
              background: rgba(255, 255, 255, 0.15);
              color: white;
              border: 2px solid rgba(255, 255, 255, 0.3);
                                  backdrop-filter: blur(10px);
            }
            
            .action-btn.secondary:hover {
              background: rgba(255, 255, 255, 0.25);
              transform: translateY(-2px);
            }
          </style>
          
          <div class="responsive-memory-container">
            <!-- HEADER -->
            <div class="memory-header">
              <div class="header-info">
                <h2>${memory.metadata?.title || memory.title || memory.subject || 'Beautiful Memory'}</h2>
                <div class="memory-date">${this.formatMemoryDate(memory.created || memory.date || memory.timestamp)}</div>
              </div>
              <button class="close-btn" onclick="window.emmaDashboard.closeMemoryDialog()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                  <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </button>
                              </div>

            <!-- HERO CAROUSEL -->
            ${hasImages ? `
              <div class="hero-carousel">
                <div class="carousel-container">
                  ${(memory.attachments || memory.mediaItems || [])
                    .filter(att => att.type?.startsWith('image/'))
                    .slice(0, 5)
                    .map((image, index) => {
                      const imageUrl = image.url || image.dataUrl || image.data || image.previewUrl;
                      
                      // 🔧 FIX: Use img tag instead of background-image for better compatibility
                      return `
                        <div class="hero-image ${index === 0 ? 'active' : ''}">
                          <img src="${imageUrl}" alt="${image.name || 'Memory image'}" style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: 12px;
                          " />
                          <div class="image-overlay"></div>
                        </div>
                      `;
                    }).join('')}
                </div>
                ${(memory.attachments || memory.mediaItems || []).filter(att => att.type?.startsWith('image/')).length > 1 ? `
                  <div class="carousel-dots">
                    ${(memory.attachments || memory.mediaItems || [])
                      .filter(att => att.type?.startsWith('image/'))
                      .slice(0, 5)
                      .map((_, index) => `
                        <div class="dot ${index === 0 ? 'active' : ''}" onclick="window.emmaDashboard.switchDashboardCarouselImage(${index})"></div>
                      `).join('')}
                        </div>
                ` : ''}
              </div>
            ` : ''}
            
            <!-- PEOPLE SECTION -->
            ${peopleList.length > 0 ? `
              <div class="people-section">
                <h3 class="section-title">👥 People in this memory</h3>
                <div class="people-grid" id="people-grid-${memory.id}">
                  <!-- People avatars will be loaded here -->
                  </div>
                </div>
              ` : ''}

            <!-- CONTENT -->
            <div class="content-section">
              <div class="memory-story">
                <p>${memory.content || memory.description || memory.details || 'This precious memory is stored in your vault...'}</p>
            </div>

              ${memory.metadata?.emotions?.length > 0 ? `
                <div class="memory-tags">
                  <span class="tag-label">💭</span>
                  <div class="emotions-list">
                    ${memory.metadata.emotions.map(emotion => `
                      <span class="emotion-tag">${emotion}</span>
                    `).join('')}
                  </div>
                </div>
              ` : ''}

              ${memory.metadata?.location || memory.location ? `
                <div class="memory-tags">
                  <span class="tag-label">📍</span>
                  <span class="location-tag">${memory.metadata?.location || memory.location}</span>
                </div>
              ` : ''}
            </div>

            <!-- MEDIA GRID -->
            ${(memory.attachments?.length > 1 || memory.mediaItems?.length > 1) || hasVideo ? `
              <div class="media-section">
                <h3 class="section-title">📷 All Media (${(memory.attachments || memory.mediaItems || []).length})</h3>
                <div class="media-grid">
                  ${(memory.attachments || memory.mediaItems || []).map((attachment, index) => `
                    <div class="media-item ${attachment.type?.startsWith('image/') ? 'image' : attachment.type?.startsWith('video/') ? 'video' : 'file'}">
                      ${attachment.type?.startsWith('image/') ? `
                        <img src="${attachment.url || attachment.dataUrl || attachment.data || attachment.previewUrl}" alt="${attachment.name}" />
                      ` : attachment.type?.startsWith('video/') ? `
                        <video src="${attachment.dataUrl || attachment.url}" muted>
                        <div class="video-play-overlay">▶️</div>
                        </video>
                      ` : `
                        <div class="file-item">
                          <div class="file-icon">${attachment.type?.startsWith('audio/') ? '🎵' : '📄'}</div>
                          <div class="file-name">${attachment.name}</div>
                        </div>
                      `}
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}
            
            <!-- ACTION BUTTONS -->
            <div class="action-buttons">
              <button class="action-btn secondary" onclick="window.emmaDashboard.editDashboardMemory('${memory.id}')">
                ✏️ Edit Memory
              </button>
              <button class="action-btn primary" onclick="window.emmaDashboard.shareDashboardMemory('${memory.id}')">
                🔗 Share Memory
              </button>
            </div>
          </div>
        `;

        dialog.addEventListener('click', (e) => {
          if (e.target === dialog) {
            dialog.remove();
          }
        });

        document.body.appendChild(dialog);
        this.currentMemoryDialog = dialog;

        // Animate in
        setTimeout(() => {
          dialog.style.opacity = '1';
          // Load people avatars if needed
          this.loadDashboardPeopleAvatars(memory);
        }, 100);
      }

      /**
       * 📅 Format memory date for display
       */
      formatMemoryDate(timestamp) {
        if (!timestamp) return 'Unknown date';
        
        try {
          const date = new Date(timestamp);
          return date.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric', 
            month: 'long',
            day: 'numeric'
          });
        } catch (error) {
          console.warn('Error formatting date:', error);
          return 'Unknown date';
        }
      }

      /**
       * 🎠 Switch carousel image in dashboard dialog
       */
      switchDashboardCarouselImage(index) {
        const heroImages = document.querySelectorAll('.hero-image');
        const dots = document.querySelectorAll('.dot');
        
        heroImages.forEach((img, i) => {
          img.classList.toggle('active', i === index);
        });
        
        dots.forEach((dot, i) => {
          dot.classList.toggle('active', i === index);
        });
      }

      /**
       * 👥 Load people avatars for dashboard memory dialog
       */
      async loadDashboardPeopleAvatars(memory) {
        const peopleGrid = document.getElementById(`people-grid-${memory.id}`);
        if (!peopleGrid) return;

        const peopleList = memory.metadata?.people || memory.people || [];
        if (peopleList.length === 0) return;

        try {
          // Get vault data for people info
          let vaultData = null;
          if (window.emmaWebVault && window.emmaWebVault.vaultData) {
            vaultData = window.emmaWebVault.vaultData;
          }

          if (!vaultData?.content?.people) {
            console.warn('⚠️ No vault people data available');
            return;
          }

          const vaultPeople = vaultData.content.people;
          const vaultMedia = vaultData.content.media || {};

          // Create avatar elements for each person
          peopleList.forEach(personId => {
            const person = vaultPeople[personId];
            if (!person) return;

            // Resolve avatar URL
            let avatarUrl = person.avatarUrl;
            if (!avatarUrl && person.avatarId && vaultMedia[person.avatarId]) {
              const mediaItem = vaultMedia[person.avatarId];
              avatarUrl = mediaItem.data?.startsWith('data:') 
                ? mediaItem.data 
                : `data:${mediaItem.type};base64,${mediaItem.data}`;
            }

            const firstName = (person.name || 'Unknown').split(' ')[0];
            const initials = firstName.charAt(0).toUpperCase();

            const avatarElement = document.createElement('div');
            avatarElement.className = 'memory-person-avatar';
            avatarElement.onclick = () => this.openPersonDialog(personId);

            if (avatarUrl) {
              const img = document.createElement('img');
              img.src = avatarUrl;
              img.alt = person.name;
              img.onerror = () => {
                // Fallback to initials if image fails
                avatarElement.innerHTML = `<span>${initials}</span>`;
              };
              avatarElement.appendChild(img);
            } else {
              avatarElement.innerHTML = `<span>${initials}</span>`;
            }

            // Add name label below avatar
            const nameLabel = document.createElement('div');
            nameLabel.style.cssText = `
              color: white;
              font-size: clamp(12px, 2vw, 14px);
              font-weight: 500;
              margin-top: 8px;
              text-align: center;
            `;
            nameLabel.textContent = firstName;

            const avatarContainer = document.createElement('div');
            avatarContainer.appendChild(avatarElement);
            avatarContainer.appendChild(nameLabel);

            peopleGrid.appendChild(avatarContainer);
          });

        } catch (error) {
          console.error('❌ Error loading dashboard people avatars:', error);
        }
      }

      /**
       * ✏️ Edit memory from dashboard dialog - DIRECT APPROACH
       */
      editDashboardMemory(memoryId) {
        // Close current dialog
        this.closeMemoryDialog();
        
        // Simple approach: Create temporary instance JUST for the edit dialog
        if (typeof EmmaChatExperience !== 'undefined') {
          const tempChatExperience = new EmmaChatExperience();
          tempChatExperience.editMemoryDetails(memoryId);
        } else {
          console.error('❌ EmmaChatExperience not available');
        }
      }

      /**
       * 🔗 Share memory from dashboard dialog
       */
      shareDashboardMemory(memoryId) {
        const shareUrl = `${window.location.origin}/index.html?memory=${memoryId}`;
        
        if (navigator.share && navigator.canShare && navigator.canShare({ url: shareUrl })) {
          navigator.share({
            title: 'Emma Memory',
            text: 'Check out this memory from Emma',
            url: shareUrl
          }).catch(err => {
            console.log('Share cancelled:', err);
            // Fallback to copy
            this.copyToClipboard(shareUrl);
          });
        } else {
          // Fallback to copy to clipboard
          this.copyToClipboard(shareUrl);
        }
      }

      /**
       * 📋 Copy text to clipboard utility
       */
      copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(text).then(() => {
            this.showToast('🔗 Memory link copied to clipboard!', 'success');
          }).catch(err => {
            console.error('Failed to copy:', err);
            this.fallbackCopyToClipboard(text);
          });
        } else {
          this.fallbackCopyToClipboard(text);
        }
      }

      /**
       * 📋 Fallback copy method for older browsers
       */
      fallbackCopyToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
          document.execCommand('copy');
          this.showToast('🔗 Memory link copied to clipboard!', 'success');
        } catch (err) {
          console.error('Fallback copy failed:', err);
          this.showToast('❌ Failed to copy link', 'error');
        }
        
        document.body.removeChild(textArea);
      }

      /**
       * 🍞 Show toast notification
       */
      showToast(message, type = 'info') {
        // Create toast element
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? 'linear-gradient(135deg, #10b981, #059669)' : 
                      type === 'error' ? 'linear-gradient(135deg, #ef4444, #dc2626)' : 
                      'linear-gradient(135deg, #8b5cf6, #7c3aed)'};
          color: white;
          padding: 16px 24px;
          border-radius: 12px;
          font-size: 14px;
          font-weight: 500;
          z-index: 20000;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          opacity: 0;
          transform: translateX(100%);
          transition: all 0.3s ease;
        `;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => {
          toast.style.opacity = '1';
          toast.style.transform = 'translateX(0)';
        }, 100);
        
        // Remove after 3 seconds
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(100%)';
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }

      // Close memory dialog
      closeMemoryDialog() {
        if (this.currentMemoryDialog) {
          this.currentMemoryDialog.style.opacity = '0';
          setTimeout(() => {
            if (this.currentMemoryDialog) {
              this.currentMemoryDialog.remove();
              this.currentMemoryDialog = null;
            }
          }, 300);
        }
      }

      // Open person dialog from memory
      openPersonDialog(personId) {

        // Navigate to people page with person selected
        window.location.href = `pages/people-emma.html?person=${personId}`;
      }

      // Memory dialog slideshow controls
      prevSlide() {

        // Demo functionality - would implement real slideshow
      }

      nextSlide() {

        // Demo functionality - would implement real slideshow
      }

      shareMemory(memoryId) {

        this.showToast('📤 Memory shared!', 'success');
      }

      editMemory(memoryId) {

        this.showToast('✏️ Opening memory editor...', 'info');
      }

      // Filter constellation by theme
      filterByTheme(theme) {

        this.nodes.forEach(node => {
          if (node.theme === theme) {
            node.element.style.opacity = '1';
            node.element.style.transform = 'scale(1)';
          } else {
            node.element.style.opacity = '0.3';
            node.element.style.transform = 'scale(0.8)';
          }
        });
      }

      showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        const span = document.createElement('span');
        span.textContent = message; // Safe - prevents HTML injection
        toast.appendChild(span);
        document.body.appendChild(toast);

        setTimeout(() => toast.classList.add('show'), 10);

        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 400);
        }, 3000);
      }
    }

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', () => {
      // Small delay to ensure all elements are definitely available
      setTimeout(() => {
        console.log('🔍 DEBUG: Creating EmmaDashboard instance...');
      window.emmaDashboard = new EmmaDashboard();

        // Setup vault modal event listeners AFTER dashboard is created
      const dashboard = window.emmaDashboard;

      // Close button
      document.getElementById('close-vault-modal').addEventListener('click', () => {
        dashboard.closeVaultModal();
      });

      // Click outside to close
      document.getElementById('vault-modal').addEventListener('click', (e) => {
        if (e.target.id === 'vault-modal') {
          dashboard.closeVaultModal();
        }
      });

      // Unlock form handlers
      document.getElementById('unlock-btn').addEventListener('click', () => {
        dashboard.unlockVault();
      });

      document.getElementById('cancel-unlock-btn').addEventListener('click', () => {
        dashboard.hideUnlockForm();
      });

      // Create vault button handler
      document.getElementById('create-vault-btn').addEventListener('click', async () => {

        try {
          if (window.emmaAPI && window.emmaAPI.vault) {
            const st = await window.emmaAPI.vault.status();
            if (st && st.initialized) {

              dashboard.showUnlockForm();
              return;
            }
          }
        } catch {}
        // Load welcome page for vault setup
        window.location.assign('pages/welcome.html');
      });

      // Password input enter key
      document.getElementById('vault-password').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          dashboard.unlockVault();
        }
      });

      // QR Code handlers
      document.getElementById('generate-vault-qr-dashboard').addEventListener('click', () => {
        dashboard.showToast('📱 Vault QR generation coming soon!', 'info');
      });

      document.getElementById('open-qr-scanner-dashboard').addEventListener('click', () => {
        dashboard.showToast('📷 QR scanner coming soon!', 'info');
      });

      // Escape key to close vault modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const modal = document.getElementById('vault-modal');
          if (modal.classList.contains('show')) {
            dashboard.closeVaultModal();
          }
        }
      });

      // Vault status is managed by WebVaultStatus - don't override here!

        // PERSISTENCE: Check if constellation was active before refresh
        const constellationWasActive = localStorage.getItem('emmaConstellationActive') === 'true';
        if (constellationWasActive) {

          setTimeout(() => {
            if (window.emmaDashboard && window.emmaDashboard.enterMemoryConstellation) {
              window.emmaDashboard.enterMemoryConstellation();
            }
          }, 1000); // Wait for dashboard to fully initialize
        }

      // CRITICAL: Initialize vault objects AFTER all scripts load
      setTimeout(() => {
          console.log('🚨🔧 DASHBOARD: setTimeout running - starting vault initialization...');
          console.log('🚨🔧 DASHBOARD: EmmaWebVault class available:', typeof EmmaWebVault);
          console.log('🚨🔧 DASHBOARD: window.emmaWebVault exists:', !!window.emmaWebVault);
          
          // CRITICAL FIX: Create the global vault instance (was missing!)
          if (typeof EmmaWebVault !== 'undefined' && !window.emmaWebVault) {
            console.log('🚨🔧 DASHBOARD: Creating new EmmaWebVault instance...');
            window.emmaWebVault = new EmmaWebVault();
            console.log('✅ DASHBOARD: EmmaWebVault instance created and ready');
            console.log('✅ DASHBOARD: window.emmaWebVault now exists:', !!window.emmaWebVault);
            
            // IMMEDIATE VAULT RESTORATION for extension compatibility
            if (sessionStorage.getItem('emmaVaultActive') === 'true') {
              console.log('🚨🔧 DASHBOARD: Immediately restoring vault for extension compatibility...');
              console.log('🚨🔧 DASHBOARD: Session vault name:', sessionStorage.getItem('emmaVaultName'));
              console.log('🚨🔧 DASHBOARD: Document ready state:', document.readyState);
              
              window.emmaWebVault.restoreVaultState()
                .then(result => {
                  if (result) {
                    console.log('🚨✅ DASHBOARD: Vault restored successfully for extension!', {
                      isOpen: window.emmaWebVault.isOpen,
                      hasVaultData: !!window.emmaWebVault.vaultData,
                      hasAddMemoryMethod: typeof window.emmaWebVault.addMemory
                    });
                  } else {
                    console.log('🚨⚠️ DASHBOARD: Vault restore returned false - troubleshooting...');
                    console.log('🚨⚠️ DASHBOARD: Current vault state:', {
                      isOpen: window.emmaWebVault.isOpen,
                      hasVaultData: !!window.emmaWebVault.vaultData,
                      sessionActive: sessionStorage.getItem('emmaVaultActive'),
                      sessionName: sessionStorage.getItem('emmaVaultName')
                    });
                  }
                })
                .catch(error => {
                  console.error('🚨❌ DASHBOARD: Could not restore vault:', error);
                  console.error('🚨❌ DASHBOARD: Restore error details:', {
                    errorMessage: error.message,
                    errorStack: error.stack,
                    vaultExists: !!window.emmaWebVault,
                    sessionActive: sessionStorage.getItem('emmaVaultActive')
                  });
                });
            } else {
              console.log('🚨ℹ️ DASHBOARD: No active vault session found - extension will need manual unlock');
            }
          } else if (typeof EmmaWebVault === 'undefined') {
            console.error('🚨❌ DASHBOARD: EmmaWebVault class not available! Check script loading.');
          } else if (window.emmaWebVault) {
            console.log('🚨ℹ️ DASHBOARD: window.emmaWebVault already exists, skipping creation');
          } else {
            console.error('🚨❌ DASHBOARD: Unknown condition preventing vault creation');
          }

          // Check what's available        
          // Extension mode - Set up extension-aware vault status
        if (window.emmaWebVault && window.emmaWebVault.extensionAvailable) {

          // Set dashboard as ready - extension handles all vault operations
          const statusIcon = document.getElementById('status-icon');
          const statusTitle = document.getElementById('status-title');
          const statusDescription = document.getElementById('status-description');
          const actionBtn = document.getElementById('vault-action-btn');

          if (statusIcon) statusIcon.textContent = '🔗';
          if (statusTitle) statusTitle.textContent = 'Extension Connected';
          if (statusDescription) statusDescription.textContent = 'Ready to preserve memories! Extension manages your vault automatically.';
          if (actionBtn) actionBtn.style.display = 'none'; // Hide action button

          // Listen for extension vault ready event
          window.addEventListener('extension-vault-ready', (event) => {

            // Force update vault icon to unlocked
            const vaultIcon = document.querySelector('#vault-node .radial-item-icon');
            if (vaultIcon) {
              vaultIcon.textContent = '🔓';

            }

            // Update vault node status
            setTimeout(() => {
              if (window.dashboard && window.dashboard.updateVaultNodeStatus) {
                window.dashboard.updateVaultNodeStatus();

              }
            }, 100);
          });
        } else if (window.emmaWebVault && window.emmaWebVault.isOpen) {
          // Vault is already open and ready
          console.log('✅ DASHBOARD: Vault is already open and ready');
        }

        }, 100); // Small delay for DOM elements to be available
        
      }, 100); // Small delay to ensure all elements are definitely available
    });
    
    // 🚨 CRITICAL: Add postMessage handlers for content script communication
    window.addEventListener('message', (event) => {
      // Only handle messages from same origin
      if (event.origin !== window.location.origin) return;
      
      if (event.data?.type === 'EMMA_VAULT_CHECK') {
        console.log('🚨📨 DASHBOARD: Received vault check request from content script');
        
        const vaultStatus = {
          exists: !!window.emmaWebVault,
          isOpen: window.emmaWebVault?.isOpen,
          canAddMemory: typeof window.emmaWebVault?.addMemory === 'function',
          timestamp: Date.now()
        };
        
        console.log('🚨📨 DASHBOARD: Sending vault status:', vaultStatus);
        
        window.postMessage({
          type: 'EMMA_VAULT_RESPONSE',
          messageId: event.data.messageId,
          vaultStatus: vaultStatus
        }, '*');
      }
      
                    if (event.data?.type === 'EMMA_VAULT_SAVE' && window.emmaWebVault && window.emmaWebVault.isOpen) {
                console.log('🚨💾 DASHBOARD: Received save request from content script');
                console.log('🚨💾 DASHBOARD: Memory data size:', JSON.stringify(event.data.memoryData).length);

                window.emmaWebVault.addMemory(event.data.memoryData)
                  .then(result => {
                    console.log('🚨✅ DASHBOARD: Save successful:', result);
                    
                    // 🎯 CRITICAL: Trigger constellation refresh after extension save
                    console.log('🔄 DASHBOARD: Triggering constellation refresh after extension save...');
                    window.dispatchEvent(new CustomEvent('emmaMemoryAdded', {
                      detail: { 
                        memoryId: result.id,
                        source: 'extension',
                        timestamp: Date.now()
                      }
                    }));
                    
                    window.postMessage({
                      type: 'EMMA_VAULT_SAVE_RESPONSE',
                      messageId: event.data.messageId,
                      result: { success: true, result }
                    }, '*');
                  })
                  .catch(error => {
                    console.error('🚨❌ DASHBOARD: Save failed:', error);
                    window.postMessage({
                      type: 'EMMA_VAULT_SAVE_RESPONSE',
                      messageId: event.data.messageId,
                      result: { success: false, error: error.message }
                    }, '*');
                  });
              }
    });
  </script>
</body>
</html>
