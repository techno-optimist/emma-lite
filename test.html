<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emma Extension Test Page</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f9fafb;
    }
    
    h1 {
      color: #1f2937;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: #6b7280;
      margin-bottom: 30px;
    }
    
    .test-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .test-card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .test-card h2 {
      color: #374151;
      font-size: 18px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .status {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: auto;
    }
    
    .status.pending {
      background: #fbbf24;
    }
    
    .status.success {
      background: #10b981;
    }
    
    .status.error {
      background: #ef4444;
    }
    
    button {
      padding: 10px 16px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    
    button:hover {
      background: #5a67d8;
    }
    
    button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }
    
    .test-output {
      margin-top: 15px;
      padding: 12px;
      background: #f3f4f6;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #374151;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    .test-output.error {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .test-output.success {
      background: #d1fae5;
      color: #065f46;
    }
    
    .simulation-chat {
      background: white;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .chat-messages {
      max-height: 400px;
      overflow-y: auto;
      padding: 20px;
      background: #f9fafb;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .message {
      margin-bottom: 16px;
      padding: 12px;
      border-radius: 8px;
    }
    
    .message.user {
      background: #667eea;
      color: white;
      margin-left: 40px;
      text-align: right;
    }
    
    .message.assistant {
      background: white;
      border: 1px solid #e5e7eb;
      margin-right: 40px;
    }
    
    .message-role {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.7;
      margin-bottom: 4px;
    }
    
    .chat-input {
      display: flex;
      gap: 10px;
    }
    
    .chat-input input {
      flex: 1;
      padding: 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .stat {
      text-align: center;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #1f2937;
    }
    
    .stat-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .log-container {
      background: #1f2937;
      color: #10b981;
      padding: 20px;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 30px;
    }
    
    .log-entry {
      margin-bottom: 4px;
      opacity: 0.8;
    }
    
    .log-entry.error {
      color: #ef4444;
    }
    
    .log-entry.success {
      color: #10b981;
    }
    
    .log-entry.info {
      color: #60a5fa;
    }
  </style>
</head>
<body>
  <h1>üß† Emma Extension Test Suite</h1>
  <p class="subtitle">Test and verify Emma Memory extension functionality</p>
  
  <!-- Simulated Chat -->
  <div class="simulation-chat">
    <h2>Chat Simulation</h2>
    <div class="chat-messages" id="chat-messages">
      <div class="message assistant">
        <div class="message-role">Assistant</div>
        Hello! How can I help you today?
      </div>
    </div>
    <div class="chat-input">
      <input type="text" id="chat-input" placeholder="Type a message to simulate a chat..." />
      <button onclick="sendMessage()">Send as User</button>
      <button onclick="sendAssistantMessage()">Send as Assistant</button>
    </div>
  </div>
  
  <!-- Test Grid -->
  <div class="test-grid">
    <!-- Extension Status Test -->
    <div class="test-card">
      <h2>
        Extension Status
        <span class="status pending" id="status-extension"></span>
      </h2>
      <button onclick="testExtension()">Check Extension</button>
      <div class="test-output" id="output-extension">Click to check if extension is installed and running</div>
    </div>
    
    <!-- Database Test -->
    <div class="test-card">
      <h2>
        Database Connection
        <span class="status pending" id="status-database"></span>
      </h2>
      <button onclick="testDatabase()">Test Database</button>
      <div class="test-output" id="output-database">Click to test IndexedDB connection</div>
    </div>
    
    <!-- Save Memory Test -->
    <div class="test-card">
      <h2>
        Save Memory
        <span class="status pending" id="status-save"></span>
      </h2>
      <button onclick="testSaveMemory()">Save Test Memory</button>
      <button onclick="saveBulkMemories()">Save 10 Memories</button>
      <div class="test-output" id="output-save">Click to save a test memory</div>
    </div>
    
    <!-- Search Test -->
    <div class="test-card">
      <h2>
        Search Memories
        <span class="status pending" id="status-search"></span>
      </h2>
      <input type="text" id="search-query" placeholder="Search query..." style="width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #d1d5db; border-radius: 6px;">
      <button onclick="testSearch()">Search</button>
      <div class="test-output" id="output-search">Enter a query and click search</div>
    </div>
    
    <!-- Statistics Test -->
    <div class="test-card">
      <h2>
        Statistics
        <span class="status pending" id="status-stats"></span>
      </h2>
      <button onclick="testStats()">Get Stats</button>
      <div class="stats-grid" id="stats-grid" style="display: none;">
        <div class="stat">
          <div class="stat-value" id="stat-total">0</div>
          <div class="stat-label">Total Memories</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-storage">0 KB</div>
          <div class="stat-label">Storage Used</div>
        </div>
      </div>
      <div class="test-output" id="output-stats">Click to get statistics</div>
    </div>
    
    <!-- Export/Import Test -->
    <div class="test-card">
      <h2>
        Export/Import
        <span class="status pending" id="status-export"></span>
      </h2>
      <button onclick="testExport()">Export Data</button>
      <button onclick="document.getElementById('import-file').click()">Import Data</button>
      <input type="file" id="import-file" accept=".json" style="display: none;" onchange="testImport(this.files[0])">
      <div class="test-output" id="output-export">Click to test export/import</div>
    </div>
    
    <!-- Clear Data Test -->
    <div class="test-card">
      <h2>
        Clear Data
        <span class="status pending" id="status-clear"></span>
      </h2>
      <button onclick="testClear()" style="background: #ef4444;">Clear All Memories</button>
      <div class="test-output" id="output-clear">‚ö†Ô∏è This will delete all stored memories</div>
    </div>
    
    <!-- Settings Test -->
    <div class="test-card">
      <h2>
        Settings
        <span class="status pending" id="status-settings"></span>
      </h2>
      <button onclick="testSettings()">Get Settings</button>
      <button onclick="toggleAutoCapture()">Toggle Auto-Capture</button>
      <div class="test-output" id="output-settings">Click to test settings</div>
    </div>
  </div>
  
  <!-- Debug Log -->
  <div class="log-container" id="log-container">
    <div class="log-entry info">Emma Test Suite initialized...</div>
  </div>

  <script>
    // Logging utility
    function log(message, type = 'info') {
      const logContainer = document.getElementById('log-container');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // Update status indicator
    function updateStatus(testId, status) {
      const indicator = document.getElementById(`status-${testId}`);
      indicator.className = `status ${status}`;
    }
    
    // Update output
    function updateOutput(testId, content, isError = false) {
      const output = document.getElementById(`output-${testId}`);
      output.textContent = typeof content === 'object' ? JSON.stringify(content, null, 2) : content;
      output.className = `test-output ${isError ? 'error' : ''}`;
    }
    
    // Test extension presence
    async function testExtension() {
      try {
        log('Testing extension presence...');
        updateStatus('extension', 'pending');
        
        if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
          // Try to send a message to the extension
          chrome.runtime.sendMessage(
            'YOUR_EXTENSION_ID', // Will be replaced with actual ID
            { action: 'ping' },
            response => {
              if (chrome.runtime.lastError) {
                // Extension might not be installed or ID is wrong
                updateStatus('extension', 'error');
                updateOutput('extension', 'Extension not detected. Make sure it\'s installed and enabled.', true);
                log('Extension not detected', 'error');
              } else {
                updateStatus('extension', 'success');
                updateOutput('extension', 'Extension is installed and running!');
                log('Extension detected successfully', 'success');
              }
            }
          );
        } else {
          updateStatus('extension', 'error');
          updateOutput('extension', 'Chrome extension API not available', true);
          log('Chrome API not available', 'error');
        }
      } catch (error) {
        updateStatus('extension', 'error');
        updateOutput('extension', error.message, true);
        log(`Extension test failed: ${error.message}`, 'error');
      }
    }
    
    // Test database connection
    async function testDatabase() {
      try {
        log('Testing IndexedDB connection...');
        updateStatus('database', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const objectStores = Array.from(db.objectStoreNames);
          updateStatus('database', 'success');
          updateOutput('database', `Database connected!\nObject stores: ${objectStores.join(', ')}`);
          log('Database connection successful', 'success');
          db.close();
        };
        
        request.onerror = () => {
          updateStatus('database', 'error');
          updateOutput('database', 'Failed to connect to database', true);
          log('Database connection failed', 'error');
        };
      } catch (error) {
        updateStatus('database', 'error');
        updateOutput('database', error.message, true);
        log(`Database test failed: ${error.message}`, 'error');
      }
    }
    
    // Test saving memory
    async function testSaveMemory() {
      try {
        log('Testing memory save...');
        updateStatus('save', 'pending');
        
        const testMemory = {
          content: `Test memory created at ${new Date().toISOString()}`,
          role: 'user',
          source: 'test-page',
          type: 'test',
          metadata: {
            test: true,
            timestamp: Date.now()
          }
        };
        
        // Direct IndexedDB save for testing
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readwrite');
          const store = transaction.objectStore('memories');
          
          const addRequest = store.add({
            ...testMemory,
            timestamp: Date.now(),
            searchText: testMemory.content.toLowerCase()
          });
          
          addRequest.onsuccess = () => {
            updateStatus('save', 'success');
            updateOutput('save', `Memory saved with ID: ${addRequest.result}`);
            log(`Memory saved successfully (ID: ${addRequest.result})`, 'success');
            db.close();
          };
          
          addRequest.onerror = () => {
            updateStatus('save', 'error');
            updateOutput('save', 'Failed to save memory', true);
            log('Memory save failed', 'error');
            db.close();
          };
        };
      } catch (error) {
        updateStatus('save', 'error');
        updateOutput('save', error.message, true);
        log(`Save test failed: ${error.message}`, 'error');
      }
    }
    
    // Save bulk memories
    async function saveBulkMemories() {
      try {
        log('Saving 10 test memories...');
        updateStatus('save', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readwrite');
          const store = transaction.objectStore('memories');
          
          let savedCount = 0;
          const topics = ['AI', 'coding', 'memory', 'learning', 'ChatGPT', 'Claude', 'extension', 'test', 'JavaScript', 'Chrome'];
          
          for (let i = 0; i < 10; i++) {
            const memory = {
              content: `Test memory #${i + 1} about ${topics[i]} created at ${new Date().toISOString()}`,
              role: i % 2 === 0 ? 'user' : 'assistant',
              source: 'test-page',
              type: 'test',
              timestamp: Date.now() - (i * 60000), // Stagger timestamps
              searchText: `test memory ${topics[i]}`.toLowerCase(),
              metadata: {
                index: i,
                topic: topics[i]
              }
            };
            
            const addRequest = store.add(memory);
            addRequest.onsuccess = () => {
              savedCount++;
              if (savedCount === 10) {
                updateStatus('save', 'success');
                updateOutput('save', '10 test memories saved successfully!');
                log('Bulk save completed', 'success');
                db.close();
              }
            };
          }
        };
      } catch (error) {
        updateStatus('save', 'error');
        updateOutput('save', error.message, true);
        log(`Bulk save failed: ${error.message}`, 'error');
      }
    }
    
    // Test search
    async function testSearch() {
      try {
        const query = document.getElementById('search-query').value;
        if (!query) {
          updateOutput('search', 'Please enter a search query');
          return;
        }
        
        log(`Searching for: ${query}`);
        updateStatus('search', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readonly');
          const store = transaction.objectStore('memories');
          
          const getAllRequest = store.getAll();
          
          getAllRequest.onsuccess = () => {
            const memories = getAllRequest.result;
            const queryLower = query.toLowerCase();
            
            // Simple search implementation
            const results = memories.filter(memory => {
              const searchText = (memory.searchText || memory.content || '').toLowerCase();
              return searchText.includes(queryLower);
            });
            
            updateStatus('search', 'success');
            updateOutput('search', `Found ${results.length} results:\n\n${results.map(r => r.content).join('\n\n')}`);
            log(`Search completed: ${results.length} results`, 'success');
            db.close();
          };
        };
      } catch (error) {
        updateStatus('search', 'error');
        updateOutput('search', error.message, true);
        log(`Search failed: ${error.message}`, 'error');
      }
    }
    
    // Test statistics
    async function testStats() {
      try {
        log('Getting statistics...');
        updateStatus('stats', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readonly');
          const store = transaction.objectStore('memories');
          
          const countRequest = store.count();
          
          countRequest.onsuccess = () => {
            const count = countRequest.result;
            
            // Estimate storage
            if (navigator.storage && navigator.storage.estimate) {
              navigator.storage.estimate().then(estimate => {
                const usedMB = (estimate.usage / 1024 / 1024).toFixed(2);
                
                document.getElementById('stat-total').textContent = count;
                document.getElementById('stat-storage').textContent = `${usedMB} MB`;
                document.getElementById('stats-grid').style.display = 'grid';
                
                updateStatus('stats', 'success');
                updateOutput('stats', `Total memories: ${count}\nStorage used: ${usedMB} MB`);
                log(`Stats retrieved: ${count} memories, ${usedMB} MB`, 'success');
                db.close();
              });
            } else {
              updateStatus('stats', 'success');
              updateOutput('stats', `Total memories: ${count}`);
              db.close();
            }
          };
        };
      } catch (error) {
        updateStatus('stats', 'error');
        updateOutput('stats', error.message, true);
        log(`Stats failed: ${error.message}`, 'error');
      }
    }
    
    // Test export
    async function testExport() {
      try {
        log('Exporting data...');
        updateStatus('export', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readonly');
          const store = transaction.objectStore('memories');
          
          const getAllRequest = store.getAll();
          
          getAllRequest.onsuccess = () => {
            const memories = getAllRequest.result;
            
            const exportData = {
              version: '1.0.0',
              exportDate: new Date().toISOString(),
              memories: memories,
              stats: {
                totalMemories: memories.length
              }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `emma-test-export-${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            
            updateStatus('export', 'success');
            updateOutput('export', `Exported ${memories.length} memories`);
            log(`Export completed: ${memories.length} memories`, 'success');
            db.close();
          };
        };
      } catch (error) {
        updateStatus('export', 'error');
        updateOutput('export', error.message, true);
        log(`Export failed: ${error.message}`, 'error');
      }
    }
    
    // Test import
    async function testImport(file) {
      try {
        log('Importing data...');
        updateStatus('export', 'pending');
        
        const text = await file.text();
        const data = JSON.parse(text);
        
        if (!data.memories || !Array.isArray(data.memories)) {
          throw new Error('Invalid import file format');
        }
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readwrite');
          const store = transaction.objectStore('memories');
          
          let imported = 0;
          
          data.memories.forEach(memory => {
            const addRequest = store.add({
              ...memory,
              timestamp: memory.timestamp || Date.now(),
              searchText: (memory.content || '').toLowerCase()
            });
            
            addRequest.onsuccess = () => {
              imported++;
              if (imported === data.memories.length) {
                updateStatus('export', 'success');
                updateOutput('export', `Imported ${imported} memories`);
                log(`Import completed: ${imported} memories`, 'success');
                db.close();
              }
            };
          });
        };
      } catch (error) {
        updateStatus('export', 'error');
        updateOutput('export', error.message, true);
        log(`Import failed: ${error.message}`, 'error');
      }
    }
    
    // Test clear
    async function testClear() {
      if (!confirm('Are you sure you want to clear all memories?')) {
        return;
      }
      
      try {
        log('Clearing all memories...');
        updateStatus('clear', 'pending');
        
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readwrite');
          const store = transaction.objectStore('memories');
          
          const clearRequest = store.clear();
          
          clearRequest.onsuccess = () => {
            updateStatus('clear', 'success');
            updateOutput('clear', 'All memories cleared');
            log('All memories cleared', 'success');
            db.close();
            
            // Update stats
            testStats();
          };
        };
      } catch (error) {
        updateStatus('clear', 'error');
        updateOutput('clear', error.message, true);
        log(`Clear failed: ${error.message}`, 'error');
      }
    }
    
    // Test settings
    async function testSettings() {
      try {
        log('Testing settings...');
        updateStatus('settings', 'pending');
        
        // Simulate settings using localStorage
        const settings = {
          autoCapture: localStorage.getItem('emma_autoCapture') !== 'false',
          captureUser: localStorage.getItem('emma_captureUser') !== 'false',
          captureAI: localStorage.getItem('emma_captureAI') !== 'false',
          debugMode: localStorage.getItem('emma_debugMode') === 'true',
          maxMemories: parseInt(localStorage.getItem('emma_maxMemories') || '10000')
        };
        
        updateStatus('settings', 'success');
        updateOutput('settings', JSON.stringify(settings, null, 2));
        log('Settings retrieved', 'success');
      } catch (error) {
        updateStatus('settings', 'error');
        updateOutput('settings', error.message, true);
        log(`Settings test failed: ${error.message}`, 'error');
      }
    }
    
    // Toggle auto-capture
    function toggleAutoCapture() {
      const current = localStorage.getItem('emma_autoCapture') !== 'false';
      localStorage.setItem('emma_autoCapture', (!current).toString());
      log(`Auto-capture toggled to: ${!current}`, 'info');
      testSettings();
    }
    
    // Chat simulation
    function sendMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      
      if (!message) return;
      
      addChatMessage(message, 'user');
      input.value = '';
      
      // Save to memory
      saveMessageAsMemory(message, 'user');
    }
    
    function sendAssistantMessage() {
      const responses = [
        "I understand. Let me help you with that.",
        "That's an interesting question! Here's what I think...",
        "Based on what you've told me, I would suggest...",
        "Great point! Have you considered...",
        "Let me explain that in more detail..."
      ];
      
      const message = responses[Math.floor(Math.random() * responses.length)];
      addChatMessage(message, 'assistant');
      
      // Save to memory
      saveMessageAsMemory(message, 'assistant');
    }
    
    function addChatMessage(content, role) {
      const messagesContainer = document.getElementById('chat-messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${role}`;
      messageDiv.innerHTML = `
        <div class="message-role">${role}</div>
        ${content}
      `;
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    async function saveMessageAsMemory(content, role) {
      try {
        const request = indexedDB.open('EmmaLiteDB', 1);
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['memories'], 'readwrite');
          const store = transaction.objectStore('memories');
          
          const memory = {
            content: content,
            role: role,
            source: 'test-chat',
            type: 'conversation',
            timestamp: Date.now(),
            searchText: content.toLowerCase(),
            metadata: {
              test: true
            }
          };
          
          const addRequest = store.add(memory);
          
          addRequest.onsuccess = () => {
            log(`Chat message saved as memory (${role})`, 'success');
            db.close();
          };
        };
      } catch (error) {
        log(`Failed to save chat message: ${error.message}`, 'error');
      }
    }
    
    // Initialize
    window.addEventListener('load', () => {
      log('Test page loaded', 'info');
      log('Run tests to verify Emma extension functionality', 'info');
    });
  </script>
</body>
</html>