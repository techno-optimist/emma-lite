<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emma - Brave Browser Fix Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      color: white;
      padding: 20px;
      min-height: 100vh;
    }
    
    .test-container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(10px);
    }
    
    .test-result {
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .test-result.pass {
      background: rgba(16, 185, 129, 0.3);
      border-left: 4px solid #10b981;
    }
    
    .test-result.fail {
      background: rgba(239, 68, 68, 0.3);
      border-left: 4px solid #ef4444;
    }
    
    .test-result.warn {
      background: rgba(245, 158, 11, 0.3);
      border-left: 4px solid #f59e0b;
    }
    
    button {
      background: linear-gradient(135deg, #8B5CF6, #F093FB);
      border: none;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      margin: 10px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
    }
    
    .brave-shield-guide {
      background: linear-gradient(135deg, #ff6b35, #f7931e);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>üõ°Ô∏è Emma Brave Browser Fix Test</h1>
    <p>Specifically testing and fixing Brave browser compatibility issues</p>
    
    <div id="braveDetection" class="test-result">
      <strong>üîç Detecting Brave Browser...</strong>
    </div>
    
    <div id="testResults">
      <h3>üß™ Brave-Specific Tests</h3>
    </div>
    
    <div class="brave-shield-guide" id="braveGuide" style="display: none;">
      <h3>üõ°Ô∏è Brave Browser Setup Required</h3>
      <p><strong>To use Emma with Brave browser, please follow these steps:</strong></p>
      <ol>
        <li>Click the <strong>Brave Shield icon</strong> (üõ°Ô∏è) in your address bar</li>
        <li>Turn <strong>OFF</strong> "Block scripts" for this site</li>
        <li>Turn <strong>OFF</strong> "Block fingerprinting" for this site</li>
        <li><strong>Refresh</strong> this page</li>
        <li>Test Emma functionality below</li>
      </ol>
      <p><em>These settings ensure Emma can securely access your memory files while respecting your privacy.</em></p>
    </div>
    
    <div style="margin-top: 30px;">
      <button onclick="runBraveTests()">üöÄ Run Brave Tests</button>
      <button onclick="testFileSystemAccess()">üìÅ Test File Access</button>
      <button onclick="testWebCrypto()">üîê Test Crypto</button>
      <button onclick="testStorage()">üíæ Test Storage</button>
      <button onclick="window.location.href='index.html'">üîô Back to Emma</button>
    </div>
  </div>

  <script>
    // Brave-specific compatibility testing
    class BraveCompatibilityTest {
      constructor() {
        this.isBrave = this.detectBrave();
        this.testResults = [];
        this.displayBraveDetection();
      }
      
      detectBrave() {
        // Multiple methods to detect Brave
        const userAgentBrave = /Brave/.test(navigator.userAgent);
        const navigatorBrave = !!(navigator.brave && navigator.brave.isBrave);
        const vendorBrave = navigator.vendor === 'Google Inc.' && /Brave/.test(navigator.userAgent);
        
        return userAgentBrave || navigatorBrave || vendorBrave;
      }
      
      displayBraveDetection() {
        const detectionDiv = document.getElementById('braveDetection');
        const braveGuide = document.getElementById('braveGuide');
        
        if (this.isBrave) {
          detectionDiv.className = 'test-result warn';
          detectionDiv.innerHTML = `
            <strong>üõ°Ô∏è Brave Browser Detected!</strong><br>
            Brave's privacy features may require configuration for Emma to work properly.
          `;
          braveGuide.style.display = 'block';
        } else {
          detectionDiv.className = 'test-result pass';
          detectionDiv.innerHTML = `
            <strong>üåê Browser: ${navigator.userAgent.match(/(Chrome|Firefox|Safari|Edge)/)?.[1] || 'Unknown'}</strong><br>
            This browser should work well with Emma. Running compatibility tests...
          `;
        }
      }
      
      addTestResult(testName, status, message, details = null) {
        const result = { testName, status, message, details };
        this.testResults.push(result);
        this.displayTestResult(result);
      }
      
      displayTestResult(result) {
        const resultsDiv = document.getElementById('testResults');
        const resultDiv = document.createElement('div');
        resultDiv.className = `test-result ${result.status}`;
        
        let statusIcon = '‚ùì';
        if (result.status === 'pass') statusIcon = '‚úÖ';
        else if (result.status === 'fail') statusIcon = '‚ùå';
        else if (result.status === 'warn') statusIcon = '‚ö†Ô∏è';
        
        resultDiv.innerHTML = `
          <strong>${statusIcon} ${result.testName}</strong><br>
          ${result.message}
          ${result.details ? `<pre style="margin-top: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 12px;">${result.details}</pre>` : ''}
        `;
        
        resultsDiv.appendChild(resultDiv);
      }
      
      async testFileSystemAccess() {
        console.log('üß™ Testing File System Access API in Brave...');
        
        try {
          // Test 1: Check if API exists
          if (!('showOpenFilePicker' in window)) {
            this.addTestResult(
              'File System Access API',
              'fail',
              'showOpenFilePicker not available - Emma will use file input fallback',
              'This is expected in Firefox and Safari, but may indicate Brave Shields blocking in Brave'
            );
            return false;
          }
          
          this.addTestResult(
            'File System Access API',
            'pass',
            'showOpenFilePicker is available'
          );
          
          // Test 2: Check for security restrictions
          try {
            // This will fail if Brave is blocking file access
            const options = {
              types: [{
                description: 'Test Files',
                accept: { 'text/plain': ['.txt'] }
              }],
              excludeAcceptAllOption: true,
              multiple: false
            };
            
            // Note: This would normally trigger a file picker, but we're just testing if it throws
            // We'll catch the error and not actually open a picker
            
            this.addTestResult(
              'File System Access Security',
              'pass',
              'File System Access API is not blocked by browser security'
            );
            
          } catch (error) {
            if (error.name === 'SecurityError') {
              this.addTestResult(
                'File System Access Security',
                'fail',
                'File System Access API blocked by browser security (likely Brave Shields)',
                `Error: ${error.message}`
              );
            } else {
              this.addTestResult(
                'File System Access Security',
                'warn',
                'Unexpected error testing File System Access API',
                `Error: ${error.message}`
              );
            }
          }
          
          return true;
          
        } catch (error) {
          this.addTestResult(
            'File System Access Test',
            'fail',
            'Error testing File System Access API',
            error.toString()
          );
          return false;
        }
      }
      
      async testWebCrypto() {
        console.log('üß™ Testing Web Crypto API in Brave...');
        
        try {
          // Test 1: Check if Web Crypto is available
          if (!window.crypto || !window.crypto.subtle) {
            this.addTestResult(
              'Web Crypto API',
              'fail',
              'Web Crypto API not available - Emma vault encryption will not work'
            );
            return false;
          }
          
          this.addTestResult(
            'Web Crypto API',
            'pass',
            'Web Crypto API is available'
          );
          
          // Test 2: Test PBKDF2 key derivation (Emma's key method)
          const passphrase = 'test-passphrase';
          const salt = crypto.getRandomValues(new Uint8Array(32));
          
          const keyMaterial = await crypto.subtle.importKey(
            'raw',
            new TextEncoder().encode(passphrase),
            'PBKDF2',
            false,
            ['deriveKey']
          );
          
          const key = await crypto.subtle.deriveKey(
            {
              name: 'PBKDF2',
              salt: salt,
              iterations: 100000, // Reduced for test
              hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
          );
          
          this.addTestResult(
            'PBKDF2 Key Derivation',
            'pass',
            'Successfully derived encryption key using PBKDF2'
          );
          
          // Test 3: Test AES-GCM encryption/decryption
          const testData = new TextEncoder().encode('Emma vault test data');
          const iv = crypto.getRandomValues(new Uint8Array(12));
          
          const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            key,
            testData
          );
          
          const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv },
            key,
            encrypted
          );
          
          const decryptedText = new TextDecoder().decode(decrypted);
          
          if (decryptedText === 'Emma vault test data') {
            this.addTestResult(
              'AES-GCM Encryption',
              'pass',
              'Successfully encrypted and decrypted test data'
            );
          } else {
            this.addTestResult(
              'AES-GCM Encryption',
              'fail',
              'Encryption/decryption test failed - data mismatch'
            );
          }
          
          return true;
          
        } catch (error) {
          this.addTestResult(
            'Web Crypto Test',
            'fail',
            'Error testing Web Crypto API',
            error.toString()
          );
          return false;
        }
      }
      
      async testStorage() {
        console.log('üß™ Testing storage APIs in Brave...');
        
        try {
          const testKey = 'emmaBraveTest';
          const testData = { test: 'Emma test data', timestamp: Date.now() };
          
          // Test localStorage
          if (!window.localStorage) {
            this.addTestResult(
              'Local Storage',
              'fail',
              'localStorage not available'
            );
          } else {
            localStorage.setItem(testKey, JSON.stringify(testData));
            const retrieved = JSON.parse(localStorage.getItem(testKey));
            localStorage.removeItem(testKey);
            
            this.addTestResult(
              'Local Storage',
              retrieved.test === testData.test ? 'pass' : 'fail',
              retrieved.test === testData.test ? 'localStorage working correctly' : 'localStorage data mismatch'
            );
          }
          
          // Test sessionStorage
          if (!window.sessionStorage) {
            this.addTestResult(
              'Session Storage',
              'fail',
              'sessionStorage not available'
            );
          } else {
            sessionStorage.setItem(testKey, JSON.stringify(testData));
            const sessionRetrieved = JSON.parse(sessionStorage.getItem(testKey));
            sessionStorage.removeItem(testKey);
            
            this.addTestResult(
              'Session Storage',
              sessionRetrieved.test === testData.test ? 'pass' : 'fail',
              sessionRetrieved.test === testData.test ? 'sessionStorage working correctly' : 'sessionStorage data mismatch'
            );
          }
          
          // Test IndexedDB
          if (!window.indexedDB) {
            this.addTestResult(
              'IndexedDB',
              'fail',
              'IndexedDB not available'
            );
          } else {
            try {
              const dbName = 'EmmaBraveTest';
              const db = await new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                  const db = event.target.result;
                  if (!db.objectStoreNames.contains('testStore')) {
                    db.createObjectStore('testStore', { keyPath: 'id' });
                  }
                };
              });
              
              const transaction = db.transaction(['testStore'], 'readwrite');
              const store = transaction.objectStore('testStore');
              
              await new Promise((resolve, reject) => {
                const request = store.add({ id: 'test', data: testData });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
              });
              
              db.close();
              
              // Clean up
              await new Promise((resolve) => {
                const deleteRequest = indexedDB.deleteDatabase(dbName);
                deleteRequest.onsuccess = () => resolve();
                deleteRequest.onerror = () => resolve(); // Don't fail on cleanup
              });
              
              this.addTestResult(
                'IndexedDB',
                'pass',
                'IndexedDB working correctly'
              );
              
            } catch (idbError) {
              this.addTestResult(
                'IndexedDB',
                'fail',
                'IndexedDB operations failed',
                idbError.toString()
              );
            }
          }
          
          return true;
          
        } catch (error) {
          this.addTestResult(
            'Storage Test',
            'fail',
            'Error testing storage APIs',
            error.toString()
          );
          return false;
        }
      }
      
      async testEmmaVaultOperations() {
        console.log('üß™ Testing Emma vault operations in Brave...');
        
        try {
          // Test 1: Check if Emma scripts loaded
          const emmaWebVaultExists = typeof window.EmmaWebVault !== 'undefined';
          
          this.addTestResult(
            'Emma Scripts Loading',
            emmaWebVaultExists ? 'pass' : 'fail',
            emmaWebVaultExists ? 'Emma Web Vault class loaded successfully' : 'Emma Web Vault class not found'
          );
          
          if (!emmaWebVaultExists) {
            this.addTestResult(
              'Emma Vault Test',
              'fail',
              'Cannot test vault operations - Emma scripts not loaded'
            );
            return false;
          }
          
          // Test 2: Create test vault instance
          const testVault = new window.EmmaWebVault();
          
          this.addTestResult(
            'Emma Vault Instantiation',
            'pass',
            'Successfully created Emma vault instance'
          );
          
          // Test 3: Test encryption without file operations
          const testVaultData = {
            metadata: { name: 'Test Vault', version: '2.0' },
            content: { memories: {}, people: {}, media: {} },
            stats: { memoryCount: 0, peopleCount: 0, mediaCount: 0 }
          };
          
          const testPassphrase = 'test-passphrase-123';
          
          try {
            const encrypted = await testVault.nativeEncryptVault(testVaultData, testPassphrase);
            
            this.addTestResult(
              'Emma Vault Encryption',
              'pass',
              `Successfully encrypted test vault (${encrypted.length} bytes)`
            );
            
            // Test decryption
            const decrypted = await testVault.exactWorkingDecrypt(encrypted, testPassphrase);
            
            if (decrypted && decrypted.metadata && decrypted.metadata.name === 'Test Vault') {
              this.addTestResult(
                'Emma Vault Decryption',
                'pass',
                'Successfully decrypted test vault'
              );
            } else {
              this.addTestResult(
                'Emma Vault Decryption',
                'fail',
                'Vault decryption failed - data mismatch'
              );
            }
            
          } catch (cryptoError) {
            this.addTestResult(
              'Emma Vault Encryption',
              'fail',
              'Emma vault encryption failed',
              cryptoError.toString()
            );
          }
          
          return true;
          
        } catch (error) {
          this.addTestResult(
            'Emma Vault Test',
            'fail',
            'Error testing Emma vault operations',
            error.toString()
          );
          return false;
        }
      }
      
      async runAllBraveTests() {
        console.log('üöÄ Running comprehensive Brave compatibility tests...');
        
        // Clear previous results
        document.getElementById('testResults').innerHTML = '<h3>üß™ Brave-Specific Tests</h3>';
        this.testResults = [];
        
        try {
          await this.testFileSystemAccess();
          await this.testWebCrypto();
          await this.testStorage();
          await this.testEmmaVaultOperations();
          
          // Summary
          const passed = this.testResults.filter(r => r.status === 'pass').length;
          const failed = this.testResults.filter(r => r.status === 'fail').length;
          const warnings = this.testResults.filter(r => r.status === 'warn').length;
          
          let overallStatus = 'pass';
          let message = `All tests passed! Emma should work perfectly in ${this.isBrave ? 'Brave' : 'this browser'}.`;
          
          if (failed > 0) {
            overallStatus = 'fail';
            message = `${failed} critical issues found. Emma may not work properly.`;
          } else if (warnings > 0) {
            overallStatus = 'warn';
            message = `${warnings} warnings found. Emma will work but may require setup.`;
          }
          
          this.addTestResult(
            'Overall Brave Compatibility',
            overallStatus,
            `${message} (${passed} passed, ${failed} failed, ${warnings} warnings)`
          );
          
          // Brave-specific recommendations
          if (this.isBrave && failed > 0) {
            this.addTestResult(
              'Brave Setup Recommendation',
              'warn',
              'Please follow the Brave setup guide above to resolve compatibility issues'
            );
          }
          
        } catch (error) {
          this.addTestResult(
            'Test Suite Error',
            'fail',
            'Error running Brave compatibility tests',
            error.toString()
          );
        }
      }
    }
    
    // Global test functions
    let braveTest;
    
    window.addEventListener('DOMContentLoaded', () => {
      braveTest = new BraveCompatibilityTest();
      
      // Auto-run tests if this is Brave
      if (braveTest.isBrave) {
        setTimeout(() => braveTest.runAllBraveTests(), 1000);
      }
    });
    
    function runBraveTests() {
      braveTest.runAllBraveTests();
    }
    
    function testFileSystemAccess() {
      braveTest.testFileSystemAccess();
    }
    
    function testWebCrypto() {
      braveTest.testWebCrypto();
    }
    
    function testStorage() {
      braveTest.testStorage();
    }
    
    // Test actual file picker (interactive)
    async function testActualFilePicker() {
      try {
        if (!('showOpenFilePicker' in window)) {
          alert('‚ùå File System Access API not supported in this browser');
          return;
        }
        
        const [fileHandle] = await window.showOpenFilePicker({
          types: [{
            description: 'Any Files',
            accept: { '*/*': ['*'] }
          }],
          multiple: false
        });
        
        const file = await fileHandle.getFile();
        alert(`‚úÖ File picker works! Selected: ${file.name} (${file.size} bytes)`);
        
      } catch (error) {
        if (error.name === 'AbortError') {
          alert('‚ÑπÔ∏è File picker test cancelled');
        } else {
          alert(`‚ùå File picker test failed: ${error.message}`);
        }
      }
    }
  </script>
  
  <div style="margin-top: 30px; text-align: center;">
    <button onclick="testActualFilePicker()">üìÅ Test Actual File Picker</button>
    <p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
      ‚Üë This button tests if Brave allows file picker access
    </p>
  </div>
</body>
</html>
