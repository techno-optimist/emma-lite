<!DOCTYPE html>
<html>
<head>
  <title>Test Suite - Emma</title>
  <link rel="stylesheet" href="css/main.css">
  <style>
    .test-section {
      background: var(--emma-card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--emma-border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
    }
    
    .test-button {
      background: var(--emma-gradient-1);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(118, 75, 162, 0.3);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
    }
    
    .test-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(118, 75, 162, 0.4);
    }
    
    .log {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--emma-border);
      padding: 16px;
      margin: 16px 0;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      color: var(--emma-text-secondary);
    }
    
    .error { color: var(--emma-error); }
    .success { color: var(--emma-success); }
    
    .test-header {
      text-align: center;
      margin-bottom: 48px;
    }
    
    .emma-orb-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 auto;
      width: 120px;
      height: 120px;
    }
    
    .emma-orb {
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .emma-orb-fallback {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(147, 51, 234, 0.8), rgba(236, 72, 153, 0.6), rgba(6, 182, 212, 0.4));
      box-shadow: 
        0 0 30px rgba(147, 51, 234, 0.4),
        0 0 60px rgba(236, 72, 153, 0.3),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
      animation: emma-orb-float 4s ease-in-out infinite, emma-orb-pulse 2s ease-in-out infinite alternate;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      display: none;
    }
    
    .emma-orb:hover, .emma-orb-fallback:hover {
      transform: scale(1.1) translateY(-5px);
    }
    
    .emma-orb-fallback:hover {
      box-shadow: 
        0 0 40px rgba(147, 51, 234, 0.6),
        0 0 80px rgba(236, 72, 153, 0.4),
        inset 0 0 25px rgba(255, 255, 255, 0.15);
    }
    
    @keyframes emma-orb-float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes emma-orb-pulse {
      0% { opacity: 0.8; }
      100% { opacity: 1; }
    }
    
    @media (prefers-reduced-motion: reduce) {
      .emma-orb {
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="container fade-in">
    <div class="test-header">
      <div class="emma-orb-container">
        <canvas id="emma-orb-canvas" class="emma-orb" width="120" height="120"></canvas>
        <div id="emma-orb-fallback" class="emma-orb-fallback"></div>
      </div>
    </div>
    
    <div class="glass-card">
      <div class="test-section">
        <h3>Step 1: Test Basic Save</h3>
        <button class="test-button" onclick="testBasicSave()">
          <span>üíæ</span>
          <span>Test Save Memory</span>
        </button>
        <div id="save-result" class="log"></div>
      </div>
      
      <div class="test-section">
        <h3>Step 2: Test Retrieval</h3>
        <button class="test-button" onclick="testGetMemories()">
          <span>üìö</span>
          <span>Get All Memories</span>
        </button>
        <div id="get-result" class="log"></div>
      </div>
      
      <div class="test-section">
        <h3>Step 3: Test Stats</h3>
        <button class="test-button" onclick="testStats()">
          <span>üìä</span>
          <span>Get Stats</span>
        </button>
        <div id="stats-result" class="log"></div>
      </div>
      
      <div class="test-section">
        <h3>Step 4: Simulate ChatGPT Message</h3>
        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid var(--emma-border); padding: 20px; margin: 16px 0; border-radius: 12px;">
          <div style="margin-bottom: 12px; color: var(--emma-text);">
            <strong style="color: var(--emma-purple);">User:</strong> Hello, how are you?
          </div>
          <div style="color: var(--emma-text);">
            <strong style="color: var(--emma-pink);">Assistant:</strong> I'm doing well, thank you! How can I help you today?
          </div>
        </div>
        <button class="test-button" onclick="testChatGPTCapture()">
          <span>üéØ</span>
          <span>Capture This Conversation</span>
        </button>
        <div id="chatgpt-result" class="log"></div>
      </div>
    </div>
  </div>

  <script>
    function log(elementId, message, isError = false) {
      const element = document.getElementById(elementId);
      element.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}</span>`;
    }

    async function testBasicSave() {
      try {
        const response = await chrome.runtime.sendMessage({
          action: 'saveMemory',
          data: {
            content: 'Test memory created at ' + new Date().toISOString(),
            source: 'test',
            type: 'test',
            role: 'user'
          }
        });
        
        if (response.success) {
          log('save-result', `‚úÖ Memory saved! ID: ${response.memoryId}`);
        } else {
          log('save-result', `‚ùå Save failed: ${response.error}`, true);
        }
      } catch (error) {
        log('save-result', `‚ùå Error: ${error.message}`, true);
      }
    }

    async function testGetMemories() {
      try {
        const response = await chrome.runtime.sendMessage({
          action: 'getAllMemories',
          limit: 10,
          offset: 0
        });
        
        if (response.success) {
          const memories = response.memories;
          log('get-result', `‚úÖ Found ${memories.length} memories:\n${JSON.stringify(memories, null, 2)}`);
        } else {
          log('get-result', `‚ùå Failed: ${response.error}`, true);
        }
      } catch (error) {
        log('get-result', `‚ùå Error: ${error.message}`, true);
      }
    }

    async function testStats() {
      try {
        const response = await chrome.runtime.sendMessage({
          action: 'getStats'
        });
        
        if (response.success) {
          log('stats-result', `‚úÖ Stats:\n${JSON.stringify(response.stats, null, 2)}`);
        } else {
          log('stats-result', `‚ùå Failed: ${response.error}`, true);
        }
      } catch (error) {
        log('stats-result', `‚ùå Error: ${error.message}`, true);
      }
    }

    async function testChatGPTCapture() {
      try {
        // Simulate capturing two messages with detailed logging
        const messages = [
          {
            content: 'Hello, how are you? (Test message 1)',
            role: 'user',
            source: 'chatgpt',
            type: 'conversation'
          },
          {
            content: "I'm doing well, thank you! How can I help you today? (Test message 2)",
            role: 'assistant',
            source: 'chatgpt',
            type: 'conversation'
          }
        ];
        
        log('chatgpt-result', `üîç Starting to save ${messages.length} messages...`);
        
        let savedCount = 0;
        for (const message of messages) {
          console.log('üîç Saving message:', message);
          
          const response = await chrome.runtime.sendMessage({
            action: 'saveMemory',
            data: message
          });
          
          console.log('üîç Save response:', response);
          
          if (response.success) {
            savedCount++;
            log('chatgpt-result', `‚úÖ Message ${savedCount} saved with ID: ${response.memoryId}`);
          } else {
            log('chatgpt-result', `‚ùå Failed to save message ${savedCount + 1}: ${response.error}`, true);
          }
          
          // Small delay between saves
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Check final stats
        const statsResponse = await chrome.runtime.sendMessage({
          action: 'getStats'
        });
        
        console.log('üîç Final stats after save:', statsResponse);
        
        // Get all memories to verify
        const memoriesResponse = await chrome.runtime.sendMessage({
          action: 'getAllMemories',
          limit: 10
        });
        
        console.log('üîç All memories after save:', memoriesResponse);
        
        log('chatgpt-result', 
          `‚úÖ Captured ${savedCount} messages successfully!\n` +
          `üìä Total memories: ${statsResponse.success ? statsResponse.stats.totalMemories : 'Error'}\n` +
          `üìö Retrieved memories: ${memoriesResponse.success ? memoriesResponse.memories.length : 'Error'}`
        );
      } catch (error) {
        console.error('üîç Test error:', error);
        log('chatgpt-result', `‚ùå Error: ${error.message}`, true);
      }
    }

    // Emma Orb WebGL Implementation
    class EmmaOrb {
      constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        this.program = null;
        this.startTime = Date.now();
        this.animationId = null;
        
        if (this.gl) {
          this.init();
        } else {
          console.log('WebGL not supported, using CSS fallback');
          this.canvas.style.display = 'none';
          const fallback = document.getElementById('emma-orb-fallback');
          if (fallback) {
            fallback.style.display = 'block';
          }
        }
      }
      
      init() {
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.fragmentShaderSource);
        
        this.program = this.createProgram(vertexShader, fragmentShader);
        this.setupGeometry();
        this.render();
      }
      
      createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }
        
        return shader;
      }
      
      createProgram(vertexShader, fragmentShader) {
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
          console.error('Program linking error:', this.gl.getProgramInfoLog(program));
          this.gl.deleteProgram(program);
          return null;
        }
        
        return program;
      }
      
      setupGeometry() {
        const vertices = new Float32Array([
          -1, -1,
          1, -1,
          -1, 1,
          1, 1
        ]);
        
        const buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        
        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
        this.gl.enableVertexAttribArray(positionLocation);
        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
      }
      
      render() {
        const gl = this.gl;
        const time = (Date.now() - this.startTime) / 1000;
        
        gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        gl.useProgram(this.program);
        
        // Set uniforms
        const timeLocation = gl.getUniformLocation(this.program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(this.program, 'u_resolution');
        const hueLocation = gl.getUniformLocation(this.program, 'u_hue');
        
        gl.uniform1f(timeLocation, time);
        gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);
        gl.uniform1f(hueLocation, 250.0); // Emma's purple hue
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        this.animationId = requestAnimationFrame(() => this.render());
      }
      
      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
      }
      
      get vertexShaderSource() {
        return `
          attribute vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
      }
      
      get fragmentShaderSource() {
        return `
          precision mediump float;
          uniform float u_time;
          uniform vec2 u_resolution;
          uniform float u_hue;
          
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
          }
          
          void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(uv, center);
            
            // Create orb shape
            float circle = 1.0 - smoothstep(0.4, 0.5, dist);
            
            // Add flowing colors
            float hue = u_hue / 360.0 + sin(u_time * 0.5 + dist * 10.0) * 0.1;
            float sat = 0.8 + sin(u_time * 0.7 + uv.x * 5.0) * 0.2;
            float val = 0.9 + sin(u_time * 0.3 + uv.y * 8.0) * 0.1;
            
            vec3 color = hsv2rgb(vec3(hue, sat, val));
            
            // Add glow effect
            float glow = exp(-dist * 3.0) * 0.5;
            color += glow * vec3(0.5, 0.2, 1.0);
            
            gl_FragColor = vec4(color * circle, circle);
          }
        `;
      }
    }
    
    // Initialize Emma Orb
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('emma-orb-canvas');
      if (canvas) {
        new EmmaOrb(canvas);
      }
    });
  </script>
</body>
</html>